,Unnamed: 0,author,content,content_url,date,dtype,email_ID_from_label,id,subject
0,221.0,lburgazz...@apache.org,"Repository: camel&#010;Updated Branches:&#010;  refs/heads/master 55a61ed20 -&gt; d72696455&#010;&#010;&#010;HeaderSelectorProducer to support suppliers for header key and default value&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/d7269645&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/d7269645&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/d7269645&#010;&#010;Branch: refs/heads/master&#010;Commit: d7269645508cfd36b716547dab2f2da3ebe364ae&#010;Parents: 55a61ed&#010;Author: lburgazzoli &lt;lburgazzoli@gmail.com&gt;&#010;Authored: Fri Apr 14 12:42:05 2017 +0200&#010;Committer: lburgazzoli &lt;lburgazzoli@gmail.com&gt;&#010;Committed: Fri Apr 14 12:42:33 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; .../java/org/apache/camel/impl/HeaderSelectorProducer.java    | 7 ++++++-&#010; 1 file changed, 6 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/d7269645/camel-core/src/main/java/org/apache/camel/impl/HeaderSelectorProducer.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/impl/HeaderSelectorProducer.java b/camel-core/src/main/java/org/apache/camel/impl/HeaderSelectorProducer.java&#010;index f91f032..7d4b11e 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/impl/HeaderSelectorProducer.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/impl/HeaderSelectorProducer.java&#010;@@ -48,6 +48,7 @@ public class HeaderSelectorProducer extends BaseSelectorProducer {&#010;     public HeaderSelectorProducer(Endpoint endpoint, Supplier&lt;String&gt; headerSupplier)&#010;{&#010;         this(endpoint, headerSupplier, () -&gt; null, null);&#010;     }&#010;+&#010;     public HeaderSelectorProducer(Endpoint endpoint, String header) {&#010;         this(endpoint, () -&gt; header, () -&gt; null, null);&#010;     }&#010;@@ -64,6 +65,10 @@ public class HeaderSelectorProducer extends BaseSelectorProducer {&#010;         this(endpoint, () -&gt; header, () -&gt; defaultHeaderValue, null);&#010;     }&#010; &#010;+    public HeaderSelectorProducer(Endpoint endpoint, String header, Supplier&lt;String&gt;&#010;defaultHeaderValueSupplier) {&#010;+        this(endpoint, () -&gt; header, defaultHeaderValueSupplier, null);&#010;+    }&#010;+&#010;     public HeaderSelectorProducer(Endpoint endpoint, Supplier&lt;String&gt; headerSupplier,&#010;Supplier&lt;String&gt; defaultHeaderValueSupplier) {&#010;         this(endpoint, headerSupplier, defaultHeaderValueSupplier, null);&#010;     }&#010;@@ -102,7 +107,7 @@ public class HeaderSelectorProducer extends BaseSelectorProducer {&#010;     @Override&#010;     protected Processor getProcessor(Exchange exchange) throws Exception {&#010;         String header = headerSupplier.get();&#010;-        String action = exchange.getIn().getHeader(headerSupplier.get(), String.class);&#010;+        String action = exchange.getIn().getHeader(header, String.class);&#010; &#010;         if (action == null) {&#010;             action = defaultHeaderValueSupplier.get();&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C9d2d740f77794180b53412948340828f%40git.apache.org%3E,2017-04-14 10:42,commits,1.0,221.0,  camel git commit: HeaderSelectorProducer to support suppliers for header key and default value
1,322.0,davscl...@apache.org,"Repository: camel&#010;Updated Branches:&#010;  refs/heads/master d72696455 -&gt; 6b42a3534&#010;&#010;&#010;Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/6b42a353&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/6b42a353&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/6b42a353&#010;&#010;Branch: refs/heads/master&#010;Commit: 6b42a3534120f58180e6194e6bf4f1a284707abc&#010;Parents: c66be7a&#010;Author: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Authored: Fri Apr 14 12:17:14 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:52:40 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; platforms/camel-catalog/pom.xml | 40 ++++++++++++++++++++++++++++++++++--&#010; 1 file changed, 38 insertions(+), 2 deletions(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/6b42a353/platforms/camel-catalog/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/platforms/camel-catalog/pom.xml b/platforms/camel-catalog/pom.xml&#010;index 2be82e0..6c71fcb 100644&#010;--- a/platforms/camel-catalog/pom.xml&#010;+++ b/platforms/camel-catalog/pom.xml&#010;@@ -92,7 +92,7 @@&#010;         &lt;executions&gt;&#010;           &lt;execution&gt;&#010;             &lt;id&gt;copy-resources&lt;/id&gt;&#010;-            &lt;phase&gt;process-sources&lt;/phase&gt;&#010;+            &lt;phase&gt;generate-sources&lt;/phase&gt;&#010;             &lt;goals&gt;&#010;               &lt;goal&gt;copy-resources&lt;/goal&gt;&#010;             &lt;/goals&gt;&#010;@@ -101,7 +101,7 @@&#010;               &lt;overwrite&gt;true&lt;/overwrite&gt;&#010;               &lt;resources&gt;&#010;                 &lt;resource&gt;&#010;-                  &lt;directory&gt;../../camel-core/src/main/java/org/apache/camel/catalog&lt;/directory&gt;&#010;+                  &lt;directory&gt;../../camel-core/src/main/java/org/apache/camel/runtimecatalog&lt;/directory&gt;&#010;                   &lt;!-- the following files are maintained in camel-core and not here,&#010;so they are copied over --&gt;&#010;                   &lt;includes&gt;&#010;                     &lt;include&gt;AbstractCamelCatalog.java&lt;/include&gt;&#010;@@ -123,6 +123,42 @@&#010;           &lt;/execution&gt;&#010;         &lt;/executions&gt;&#010;       &lt;/plugin&gt;&#010;+      &lt;!-- rename runtimecatalog to catalog which is the package name we use here --&gt;&#010;+      &lt;plugin&gt;&#010;+        &lt;groupId&gt;com.google.code.maven-replacer-plugin&lt;/groupId&gt;&#010;+        &lt;artifactId&gt;replacer&lt;/artifactId&gt;&#010;+        &lt;version&gt;1.5.3&lt;/version&gt;&#010;+        &lt;executions&gt;&#010;+          &lt;execution&gt;&#010;+            &lt;phase&gt;process-sources&lt;/phase&gt;&#010;+            &lt;goals&gt;&#010;+              &lt;goal&gt;replace&lt;/goal&gt;&#010;+            &lt;/goals&gt;&#010;+          &lt;/execution&gt;&#010;+        &lt;/executions&gt;&#010;+        &lt;configuration&gt;&#010;+          &lt;includes&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/AbstractCamelCatalog.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/CatalogHelper.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/CollectionStringBuffer.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/URISupport.java&lt;/include&gt;&#010;+          &lt;/includes&gt;&#010;+          &lt;replacements&gt;&#010;+            &lt;replacement&gt;&#010;+              &lt;token&gt;org.apache.camel.runtimecatalog&lt;/token&gt;&#010;+              &lt;value&gt;org.apache.camel.catalog&lt;/value&gt;&#010;+            &lt;/replacement&gt;&#010;+          &lt;/replacements&gt;&#010;+        &lt;/configuration&gt;&#010;+      &lt;/plugin&gt;&#010; &#010;       &lt;!-- generate and include all components in the catalog --&gt;&#010;       &lt;plugin&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cde5de0a2e2ca40e6bcaa03835723a40e%40git.apache.org%3E,2017-04-14 10:52,commits,2.0,322.0,[1/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
2,323.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;b/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;new file mode 100644&#010;index 0000000..309fb8e&#010;--- /dev/null&#010;+++ b/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;@@ -0,0 +1,104 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.net.URISyntaxException;&#010;+import java.util.HashMap;&#010;+import java.util.Map;&#010;+&#010;+import org.junit.Before;&#010;+import org.junit.Test;&#010;+&#010;+import static org.easymock.EasyMock.expect;&#010;+import static org.easymock.EasyMock.mock;&#010;+import static org.easymock.EasyMock.replay;&#010;+import static org.junit.Assert.assertEquals;&#010;+&#010;+public class AbstractCamelCatalogTest {&#010;+&#010;+    AbstractCamelCatalog catalog = new AbstractCamelCatalog() {&#010;+    };&#010;+&#010;+    JSonSchemaResolver resolver;&#010;+&#010;+    @Before&#010;+    public void setupMockCatalog() {&#010;+        resolver = mock(JSonSchemaResolver.class);&#010;+&#010;+        catalog.setJSonSchemaResolver(resolver);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void shouldConstructEndpointUris() throws URISyntaxException {&#010;+        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;+            + ""  \""component\"": {\n""//&#010;+            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;+            + ""  }\n""//&#010;+            + ""}"");&#010;+&#010;+        replay(resolver);&#010;+&#010;+        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;+        properties.put(""param1"", ""value1"");&#010;+        properties.put(""param2"", ""value2"");&#010;+        properties.put(""param3"", ""value3"");&#010;+&#010;+        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;+&#010;+        assertEquals(""comp:value1:value2?param3=value3"", endpointUri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void shouldConstructEndpointUrisWithPropertyPlaceholders() throws URISyntaxException&#010;{&#010;+        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;+            + ""  \""component\"": {\n""//&#010;+            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;+            + ""  }\n""//&#010;+            + ""}"");&#010;+&#010;+        replay(resolver);&#010;+&#010;+        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;+        properties.put(""param1"", ""{{prop1}}"");&#010;+        properties.put(""param2"", ""{{prop2}}"");&#010;+        properties.put(""param3"", ""{{prop3}}"");&#010;+&#010;+        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;+&#010;+        assertEquals(""comp:{{prop1}}:{{prop2}}?param3={{prop3}}"", endpointUri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void shouldConstructEndpointUrisWhenValuesContainTokens() throws URISyntaxException&#010;{&#010;+        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;+            + ""  \""component\"": {\n""//&#010;+            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;+            + ""  }\n""//&#010;+            + ""}"");&#010;+&#010;+        replay(resolver);&#010;+&#010;+        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;+        properties.put(""param1"", ""{value1}"");&#010;+        properties.put(""param2"", ""/value2/"");&#010;+        properties.put(""param3"", ""/value3/{param}"");&#010;+&#010;+        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;+&#010;+        assertEquals(""comp:{value1}:/value2/?param3=/value3/{param}"", endpointUri);&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;b/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;new file mode 100644&#010;index 0000000..dfdd5c5&#010;--- /dev/null&#010;+++ b/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;@@ -0,0 +1,393 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.HashMap;&#010;+import java.util.Map;&#010;+&#010;+import org.apache.camel.impl.DefaultCamelContext;&#010;+import org.junit.BeforeClass;&#010;+import org.junit.Test;&#010;+import org.slf4j.Logger;&#010;+import org.slf4j.LoggerFactory;&#010;+&#010;+import static org.junit.Assert.assertEquals;&#010;+import static org.junit.Assert.assertFalse;&#010;+import static org.junit.Assert.assertNotNull;&#010;+import static org.junit.Assert.assertTrue;&#010;+&#010;+public class RuntimeCamelCatalogTest {&#010;+&#010;+    static RuntimeCamelCatalog catalog;&#010;+&#010;+    private static final Logger LOG = LoggerFactory.getLogger(RuntimeCamelCatalogTest.class);&#010;+&#010;+    @BeforeClass&#010;+    public static void createCamelCatalog() {&#010;+        catalog = new DefaultRuntimeCamelCatalog(new DefaultCamelContext());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testFromCamelContext() throws Exception {&#010;+        String schema = new DefaultCamelContext().getRuntimeCamelCatalog().modelJSonSchema(""choice"");&#010;+        assertNotNull(schema);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testJsonSchema() throws Exception {&#010;+        String schema = catalog.modelJSonSchema(""aggregate"");&#010;+        assertNotNull(schema);&#010;+&#010;+        // lets make it possible to find bean/method using both names&#010;+        schema = catalog.modelJSonSchema(""method"");&#010;+        assertNotNull(schema);&#010;+        schema = catalog.modelJSonSchema(""bean"");&#010;+        assertNotNull(schema);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriMapFile() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""directoryName"", ""src/data/inbox"");&#010;+        map.put(""noop"", ""true"");&#010;+        map.put(""delay"", ""5000"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""file"", map, true);&#010;+        assertEquals(""file:src/data/inbox?delay=5000&amp;noop=true"", uri);&#010;+&#010;+        String uri2 = catalog.asEndpointUriXml(""file"", map, true);&#010;+        assertEquals(""file:src/data/inbox?delay=5000&amp;amp;noop=true"", uri2);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriTimer() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""timerName"", ""foo"");&#010;+        map.put(""period"", ""5000"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;+        assertEquals(""timer:foo?period=5000"", uri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriPropertiesPlaceholders() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""timerName"", ""foo"");&#010;+        map.put(""period"", ""{{howoften}}"");&#010;+        map.put(""repeatCount"", ""5"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;+        assertEquals(""timer:foo?period=%7B%7Bhowoften%7D%7D&amp;repeatCount=5"", uri);&#010;+&#010;+        uri = catalog.asEndpointUri(""timer"", map, false);&#010;+        assertEquals(""timer:foo?period={{howoften}}&amp;repeatCount=5"", uri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriBeanLookup() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""resourceUri"", ""foo.xslt"");&#010;+        map.put(""converter"", ""#myConverter"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""xslt"", map, true);&#010;+        assertEquals(""xslt:foo.xslt?converter=%23myConverter"", uri);&#010;+&#010;+        uri = catalog.asEndpointUri(""xslt"", map, false);&#010;+        assertEquals(""xslt:foo.xslt?converter=#myConverter"", uri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testEndpointPropertiesPlaceholders() throws Exception {&#010;+        Map&lt;String, String&gt; map = catalog.endpointProperties(""timer:foo?period={{howoften}}&amp;repeatCount=5"");&#010;+        assertNotNull(map);&#010;+        assertEquals(3, map.size());&#010;+&#010;+        assertEquals(""foo"", map.get(""timerName""));&#010;+        assertEquals(""{{howoften}}"", map.get(""period""));&#010;+        assertEquals(""5"", map.get(""repeatCount""));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriLog() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""loggerName"", ""foo"");&#010;+        map.put(""loggerLevel"", ""WARN"");&#010;+        map.put(""multiline"", ""true"");&#010;+        map.put(""showAll"", ""true"");&#010;+        map.put(""showBody"", ""false"");&#010;+        map.put(""showBodyType"", ""false"");&#010;+        map.put(""showExchangePattern"", ""false"");&#010;+        map.put(""style"", ""Tab"");&#010;+&#010;+        assertEquals(""log:foo?loggerLevel=WARN&amp;multiline=true&amp;showAll=true&amp;style=Tab"",&#010;catalog.asEndpointUri(""log"", map, false));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriLogShort() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""loggerName"", ""foo"");&#010;+        map.put(""loggerLevel"", ""DEBUG"");&#010;+&#010;+        assertEquals(""log:foo?loggerLevel=DEBUG"", catalog.asEndpointUri(""log"", map, false));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriWithplaceholder() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""name"", ""foo"");&#010;+        map.put(""blockWhenFull"", ""{{block}}"");&#010;+        assertEquals(""seda:foo?blockWhenFull={{block}}"", catalog.asEndpointUri(""seda"", map,&#010;false));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testEndpointPropertiesSedaRequired() throws Exception {&#010;+        Map&lt;String, String&gt; map = catalog.endpointProperties(""seda:foo"");&#010;+        assertNotNull(map);&#010;+        assertEquals(1, map.size());&#010;+&#010;+        assertEquals(""foo"", map.get(""name""));&#010;+&#010;+        map = catalog.endpointProperties(""seda:foo?blockWhenFull=true"");&#010;+        assertNotNull(map);&#010;+        assertEquals(2, map.size());&#010;+&#010;+        assertEquals(""foo"", map.get(""name""));&#010;+        assertEquals(""true"", map.get(""blockWhenFull""));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void validateProperties() throws Exception {&#010;+        // valid&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(""log:mylog"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // unknown&#010;+        result = catalog.validateEndpointProperties(""log:mylog?level=WARN&amp;foo=bar"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getUnknown().contains(""foo""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // enum&#010;+        result = catalog.validateEndpointProperties(""seda:foo?waitForTaskToComplete=blah"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""blah"", result.getInvalidEnum().get(""waitForTaskToComplete""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // reference okay&#010;+        result = catalog.validateEndpointProperties(""seda:foo?queue=#queue"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(0, result.getNumberOfErrors());&#010;+&#010;+        // unknown component&#010;+        result = catalog.validateEndpointProperties(""foo:bar?me=you"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getUnknownComponent().equals(""foo""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // invalid boolean but default value&#010;+        result = catalog.validateEndpointProperties(""log:output?showAll=ggg"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""ggg"", result.getInvalidBoolean().get(""showAll""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // dataset&#010;+        result = catalog.validateEndpointProperties(""dataset:foo?minRate=50"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // time pattern&#010;+        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=true&amp;delay=0&amp;period=2s"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // reference lookup&#010;+        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=#fixed&amp;delay=#myDelay"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // optional consumer. prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?consumer.delay=5000&amp;consumer.greedy=true"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // optional without consumer. prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;greedy=true"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // mixed optional without consumer. prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;consumer.greedy=true"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;scheduler.foo=123&amp;scheduler.bar=456"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // stub&#010;+        result = catalog.validateEndpointProperties(""stub:foo?me=123&amp;you=456"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // lenient on&#010;+        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // lenient off&#010;+        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"",&#010;true);&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getUnknown().contains(""foo""));&#010;+&#010;+        // data format&#010;+        result = catalog.validateEndpointProperties(""dataformat:string:marshal?charset=utf-8"",&#010;true);&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // incapable to parse&#010;+        result = catalog.validateEndpointProperties(""{{getFtpUrl}}?recursive=true"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getIncapable() != null);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void validatePropertiesSummary() throws Exception {&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(""yammer:MESSAGES?blah=yada&amp;accessToken=aaa&amp;consumerKey=&amp;useJson=no&amp;initialDelay=five&amp;pollStrategy=myStrategy"");&#010;+        assertFalse(result.isSuccess());&#010;+        String reason = result.summaryErrorMessage(true);&#010;+        LOG.info(reason);&#010;+&#010;+        result = catalog.validateEndpointProperties(""jms:unknown:myqueue"");&#010;+        assertFalse(result.isSuccess());&#010;+        reason = result.summaryErrorMessage(false);&#010;+        LOG.info(reason);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void validateTimePattern() throws Exception {&#010;+        assertTrue(catalog.validateTimePattern(""0""));&#010;+        assertTrue(catalog.validateTimePattern(""500""));&#010;+        assertTrue(catalog.validateTimePattern(""10000""));&#010;+        assertTrue(catalog.validateTimePattern(""5s""));&#010;+        assertTrue(catalog.validateTimePattern(""5sec""));&#010;+        assertTrue(catalog.validateTimePattern(""5secs""));&#010;+        assertTrue(catalog.validateTimePattern(""3m""));&#010;+        assertTrue(catalog.validateTimePattern(""3min""));&#010;+        assertTrue(catalog.validateTimePattern(""3minutes""));&#010;+        assertTrue(catalog.validateTimePattern(""5m15s""));&#010;+        assertTrue(catalog.validateTimePattern(""1h""));&#010;+        assertTrue(catalog.validateTimePattern(""1hour""));&#010;+        assertTrue(catalog.validateTimePattern(""2hours""));&#010;+&#010;+        assertFalse(catalog.validateTimePattern(""bla""));&#010;+        assertFalse(catalog.validateTimePattern(""2year""));&#010;+        assertFalse(catalog.validateTimePattern(""60darn""));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testEndpointComponentName() throws Exception {&#010;+        String name = catalog.endpointComponentName(""jms:queue:foo"");&#010;+        assertEquals(""jms"", name);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testSimpleExpression() throws Exception {&#010;+        SimpleValidationResult result = catalog.validateSimpleExpression(null, ""${body}"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body}"", result.getSimple());&#010;+&#010;+        result = catalog.validateSimpleExpression(null, ""${body"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""${body"", result.getSimple());&#010;+        LOG.info(result.getError());&#010;+        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol&#010;at location 5""));&#010;+        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;+        assertEquals(5, result.getIndex());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testSimplePredicate() throws Exception {&#010;+        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} ==&#010;'abc'"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body} == 'abc'"", result.getSimple());&#010;+&#010;+        result = catalog.validateSimplePredicate(null, ""${body} &gt; ${header.size"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""${body} &gt; ${header.size"", result.getSimple());&#010;+        LOG.info(result.getError());&#010;+        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol&#010;at location 22""));&#010;+        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;+        assertEquals(22, result.getIndex());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testSimplePredicatePlaceholder() throws Exception {&#010;+        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} contains&#010;'{{danger}}'"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body} contains '{{danger}}'"", result.getSimple());&#010;+&#010;+        result = catalog.validateSimplePredicate(null, ""${bdy} contains '{{danger}}'"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""${bdy} contains '{{danger}}'"", result.getSimple());&#010;+        LOG.info(result.getError());&#010;+        assertTrue(result.getError().startsWith(""Unknown function: bdy at location 0""));&#010;+        assertTrue(result.getError().contains(""'{{danger}}'""));&#010;+        assertEquals(""Unknown function: bdy"", result.getShortError());&#010;+        assertEquals(0, result.getIndex());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testValidateLanguage() throws Exception {&#010;+        LanguageValidationResult result = catalog.validateLanguageExpression(null, ""simple"",&#010;""${body}"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body}"", result.getText());&#010;+&#010;+        result = catalog.validateLanguageExpression(null, ""header"", ""foo"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""foo"", result.getText());&#010;+&#010;+        result = catalog.validateLanguagePredicate(null, ""simple"", ""${body} &gt; 10"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body} &gt; 10"", result.getText());&#010;+&#010;+        result = catalog.validateLanguagePredicate(null, ""header"", ""bar"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""bar"", result.getText());&#010;+&#010;+        result = catalog.validateLanguagePredicate(null, ""foobar"", ""bar"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""Unknown language foobar"", result.getError());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testValidateEndpointConsumerOnly() throws Exception {&#010;+        String uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true"";&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false,&#010;true, false);&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true&amp;fileExist=Append"";&#010;+        result = catalog.validateEndpointProperties(uri, false, true, false);&#010;+        assertFalse(result.isSuccess());&#010;+&#010;+        assertEquals(""fileExist"", result.getNotConsumerOnly().iterator().next());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testValidateEndpointProducerOnly() throws Exception {&#010;+        String uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append"";&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false,&#010;false, true);&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append&amp;delete=true"";&#010;+        result = catalog.validateEndpointProperties(uri, false, false, true);&#010;+        assertFalse(result.isSuccess());&#010;+&#010;+        assertEquals(""delete"", result.getNotProducerOnly().iterator().next());&#010;+    }&#010;+&#010;+}&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C9e3f964e77d045cf840b002cc3565efe%40git.apache.org%3E,2017-04-14 10:52,commits,2.0,323.0,  [2/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
3,324.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java&#010;new file mode 100644&#010;index 0000000..1e69269&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java&#010;@@ -0,0 +1,424 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.ArrayList;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.LinkedHashSet;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+import java.util.Set;&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+public final class JSonSchemaHelper {&#010;+&#010;+    // 0 = text, 1 = enum, 2 = boolean, 3 = integer or number&#010;+    private static final Pattern PATTERN = Pattern.compile(""\""(.+?)\""|\\[(.+)\\]|(true|false)|(-?\\d+\\.?\\d*)"");&#010;+    private static final String QUOT = ""&amp;quot;"";&#010;+&#010;+    private JSonSchemaHelper() {&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the json schema to split it into a list or rows, where each row contains key value pairs with the metadata&#010;+     *&#010;+     * @param group the group to parse from such as &lt;tt&gt;component&lt;/tt&gt;, &lt;tt&gt;componentProperties&lt;/tt&gt;, or &lt;tt&gt;properties&lt;/tt&gt;.&#010;+     * @param json the json&#010;+     * @return a list of all the rows, where each row is a set of key value pairs with metadata&#010;+     */&#010;+    public static List&lt;Map&lt;String, String&gt;&gt; parseJsonSchema(String group, String json, boolean parseProperties) {&#010;+        List&lt;Map&lt;String, String&gt;&gt; answer = new ArrayList&lt;Map&lt;String, String&gt;&gt;();&#010;+        if (json == null) {&#010;+            return answer;&#010;+        }&#010;+&#010;+        boolean found = false;&#010;+&#010;+        // parse line by line&#010;+        String[] lines = json.split(""\n"");&#010;+        for (String line : lines) {&#010;+            // we need to find the group first&#010;+            if (!found) {&#010;+                String s = line.trim();&#010;+                found = s.startsWith(""\"""" + group + ""\"":"") &amp;&amp; s.endsWith(""{"");&#010;+                continue;&#010;+            }&#010;+&#010;+            // we should stop when we end the group&#010;+            if (line.equals(""  },"") || line.equals(""  }"")) {&#010;+                break;&#010;+            }&#010;+&#010;+            // need to safe encode \"" so we can parse the line&#010;+            line = line.replaceAll(""\""\\\\\""\"""", '""' + QUOT + '""');&#010;+&#010;+            Map&lt;String, String&gt; row = new LinkedHashMap&lt;String, String&gt;();&#010;+            Matcher matcher = PATTERN.matcher(line);&#010;+&#010;+            String key;&#010;+            if (parseProperties) {&#010;+                // when parsing properties the first key is given as name, so the first parsed token is the value of the name&#010;+                key = ""name"";&#010;+            } else {&#010;+                key = null;&#010;+            }&#010;+            while (matcher.find()) {&#010;+                if (key == null) {&#010;+                    key = matcher.group(1);&#010;+                } else {&#010;+                    String value = matcher.group(1);&#010;+                    if (value != null) {&#010;+                        // its text based&#010;+                        value = value.trim();&#010;+                        // decode&#010;+                        value = value.replaceAll(QUOT, ""\"""");&#010;+                        value = decodeJson(value);&#010;+                    }&#010;+                    if (value == null) {&#010;+                        // not text then its maybe an enum?&#010;+                        value = matcher.group(2);&#010;+                        if (value != null) {&#010;+                            // its an enum so strip out "" and trim spaces after comma&#010;+                            value = value.replaceAll(""\"""", """");&#010;+                            value = value.replaceAll("", "", "","");&#010;+                            value = value.trim();&#010;+                        }&#010;+                    }&#010;+                    if (value == null) {&#010;+                        // not text then its maybe a boolean?&#010;+                        value = matcher.group(3);&#010;+                    }&#010;+                    if (value == null) {&#010;+                        // not text then its maybe a integer?&#010;+                        value = matcher.group(4);&#010;+                    }&#010;+                    if (value != null) {&#010;+                        row.put(key, value);&#010;+                    }&#010;+                    // reset&#010;+                    key = null;&#010;+                }&#010;+            }&#010;+            if (!row.isEmpty()) {&#010;+                answer.add(row);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    private static String decodeJson(String value) {&#010;+        // json encodes a \ as \\ so we need to decode from \\ back to \&#010;+        if (""\\\\"".equals(value)) {&#010;+            value = ""\\"";&#010;+        }&#010;+        return value;&#010;+    }&#010;+&#010;+    public static boolean isComponentLenientProperties(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""lenientProperties"")) {&#010;+                return ""true"".equals(row.get(""lenientProperties""));&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isComponentConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""consumerOnly"")) {&#010;+                return ""true"".equals(row.get(""consumerOnly""));&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isComponentProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""producerOnly"")) {&#010;+                return ""true"".equals(row.get(""producerOnly""));&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String labels = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""label"")) {&#010;+                labels = row.get(""label"");&#010;+            }&#010;+            if (found) {&#010;+                return labels != null &amp;&amp; labels.contains(""consumer"");&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String labels = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""label"")) {&#010;+                labels = row.get(""label"");&#010;+            }&#010;+            if (found) {&#010;+                return labels != null &amp;&amp; labels.contains(""producer"");&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyRequired(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            boolean required = false;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""required"")) {&#010;+                required = ""true"".equals(row.get(""required""));&#010;+            }&#010;+            if (found) {&#010;+                return required;&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static String getPropertyKind(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String kind = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""kind"")) {&#010;+                kind = row.get(""kind"");&#010;+            }&#010;+            if (found) {&#010;+                return kind;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static boolean isPropertyBoolean(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""boolean"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyInteger(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""integer"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyNumber(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""number"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyObject(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""object"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static String getPropertyDefaultValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String defaultValue = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""defaultValue"")) {&#010;+                defaultValue = row.get(""defaultValue"");&#010;+            }&#010;+            if (found) {&#010;+                return defaultValue;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static String stripOptionalPrefixFromName(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String optionalPrefix = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""optionalPrefix"")) {&#010;+                optionalPrefix = row.get(""optionalPrefix"");&#010;+            }&#010;+            if (row.containsKey(""name"")) {&#010;+                if (optionalPrefix != null &amp;&amp; name.startsWith(optionalPrefix)) {&#010;+                    name = name.substring(optionalPrefix.length());&#010;+                    // try again&#010;+                    return stripOptionalPrefixFromName(rows, name);&#010;+                } else {&#010;+                    found = name.equals(row.get(""name""));&#010;+                }&#010;+            }&#010;+            if (found) {&#010;+                return name;&#010;+            }&#010;+        }&#010;+        return name;&#010;+    }&#010;+&#010;+    public static String getPropertyEnum(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String enums = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""enum"")) {&#010;+                enums = row.get(""enum"");&#010;+            }&#010;+            if (found) {&#010;+                return enums;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static String getPropertyPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String prefix = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""prefix"")) {&#010;+                prefix = row.get(""prefix"");&#010;+            }&#010;+            if (found) {&#010;+                return prefix;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static boolean isPropertyMultiValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            boolean multiValue = false;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""multiValue"")) {&#010;+                multiValue = ""true"".equals(row.get(""multiValue""));&#010;+            }&#010;+            if (found) {&#010;+                return multiValue;&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static String getPropertyNameFromNameWithPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String propertyName = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                propertyName = row.get(""name"");&#010;+            }&#010;+            if (row.containsKey(""prefix"")) {&#010;+                String preifx = row.get(""prefix"");&#010;+                found = name.startsWith(preifx);&#010;+            }&#010;+            if (found) {&#010;+                return propertyName;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static Map&lt;String, String&gt; getRow(List&lt;Map&lt;String, String&gt;&gt; rows, String key) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (key.equals(row.get(""name""))) {&#010;+                return row;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static Set&lt;String&gt; getNames(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        Set&lt;String&gt; answer = new LinkedHashSet&lt;String&gt;();&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""name"")) {&#010;+                answer.add(row.get(""name""));&#010;+            }&#010;+        }&#010;+        return answer;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java&#010;new file mode 100644&#010;index 0000000..dbd6f45&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java&#010;@@ -0,0 +1,64 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+/**&#010;+ * Pluggable resolver to load JSon schema files for components, data formats, languages etc.&#010;+ */&#010;+public interface JSonSchemaResolver {&#010;+&#010;+    /**&#010;+     * Returns the component information as JSon format.&#010;+     *&#010;+     * @param name the component name&#010;+     * @return component details in JSon&#010;+     */&#010;+    String getComponentJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the data format information as JSon format.&#010;+     *&#010;+     * @param name the data format name&#010;+     * @return data format details in JSon&#010;+     */&#010;+    String getDataFormatJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the language information as JSon format.&#010;+     *&#010;+     * @param name the language name&#010;+     * @return language details in JSon&#010;+     */&#010;+    String getLanguageJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the other (miscellaneous) information as JSon format.&#010;+     *&#010;+     * @param name the other (miscellaneous) name&#010;+     * @return other (miscellaneous) details in JSon&#010;+     */&#010;+    String getOtherJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the model information as JSon format.&#010;+     *&#010;+     * @param name the model name&#010;+     * @return model details in JSon&#010;+     */&#010;+    String getModelJSonSchema(String name);&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java&#010;new file mode 100644&#010;index 0000000..dbb5525&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java&#010;@@ -0,0 +1,65 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.Serializable;&#010;+&#010;+/**&#010;+ * Validation result of parsing a language expression or predicate&#010;+ */&#010;+public class LanguageValidationResult implements Serializable {&#010;+    private final String text;&#010;+    private String error;&#010;+    private String shortError;&#010;+    private int index;&#010;+&#010;+    public LanguageValidationResult(String text) {&#010;+        this.text = text;&#010;+    }&#010;+&#010;+    public String getText() {&#010;+        return text;&#010;+    }&#010;+&#010;+    public boolean isSuccess() {&#010;+        return error == null;&#010;+    }&#010;+&#010;+    public void setError(String error) {&#010;+        this.error = error;&#010;+    }&#010;+&#010;+    public String getError() {&#010;+        return error;&#010;+    }&#010;+&#010;+    public String getShortError() {&#010;+        return shortError;&#010;+    }&#010;+&#010;+    public void setShortError(String shortError) {&#010;+        this.shortError = shortError;&#010;+    }&#010;+&#010;+    public int getIndex() {&#010;+        return index;&#010;+    }&#010;+&#010;+    public void setIndex(int index) {&#010;+        this.index = index;&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java&#010;new file mode 100644&#010;index 0000000..86c4b53&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java&#010;@@ -0,0 +1,234 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.net.URISyntaxException;&#010;+import java.util.Map;&#010;+&#010;+import org.apache.camel.StaticService;&#010;+&#010;+/**&#010;+ * Runtime based CamelCatalog which are included in camel-core that can provided limit CamelCatalog capabilities&#010;+ */&#010;+public interface RuntimeCamelCatalog extends StaticService {&#010;+&#010;+    /**&#010;+     * Returns the component information as JSon format.&#010;+     *&#010;+     * @param name the component name&#010;+     * @return component details in JSon&#010;+     */&#010;+    String componentJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the data format information as JSon format.&#010;+     *&#010;+     * @param name the data format name&#010;+     * @return data format details in JSon&#010;+     */&#010;+    String dataFormatJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the language information as JSon format.&#010;+     *&#010;+     * @param name the language name&#010;+     * @return language details in JSon&#010;+     */&#010;+    String languageJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the model information as JSon format.&#010;+     *&#010;+     * @param name the model name&#010;+     * @return model details in JSon&#010;+     */&#010;+    String modelJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Parses the endpoint uri and constructs a key/value properties of each option&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return properties as key value pairs of each endpoint option&#010;+     */&#010;+    Map&lt;String, String&gt; endpointProperties(String uri) throws URISyntaxException;&#010;+&#010;+    /**&#010;+     * Parses the endpoint uri and constructs a key/value properties of only the lenient properties (eg custom options)&#010;+     * &lt;p/&gt;&#010;+     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return properties as key value pairs of each lenient properties&#010;+     */&#010;+    Map&lt;String, String&gt; endpointLenientProperties(String uri) throws URISyntaxException;&#010;+&#010;+    /**&#010;+     * Validates the pattern whether its a valid time pattern.&#010;+     *&#010;+     * @param pattern  the pattern such as 5000, 5s, 5sec, 4min, 4m30s, 1h, etc.&#010;+     * @return &lt;tt&gt;true&lt;/tt&gt; if valid, &lt;tt&gt;false&lt;/tt&gt; if invalid&#010;+     */&#010;+    boolean validateTimePattern(String pattern);&#010;+&#010;+    /**&#010;+     * Validates the properties for the given scheme against component and endpoint&#010;+     *&#010;+     * @param scheme  the endpoint scheme&#010;+     * @param properties  the endpoint properties&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateProperties(String scheme, Map&lt;String, String&gt; properties);&#010;+&#010;+    /**&#010;+     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateEndpointProperties(String uri);&#010;+&#010;+    /**&#010;+     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;+     * &lt;p/&gt;&#010;+     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;+     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;+     * but in the uri because of using lenient properties.&#010;+     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties);&#010;+&#010;+    /**&#010;+     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;+     * &lt;p/&gt;&#010;+     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;+     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;+     * but in the uri because of using lenient properties.&#010;+     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;+     * @param consumerOnly whether the endpoint is only used as a consumer&#010;+     * @param producerOnly whether the endpoint is only used as a producer&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties, boolean consumerOnly, boolean producerOnly);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple expression.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param simple  the simple expression&#010;+     * @return validation result&#010;+     * @deprecated use {@link #validateSimpleExpression(ClassLoader, String)}&#010;+     */&#010;+    @Deprecated&#010;+    SimpleValidationResult validateSimpleExpression(String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple expression.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param simple  the simple expression&#010;+     * @return validation result&#010;+     */&#010;+    SimpleValidationResult validateSimpleExpression(ClassLoader classLoader, String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple predicate&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param simple  the simple predicate&#010;+     * @return validation result&#010;+     * @deprecated use {@link #validateSimplePredicate(ClassLoader, String)}&#010;+     */&#010;+    @Deprecated&#010;+    SimpleValidationResult validateSimplePredicate(String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple predicate&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param simple  the simple predicate&#010;+     * @return validation result&#010;+     */&#010;+    SimpleValidationResult validateSimplePredicate(ClassLoader classLoader, String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the language as a predicate&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param language the name of the language&#010;+     * @param text  the predicate text&#010;+     * @return validation result&#010;+     */&#010;+    LanguageValidationResult validateLanguagePredicate(ClassLoader classLoader, String language, String text);&#010;+&#010;+    /**&#010;+     * Parses and validates the language as an expression&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param language the name of the language&#010;+     * @param text  the expression text&#010;+     * @return validation result&#010;+     */&#010;+    LanguageValidationResult validateLanguageExpression(ClassLoader classLoader, String language, String text);&#010;+&#010;+    /**&#010;+     * Returns the component name from the given endpoint uri&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return the component name (aka scheme), or &lt;tt&gt;null&lt;/tt&gt; if not possible to determine&#010;+     */&#010;+    String endpointComponentName(String uri);&#010;+&#010;+    /**&#010;+     * Creates an endpoint uri in Java style from the information from the properties&#010;+     *&#010;+     * @param scheme the endpoint schema&#010;+     * @param properties the properties as key value pairs&#010;+     * @param encode whether to URL encode the returned uri or not&#010;+     * @return the constructed endpoint uri&#010;+     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;+     */&#010;+    String asEndpointUri(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;+&#010;+    /**&#010;+     * Creates an endpoint uri in XML style (eg escape &amp; as &amp;ampl;) from the information from the properties&#010;+     *&#010;+     * @param scheme the endpoint schema&#010;+     * @param properties the properties as key value pairs&#010;+     * @param encode whether to URL encode the returned uri or not&#010;+     * @return the constructed endpoint uri&#010;+     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;+     */&#010;+    String asEndpointUriXml(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java&#010;new file mode 100644&#010;index 0000000..1b8dd0e&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java&#010;@@ -0,0 +1,32 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+/**&#010;+ * To be backwards compatible, but favor using {@link LanguageValidationResult} instead.&#010;+ */&#010;+public class SimpleValidationResult extends LanguageValidationResult {&#010;+&#010;+    public SimpleValidationResult(String text) {&#010;+        super(text);&#010;+    }&#010;+&#010;+    public String getSimple() {&#010;+        return getText();&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java&#010;new file mode 100644&#010;index 0000000..e29afc6&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java&#010;@@ -0,0 +1,34 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.Set;&#010;+&#010;+/**&#010;+ * Strategy to provide suggestions for unknown endpoint options&#010;+ */&#010;+public interface SuggestionStrategy {&#010;+&#010;+    /**&#010;+     * Provides a list of valid option names for a did you mean function.&#010;+     *&#010;+     * @param names         valid names&#010;+     * @param unknownOption unknown option name&#010;+     * @return a list of suggested names (did you mean)&#010;+     */&#010;+    String[] suggestEndpointOptions(Set&lt;String&gt; names, String unknownOption);&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java&#010;new file mode 100644&#010;index 0000000..ed5585c&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java&#010;@@ -0,0 +1,120 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+/**&#010;+ * This class is a copy from camel-core so we can use it independent to validate uris with time patterns&#010;+ */&#010;+public final class TimePatternConverter {&#010;+    private static final Pattern NUMBERS_ONLY_STRING_PATTERN = Pattern.compile(""^[-]?(\\d)+$"", Pattern.CASE_INSENSITIVE);&#010;+    private static final Pattern HOUR_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))h(our(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;+    private static final Pattern MINUTES_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))m(in(ute(s)?)?)?"", Pattern.CASE_INSENSITIVE);&#010;+    private static final Pattern SECONDS_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))s(ec(ond)?(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;+&#010;+    /**&#010;+     * Utility classes should not have a public constructor.&#010;+     */&#010;+    private TimePatternConverter() {&#010;+    }&#010;+&#010;+    public static long toMilliSeconds(String source) throws IllegalArgumentException {&#010;+        long milliseconds = 0;&#010;+        boolean foundFlag = false;&#010;+&#010;+        checkCorrectnessOfPattern(source);&#010;+        Matcher matcher;&#010;+&#010;+        matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;+        if (matcher.find()) {&#010;+            // Note: This will also be used for regular numeric strings.&#010;+            //       This String -&gt; long converter will be used for all strings.&#010;+            milliseconds = Long.valueOf(source);&#010;+        } else {&#010;+            matcher = createMatcher(HOUR_REGEX_PATTERN, source);&#010;+            if (matcher.find()) {&#010;+                milliseconds = milliseconds + (3600000 * Long.valueOf(matcher.group(1)));&#010;+                foundFlag = true;&#010;+            }&#010;+&#010;+            matcher = createMatcher(MINUTES_REGEX_PATTERN, source);&#010;+            if (matcher.find()) {&#010;+                long minutes = Long.valueOf(matcher.group(1));&#010;+                if ((minutes &gt; 59) &amp;&amp; foundFlag) {&#010;+                    throw new IllegalArgumentException(""Minutes should contain a valid value between 0 and 59: "" + source);&#010;+                }&#010;+                foundFlag = true;&#010;+                milliseconds = milliseconds + (60000 * minutes);&#010;+            }&#010;+&#010;+            matcher = createMatcher(SECONDS_REGEX_PATTERN, source);&#010;+            if (matcher.find()) {&#010;+                long seconds = Long.valueOf(matcher.group(1));&#010;+                if ((seconds &gt; 59) &amp;&amp; foundFlag) {&#010;+                    throw new IllegalArgumentException(""Seconds should contain a valid value between 0 and 59: "" + source);&#010;+                }&#010;+                foundFlag = true;&#010;+                milliseconds = milliseconds + (1000 * seconds);&#010;+            }&#010;+&#010;+            // No pattern matched... initiating fallback check and conversion (if required).&#010;+            // The source at this point may contain illegal values or special characters&#010;+            if (!foundFlag) {&#010;+                milliseconds = Long.valueOf(source);&#010;+            }&#010;+        }&#010;+&#010;+        return milliseconds;&#010;+    }&#010;+&#010;+    private static void checkCorrectnessOfPattern(String source) {&#010;+        //replace only numbers once&#010;+        Matcher matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;+        String replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        //replace hour string once&#010;+        matcher = createMatcher(HOUR_REGEX_PATTERN, replaceSource);&#010;+        if (matcher.find() &amp;&amp; matcher.find()) {&#010;+            throw new IllegalArgumentException(""Hours should not be specified more then once: "" + source);&#010;+        }&#010;+        replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        //replace minutes once&#010;+        matcher = createMatcher(MINUTES_REGEX_PATTERN, replaceSource);&#010;+        if (matcher.find() &amp;&amp; matcher.find()) {&#010;+            throw new IllegalArgumentException(""Minutes should not be specified more then once: "" + source);&#010;+        }&#010;+        replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        //replace seconds once&#010;+        matcher = createMatcher(SECONDS_REGEX_PATTERN, replaceSource);&#010;+        if (matcher.find() &amp;&amp; matcher.find()) {&#010;+            throw new IllegalArgumentException(""Seconds should not be specified more then once: "" + source);&#010;+        }&#010;+        replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        if (replaceSource.length() &gt; 0) {&#010;+            throw new IllegalArgumentException(""Illegal characters: "" + source);&#010;+        }&#010;+    }&#010;+&#010;+    private static Matcher createMatcher(Pattern pattern, String source) {&#010;+        return pattern.matcher(source);&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java&#010;new file mode 100644&#010;index 0000000..8389590&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java&#010;@@ -0,0 +1,392 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.UnsupportedEncodingException;&#010;+import java.net.URI;&#010;+import java.net.URISyntaxException;&#010;+import java.net.URLDecoder;&#010;+import java.net.URLEncoder;&#010;+import java.util.ArrayList;&#010;+import java.util.Iterator;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+&#010;+/**&#010;+ * Copied from org.apache.camel.util.URISupport&#010;+ */&#010;+public final class URISupport {&#010;+&#010;+    public static final String RAW_TOKEN_START = ""RAW("";&#010;+    public static final String RAW_TOKEN_END = "")"";&#010;+&#010;+    private static final String CHARSET = ""UTF-8"";&#010;+&#010;+    private URISupport() {&#010;+        // Helper class&#010;+    }&#010;+&#010;+    /**&#010;+     * Normalizes the URI so unsafe characters is encoded&#010;+     *&#010;+     * @param uri the input uri&#010;+     * @return as URI instance&#010;+     * @throws URISyntaxException is thrown if syntax error in the input uri&#010;+     */&#010;+    public static URI normalizeUri(String uri) throws URISyntaxException {&#010;+        return new URI(UnsafeUriCharactersEncoder.encode(uri, true));&#010;+    }&#010;+&#010;+    public static Map&lt;String, Object&gt; extractProperties(Map&lt;String, Object&gt; properties, String optionPrefix) {&#010;+        Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;(properties.size());&#010;+&#010;+        for (Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; it = properties.entrySet().iterator(); it.hasNext();) {&#010;+            Map.Entry&lt;String, Object&gt; entry = it.next();&#010;+            String name = entry.getKey();&#010;+            if (name.startsWith(optionPrefix)) {&#010;+                Object value = properties.get(name);&#010;+                name = name.substring(optionPrefix.length());&#010;+                rc.put(name, value);&#010;+                it.remove();&#010;+            }&#010;+        }&#010;+&#010;+        return rc;&#010;+    }&#010;+&#010;+    /**&#010;+     * Strips the query parameters from the uri&#010;+     *&#010;+     * @param uri  the uri&#010;+     * @return the uri without the query parameter&#010;+     */&#010;+    public static String stripQuery(String uri) {&#010;+        int idx = uri.indexOf('?');&#010;+        if (idx &gt; -1) {&#010;+            uri = uri.substring(0, idx);&#010;+        }&#010;+        return uri;&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the query parameters of the uri (eg the query part).&#010;+     *&#010;+     * @param uri the uri&#010;+     * @return the parameters, or an empty map if no parameters (eg never null)&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     */&#010;+    public static Map&lt;String, Object&gt; parseParameters(URI uri) throws URISyntaxException {&#010;+        String query = uri.getQuery();&#010;+        if (query == null) {&#010;+            String schemeSpecificPart = uri.getSchemeSpecificPart();&#010;+            int idx = schemeSpecificPart.indexOf('?');&#010;+            if (idx &lt; 0) {&#010;+                // return an empty map&#010;+                return new LinkedHashMap&lt;String, Object&gt;(0);&#010;+            } else {&#010;+                query = schemeSpecificPart.substring(idx + 1);&#010;+            }&#010;+        } else {&#010;+            query = stripPrefix(query, ""?"");&#010;+        }&#010;+        return parseQuery(query);&#010;+    }&#010;+&#010;+    /**&#010;+     * Strips the prefix from the value.&#010;+     * &lt;p/&gt;&#010;+     * Returns the value as-is if not starting with the prefix.&#010;+     *&#010;+     * @param value  the value&#010;+     * @param prefix the prefix to remove from value&#010;+     * @return the value without the prefix&#010;+     */&#010;+    public static String stripPrefix(String value, String prefix) {&#010;+        if (value != null &amp;&amp; value.startsWith(prefix)) {&#010;+            return value.substring(prefix.length());&#010;+        }&#010;+        return value;&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the query part of the uri (eg the parameters).&#010;+     * &lt;p/&gt;&#010;+     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;+     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;+     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;+     *&#010;+     * @param uri the uri&#010;+     * @return the parameters, or an empty map if no parameters (eg never null)&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     * @see #RAW_TOKEN_START&#010;+     * @see #RAW_TOKEN_END&#010;+     */&#010;+    public static Map&lt;String, Object&gt; parseQuery(String uri) throws URISyntaxException {&#010;+        return parseQuery(uri, false);&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the query part of the uri (eg the parameters).&#010;+     * &lt;p/&gt;&#010;+     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;+     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;+     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;+     *&#010;+     * @param uri the uri&#010;+     * @param useRaw whether to force using raw values&#010;+     * @return the parameters, or an empty map if no parameters (eg never null)&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     * @see #RAW_TOKEN_START&#010;+     * @see #RAW_TOKEN_END&#010;+     */&#010;+    public static Map&lt;String, Object&gt; parseQuery(String uri, boolean useRaw) throws URISyntaxException {&#010;+        // must check for trailing &amp; as the uri.split(""&amp;"") will ignore those&#010;+        if (uri != null &amp;&amp; uri.endsWith(""&amp;"")) {&#010;+            throw new URISyntaxException(uri, ""Invalid uri syntax: Trailing &amp; marker found. ""&#010;+                    + ""Check the uri and remove the trailing &amp; marker."");&#010;+        }&#010;+&#010;+        if (isEmpty(uri)) {&#010;+            // return an empty map&#010;+            return new LinkedHashMap&lt;String, Object&gt;(0);&#010;+        }&#010;+&#010;+        // need to parse the uri query parameters manually as we cannot rely on splitting by &amp;,&#010;+        // as &amp; can be used in a parameter value as well.&#010;+&#010;+        try {&#010;+            // use a linked map so the parameters is in the same order&#010;+            Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;();&#010;+&#010;+            boolean isKey = true;&#010;+            boolean isValue = false;&#010;+            boolean isRaw = false;&#010;+            StringBuilder key = new StringBuilder();&#010;+            StringBuilder value = new StringBuilder();&#010;+&#010;+            // parse the uri parameters char by char&#010;+            for (int i = 0; i &lt; uri.length(); i++) {&#010;+                // current char&#010;+                char ch = uri.charAt(i);&#010;+                // look ahead of the next char&#010;+                char next;&#010;+                if (i &lt;= uri.length() - 2) {&#010;+                    next = uri.charAt(i + 1);&#010;+                } else {&#010;+                    next = '\u0000';&#010;+                }&#010;+&#010;+                // are we a raw value&#010;+                isRaw = value.toString().startsWith(RAW_TOKEN_START);&#010;+&#010;+                // if we are in raw mode, then we keep adding until we hit the end marker&#010;+                if (isRaw) {&#010;+                    if (isKey) {&#010;+                        key.append(ch);&#010;+                    } else if (isValue) {&#010;+                        value.append(ch);&#010;+                    }&#010;+&#010;+                    // we only end the raw marker if its )&amp; or at the end of the value&#010;+&#010;+                    boolean end = ch == RAW_TOKEN_END.charAt(0) &amp;&amp; (next == '&amp;' || next == '\u0000');&#010;+                    if (end) {&#010;+                        // raw value end, so add that as a parameter, and reset flags&#010;+                        addParameter(key.toString(), value.toString(), rc, useRaw || isRaw);&#010;+                        key.setLength(0);&#010;+                        value.setLength(0);&#010;+                        isKey = true;&#010;+                        isValue = false;&#010;+                        isRaw = false;&#010;+                        // skip to next as we are in raw mode and have already added the value&#010;+                        i++;&#010;+                    }&#010;+                    continue;&#010;+                }&#010;+&#010;+                // if its a key and there is a = sign then the key ends and we are in value mode&#010;+                if (isKey &amp;&amp; ch == '=') {&#010;+                    isKey = false;&#010;+                    isValue = true;&#010;+                    isRaw = false;&#010;+                    continue;&#010;+                }&#010;+&#010;+                // the &amp; denote parameter is ended&#010;+                if (ch == '&amp;') {&#010;+                    // parameter is ended, as we hit &amp; separator&#010;+                    String aKey = key.toString();&#010;+                    // the key may be a placeholder of options which we then do not know what is&#010;+                    boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;+                    if (validKey) {&#010;+                        addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;+                    }&#010;+                    key.setLength(0);&#010;+                    value.setLength(0);&#010;+                    isKey = true;&#010;+                    isValue = false;&#010;+                    isRaw = false;&#010;+                    continue;&#010;+                }&#010;+&#010;+                // regular char so add it to the key or value&#010;+                if (isKey) {&#010;+                    key.append(ch);&#010;+                } else if (isValue) {&#010;+                    value.append(ch);&#010;+                }&#010;+            }&#010;+&#010;+            // any left over parameters, then add that&#010;+            if (key.length() &gt; 0) {&#010;+                String aKey = key.toString();&#010;+                // the key may be a placeholder of options which we then do not know what is&#010;+                boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;+                if (validKey) {&#010;+                    addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;+                }&#010;+            }&#010;+&#010;+            return rc;&#010;+&#010;+        } catch (UnsupportedEncodingException e) {&#010;+            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;+            se.initCause(e);&#010;+            throw se;&#010;+        }&#010;+    }&#010;+&#010;+    @SuppressWarnings(""unchecked"")&#010;+    private static void addParameter(String name, String value, Map&lt;String, Object&gt; map, boolean isRaw) throws UnsupportedEncodingException {&#010;+        name = URLDecoder.decode(name, CHARSET);&#010;+        if (!isRaw) {&#010;+            // need to replace % with %25&#010;+            value = URLDecoder.decode(value.replaceAll(""%"", ""%25""), CHARSET);&#010;+        }&#010;+&#010;+        // does the key already exist?&#010;+        if (map.containsKey(name)) {&#010;+            // yes it does, so make sure we can support multiple values, but using a list&#010;+            // to hold the multiple values&#010;+            Object existing = map.get(name);&#010;+            List&lt;String&gt; list;&#010;+            if (existing instanceof List) {&#010;+                list = (List&lt;String&gt;) existing;&#010;+            } else {&#010;+                // create a new list to hold the multiple values&#010;+                list = new ArrayList&lt;String&gt;();&#010;+                String s = existing != null ? existing.toString() : null;&#010;+                if (s != null) {&#010;+                    list.add(s);&#010;+                }&#010;+            }&#010;+            list.add(value);&#010;+            map.put(name, list);&#010;+        } else {&#010;+            map.put(name, value);&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Assembles a query from the given map.&#010;+     *&#010;+     * @param options  the map with the options (eg key/value pairs)&#010;+     * @param ampersand to use &amp; for Java code, and &amp;amp; for XML&#010;+     * @return a query string with &lt;tt&gt;key1=value&amp;key2=value2&amp;...&lt;/tt&gt;, or an empty string if there is no options.&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     */&#010;+    public static String createQueryString(Map&lt;String, String&gt; options, String ampersand, boolean encode) throws URISyntaxException {&#010;+        try {&#010;+            if (options.size() &gt; 0) {&#010;+                StringBuilder rc = new StringBuilder();&#010;+                boolean first = true;&#010;+                for (Object o : options.keySet()) {&#010;+                    if (first) {&#010;+                        first = false;&#010;+                    } else {&#010;+                        rc.append(ampersand);&#010;+                    }&#010;+&#010;+                    String key = (String) o;&#010;+                    Object value = options.get(key);&#010;+&#010;+                    // use the value as a String&#010;+                    String s = value != null ? value.toString() : null;&#010;+                    appendQueryStringParameter(key, s, rc, encode);&#010;+                }&#010;+                return rc.toString();&#010;+            } else {&#010;+                return """";&#010;+            }&#010;+        } catch (UnsupportedEncodingException e) {&#010;+            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;+            se.initCause(e);&#010;+            throw se;&#010;+        }&#010;+    }&#010;+&#010;+    private static void appendQueryStringParameter(String key, String value, StringBuilder rc, boolean encode) throws UnsupportedEncodingException {&#010;+        if (encode) {&#010;+            rc.append(URLEncoder.encode(key, CHARSET));&#010;+        } else {&#010;+            rc.append(key);&#010;+        }&#010;+        // only append if value is not null&#010;+        if (value != null) {&#010;+            rc.append(""="");&#010;+            if (value.startsWith(RAW_TOKEN_START) &amp;&amp; value.endsWith(RAW_TOKEN_END)) {&#010;+                // do not encode RAW parameters&#010;+                rc.append(value);&#010;+            } else {&#010;+                if (encode) {&#010;+                    rc.append(URLEncoder.encode(value, CHARSET));&#010;+                } else {&#010;+                    rc.append(value);&#010;+                }&#010;+            }&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if empty&#010;+     */&#010;+    public static boolean isEmpty(Object value) {&#010;+        return !isNotEmpty(value);&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;b&gt;not&lt;/b&gt; &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if &lt;b&gt;not&lt;/b&gt; empty&#010;+     */&#010;+    public static boolean isNotEmpty(Object value) {&#010;+        if (value == null) {&#010;+            return false;&#010;+        } else if (value instanceof String) {&#010;+            String text = (String) value;&#010;+            return text.trim().length() &gt; 0;&#010;+        } else {&#010;+            return true;&#010;+        }&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java&#010;new file mode 100644&#010;index 0000000..a11c810&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java&#010;@@ -0,0 +1,206 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.ArrayList;&#010;+import java.util.BitSet;&#010;+import java.util.List;&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+/**&#010;+ * Encoder for unsafe URI characters.&#010;+ * &lt;p/&gt;&#010;+ * A good source for details is &lt;a href=""http://en.wikipedia.org/wiki/Url_encode""&gt;wikipedia url encode&lt;/a&gt; article.&#010;+ */&#010;+public final class UnsafeUriCharactersEncoder {&#010;+    private static BitSet unsafeCharactersRfc1738;&#010;+    private static BitSet unsafeCharactersHttp;&#010;+    private static final char[] HEX_DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C',&#010;+        'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'};&#010;+    private static final Pattern RAW_PATTERN = Pattern.compile(""RAW\\([^\\)]+\\)"");&#010;+&#010;+    static {&#010;+        unsafeCharactersRfc1738 = new BitSet(256);&#010;+        unsafeCharactersRfc1738.set(' ');&#010;+        unsafeCharactersRfc1738.set('""');&#010;+        unsafeCharactersRfc1738.set('&lt;');&#010;+        unsafeCharactersRfc1738.set('&gt;');&#010;+        unsafeCharactersRfc1738.set('#');&#010;+        unsafeCharactersRfc1738.set('%');&#010;+        unsafeCharactersRfc1738.set('{');&#010;+        unsafeCharactersRfc1738.set('}');&#010;+        unsafeCharactersRfc1738.set('|');&#010;+        unsafeCharactersRfc1738.set('\\');&#010;+        unsafeCharactersRfc1738.set('^');&#010;+        unsafeCharactersRfc1738.set('~');&#010;+        unsafeCharactersRfc1738.set('[');&#010;+        unsafeCharactersRfc1738.set(']');&#010;+        unsafeCharactersRfc1738.set('`');&#010;+    }&#010;+&#010;+    static {&#010;+        unsafeCharactersHttp = new BitSet(256);&#010;+        unsafeCharactersHttp.set(' ');&#010;+        unsafeCharactersHttp.set('""');&#010;+        unsafeCharactersHttp.set('&lt;');&#010;+        unsafeCharactersHttp.set('&gt;');&#010;+        unsafeCharactersHttp.set('#');&#010;+        unsafeCharactersHttp.set('%');&#010;+        unsafeCharactersHttp.set('{');&#010;+        unsafeCharactersHttp.set('}');&#010;+        unsafeCharactersHttp.set('|');&#010;+        unsafeCharactersHttp.set('\\');&#010;+        unsafeCharactersHttp.set('^');&#010;+        unsafeCharactersHttp.set('~');&#010;+        unsafeCharactersHttp.set('`');&#010;+    }&#010;+&#010;+    private UnsafeUriCharactersEncoder() {&#010;+        // util class&#010;+    }&#010;+&#010;+    public static String encode(String s) {&#010;+        return encode(s, unsafeCharactersRfc1738);&#010;+    }&#010;+&#010;+    public static String encodeHttpURI(String s) {&#010;+        return encode(s, unsafeCharactersHttp);&#010;+    }&#010;+&#010;+    public static String encode(String s, BitSet unsafeCharacters) {&#010;+        return encode(s, unsafeCharacters, false);&#010;+    }&#010;+&#010;+    public static String encode(String s, boolean checkRaw) {&#010;+        return encode(s, unsafeCharactersRfc1738, checkRaw);&#010;+    }&#010;+&#010;+    public static String encodeHttpURI(String s, boolean checkRaw) {&#010;+        return encode(s, unsafeCharactersHttp, checkRaw);&#010;+    }&#010;+&#010;+    private static List&lt;Pair&gt; checkRAW(String s) {&#010;+        Matcher matcher = RAW_PATTERN.matcher(s);&#010;+        List&lt;Pair&gt; answer = new ArrayList&lt;Pair&gt;();&#010;+        // Check all occurrences&#010;+        while (matcher.find()) {&#010;+            answer.add(new Pair(matcher.start(), matcher.end()));&#010;+        }&#010;+        return answer;&#010;+    }&#010;+&#010;+    private static boolean isRaw(int index, List&lt;Pair&gt; pairs) {&#010;+        for (Pair pair : pairs) {&#010;+            if (index &lt; pair.left) {&#010;+                return false;&#010;+            } else {&#010;+                if (index &gt;= pair.left) {&#010;+                    if (index &lt;= pair.right) {&#010;+                        return true;&#010;+                    } else {&#010;+                        continue;&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    private static class Pair {&#010;+        int left;&#010;+        int right;&#010;+&#010;+        Pair(int left, int right) {&#010;+            this.left = left;&#010;+            this.right = right;&#010;+        }&#010;+    }&#010;+&#010;+    // Just skip the encode for isRAW part&#010;+    public static String encode(String s, BitSet unsafeCharacters, boolean checkRaw) {&#010;+        List&lt;Pair&gt; rawPairs;&#010;+        if (checkRaw) {&#010;+            rawPairs = checkRAW(s);&#010;+        } else {&#010;+            rawPairs = new ArrayList&lt;Pair&gt;();&#010;+        }&#010;+&#010;+        int n = s == null ? 0 : s.length();&#010;+        if (n == 0) {&#010;+            return s;&#010;+        }&#010;+&#010;+        // First check whether we actually need to encode&#010;+        char chars[] = s.toCharArray();&#010;+        for (int i = 0;;) {&#010;+            // just deal with the ascii character&#010;+            if (chars[i] &gt; 0 &amp;&amp; chars[i] &lt; 128) {&#010;+                if (unsafeCharacters.get(chars[i])) {&#010;+                    break;&#010;+                }&#010;+            }&#010;+            if (++i &gt;= chars.length) {&#010;+                return s;&#010;+            }&#010;+        }&#010;+&#010;+        // okay there are some unsafe characters so we do need to encode&#010;+        // see details at: http://en.wikipedia.org/wiki/Url_encode&#010;+        StringBuilder sb = new StringBuilder();&#010;+        for (int i = 0; i &lt; chars.length; i++) {&#010;+            char ch = chars[i];&#010;+            if (ch &gt; 0 &amp;&amp; ch &lt; 128 &amp;&amp; unsafeCharacters.get(ch)) {&#010;+                // special for % sign as it may be a decimal encoded value&#010;+                if (ch == '%') {&#010;+                    char next = i + 1 &lt; chars.length ? chars[i + 1] : ' ';&#010;+                    char next2 = i + 2 &lt; chars.length ? chars[i + 2] : ' ';&#010;+&#010;+                    if (isHexDigit(next) &amp;&amp; isHexDigit(next2) &amp;&amp; !isRaw(i, rawPairs)) {&#010;+                        // its already encoded (decimal encoded) so just append as is&#010;+                        sb.append(ch);&#010;+                    } else {&#010;+                        // must escape then, as its an unsafe character&#010;+                        appendEscape(sb, (byte) ch);&#010;+                    }&#010;+                } else {&#010;+                    // must escape then, as its an unsafe character&#010;+                    appendEscape(sb, (byte) ch);&#010;+                }&#010;+            } else {&#010;+                sb.append(ch);&#010;+            }&#010;+        }&#010;+        return sb.toString();&#010;+    }&#010;+&#010;+    private static void appendEscape(StringBuilder sb, byte b) {&#010;+        sb.append('%');&#010;+        sb.append(HEX_DIGITS[(b &gt;&gt; 4) &amp; 0x0f]);&#010;+        sb.append(HEX_DIGITS[(b &gt;&gt; 0) &amp; 0x0f]);&#010;+    }&#010;+&#010;+    private static boolean isHexDigit(char ch) {&#010;+        for (char hex : HEX_DIGITS) {&#010;+            if (hex == ch) {&#010;+                return true;&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html b/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html&#010;new file mode 100644&#010;index 0000000..2f15a04&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html&#010;@@ -0,0 +1,25 @@&#010;+&lt;!--&#010;+    Licensed to the Apache Software Foundation (ASF) under one or more&#010;+    contributor license agreements.  See the NOTICE file distributed with&#010;+    this work for additional information regarding copyright ownership.&#010;+    The ASF licenses this file to You under the Apache License, Version 2.0&#010;+    (the ""License""); you may not use this file except in compliance with&#010;+    the License.  You may obtain a copy of the License at&#010;+&#010;+    http://www.apache.org/licenses/LICENSE-2.0&#010;+&#010;+    Unless required by applicable law or agreed to in writing, software&#010;+    distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+    See the License for the specific language governing permissions and&#010;+    limitations under the License.&#010;+--&gt;&#010;+&lt;html&gt;&#010;+&lt;head&gt;&#010;+&lt;/head&gt;&#010;+&lt;body&gt;&#010;+&#010;+Runtime Camel Catalog&#010;+&#010;+&lt;/body&gt;&#010;+&lt;/html&gt;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java b/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;index fd22f55..a32c109 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;@@ -37,8 +37,8 @@ import org.apache.camel.PollingConsumer;&#010; import org.apache.camel.Processor;&#010; import org.apache.camel.ResolveEndpointFailedException;&#010; import org.apache.camel.Route;&#010;-import org.apache.camel.catalog.DefaultRuntimeCamelCatalog;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.DefaultRuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.BrowsableEndpoint;&#010; import org.slf4j.Logger;&#010; import org.slf4j.LoggerFactory;&#010;@@ -523,7 +523,7 @@ public final class EndpointHelper {&#010;      * @param uri          the endpoint uri&#010;      * @return a map for each option in the uri with the corresponding information from the json&#010;      * @throws Exception is thrown in case of error&#010;-     * @deprecated use {@link org.apache.camel.catalog.RuntimeCamelCatalog#endpointProperties(String)}&#010;+     * @deprecated use {@link org.apache.camel.runtimecatalog.RuntimeCamelCatalog#endpointProperties(String)}&#010;      */&#010;     @Deprecated&#010;     public static Map&lt;String, Object&gt; endpointProperties(CamelContext camelContext, String uri) throws Exception {&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java b/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java&#010;deleted file mode 100644&#010;index ed7e997..0000000&#010;--- a/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java&#010;+++ /dev/null&#010;@@ -1,104 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.net.URISyntaxException;&#010;-import java.util.HashMap;&#010;-import java.util.Map;&#010;-&#010;-import org.junit.Before;&#010;-import org.junit.Test;&#010;-&#010;-import static org.easymock.EasyMock.expect;&#010;-import static org.easymock.EasyMock.mock;&#010;-import static org.easymock.EasyMock.replay;&#010;-import static org.junit.Assert.assertEquals;&#010;-&#010;-public class AbstractCamelCatalogTest {&#010;-&#010;-    AbstractCamelCatalog catalog = new AbstractCamelCatalog() {&#010;-    };&#010;-&#010;-    JSonSchemaResolver resolver;&#010;-&#010;-    @Before&#010;-    public void setupMockCatalog() {&#010;-        resolver = mock(JSonSchemaResolver.class);&#010;-&#010;-        catalog.setJSonSchemaResolver(resolver);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void shouldConstructEndpointUris() throws URISyntaxException {&#010;-        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;-            + ""  \""component\"": {\n""//&#010;-            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;-            + ""  }\n""//&#010;-            + ""}"");&#010;-&#010;-        replay(resolver);&#010;-&#010;-        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;-        properties.put(""param1"", ""value1"");&#010;-        properties.put(""param2"", ""value2"");&#010;-        properties.put(""param3"", ""value3"");&#010;-&#010;-        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;-&#010;-        assertEquals(""comp:value1:value2?param3=value3"", endpointUri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void shouldConstructEndpointUrisWithPropertyPlaceholders() throws URISyntaxException {&#010;-        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;-            + ""  \""component\"": {\n""//&#010;-            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;-            + ""  }\n""//&#010;-            + ""}"");&#010;-&#010;-        replay(resolver);&#010;-&#010;-        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;-        properties.put(""param1"", ""{{prop1}}"");&#010;-        properties.put(""param2"", ""{{prop2}}"");&#010;-        properties.put(""param3"", ""{{prop3}}"");&#010;-&#010;-        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;-&#010;-        assertEquals(""comp:{{prop1}}:{{prop2}}?param3={{prop3}}"", endpointUri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void shouldConstructEndpointUrisWhenValuesContainTokens() throws URISyntaxException {&#010;-        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;-            + ""  \""component\"": {\n""//&#010;-            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;-            + ""  }\n""//&#010;-            + ""}"");&#010;-&#010;-        replay(resolver);&#010;-&#010;-        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;-        properties.put(""param1"", ""{value1}"");&#010;-        properties.put(""param2"", ""/value2/"");&#010;-        properties.put(""param3"", ""/value3/{param}"");&#010;-&#010;-        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;-&#010;-        assertEquals(""comp:{value1}:/value2/?param3=/value3/{param}"", endpointUri);&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java b/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java&#010;deleted file mode 100644&#010;index 78e51a2..0000000&#010;--- a/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java&#010;+++ /dev/null&#010;@@ -1,393 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.HashMap;&#010;-import java.util.Map;&#010;-&#010;-import org.apache.camel.impl.DefaultCamelContext;&#010;-import org.junit.BeforeClass;&#010;-import org.junit.Test;&#010;-import org.slf4j.Logger;&#010;-import org.slf4j.LoggerFactory;&#010;-&#010;-import static org.junit.Assert.assertEquals;&#010;-import static org.junit.Assert.assertFalse;&#010;-import static org.junit.Assert.assertNotNull;&#010;-import static org.junit.Assert.assertTrue;&#010;-&#010;-public class RuntimeCamelCatalogTest {&#010;-&#010;-    static RuntimeCamelCatalog catalog;&#010;-&#010;-    private static final Logger LOG = LoggerFactory.getLogger(RuntimeCamelCatalogTest.class);&#010;-&#010;-    @BeforeClass&#010;-    public static void createCamelCatalog() {&#010;-        catalog = new DefaultRuntimeCamelCatalog(new DefaultCamelContext());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testFromCamelContext() throws Exception {&#010;-        String schema = new DefaultCamelContext().getRuntimeCamelCatalog().modelJSonSchema(""choice"");&#010;-        assertNotNull(schema);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testJsonSchema() throws Exception {&#010;-        String schema = catalog.modelJSonSchema(""aggregate"");&#010;-        assertNotNull(schema);&#010;-&#010;-        // lets make it possible to find bean/method using both names&#010;-        schema = catalog.modelJSonSchema(""method"");&#010;-        assertNotNull(schema);&#010;-        schema = catalog.modelJSonSchema(""bean"");&#010;-        assertNotNull(schema);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriMapFile() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""directoryName"", ""src/data/inbox"");&#010;-        map.put(""noop"", ""true"");&#010;-        map.put(""delay"", ""5000"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""file"", map, true);&#010;-        assertEquals(""file:src/data/inbox?delay=5000&amp;noop=true"", uri);&#010;-&#010;-        String uri2 = catalog.asEndpointUriXml(""file"", map, true);&#010;-        assertEquals(""file:src/data/inbox?delay=5000&amp;amp;noop=true"", uri2);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriTimer() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""timerName"", ""foo"");&#010;-        map.put(""period"", ""5000"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;-        assertEquals(""timer:foo?period=5000"", uri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriPropertiesPlaceholders() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""timerName"", ""foo"");&#010;-        map.put(""period"", ""{{howoften}}"");&#010;-        map.put(""repeatCount"", ""5"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;-        assertEquals(""timer:foo?period=%7B%7Bhowoften%7D%7D&amp;repeatCount=5"", uri);&#010;-&#010;-        uri = catalog.asEndpointUri(""timer"", map, false);&#010;-        assertEquals(""timer:foo?period={{howoften}}&amp;repeatCount=5"", uri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriBeanLookup() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""resourceUri"", ""foo.xslt"");&#010;-        map.put(""converter"", ""#myConverter"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""xslt"", map, true);&#010;-        assertEquals(""xslt:foo.xslt?converter=%23myConverter"", uri);&#010;-&#010;-        uri = catalog.asEndpointUri(""xslt"", map, false);&#010;-        assertEquals(""xslt:foo.xslt?converter=#myConverter"", uri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testEndpointPropertiesPlaceholders() throws Exception {&#010;-        Map&lt;String, String&gt; map = catalog.endpointProperties(""timer:foo?period={{howoften}}&amp;repeatCount=5"");&#010;-        assertNotNull(map);&#010;-        assertEquals(3, map.size());&#010;-&#010;-        assertEquals(""foo"", map.get(""timerName""));&#010;-        assertEquals(""{{howoften}}"", map.get(""period""));&#010;-        assertEquals(""5"", map.get(""repeatCount""));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriLog() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""loggerName"", ""foo"");&#010;-        map.put(""loggerLevel"", ""WARN"");&#010;-        map.put(""multiline"", ""true"");&#010;-        map.put(""showAll"", ""true"");&#010;-        map.put(""showBody"", ""false"");&#010;-        map.put(""showBodyType"", ""false"");&#010;-        map.put(""showExchangePattern"", ""false"");&#010;-        map.put(""style"", ""Tab"");&#010;-&#010;-        assertEquals(""log:foo?loggerLevel=WARN&amp;multiline=true&amp;showAll=true&amp;style=Tab"", catalog.asEndpointUri(""log"", map, false));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriLogShort() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""loggerName"", ""foo"");&#010;-        map.put(""loggerLevel"", ""DEBUG"");&#010;-&#010;-        assertEquals(""log:foo?loggerLevel=DEBUG"", catalog.asEndpointUri(""log"", map, false));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriWithplaceholder() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""name"", ""foo"");&#010;-        map.put(""blockWhenFull"", ""{{block}}"");&#010;-        assertEquals(""seda:foo?blockWhenFull={{block}}"", catalog.asEndpointUri(""seda"", map, false));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testEndpointPropertiesSedaRequired() throws Exception {&#010;-        Map&lt;String, String&gt; map = catalog.endpointProperties(""seda:foo"");&#010;-        assertNotNull(map);&#010;-        assertEquals(1, map.size());&#010;-&#010;-        assertEquals(""foo"", map.get(""name""));&#010;-&#010;-        map = catalog.endpointProperties(""seda:foo?blockWhenFull=true"");&#010;-        assertNotNull(map);&#010;-        assertEquals(2, map.size());&#010;-&#010;-        assertEquals(""foo"", map.get(""name""));&#010;-        assertEquals(""true"", map.get(""blockWhenFull""));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void validateProperties() throws Exception {&#010;-        // valid&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(""log:mylog"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // unknown&#010;-        result = catalog.validateEndpointProperties(""log:mylog?level=WARN&amp;foo=bar"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getUnknown().contains(""foo""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // enum&#010;-        result = catalog.validateEndpointProperties(""seda:foo?waitForTaskToComplete=blah"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""blah"", result.getInvalidEnum().get(""waitForTaskToComplete""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // reference okay&#010;-        result = catalog.validateEndpointProperties(""seda:foo?queue=#queue"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(0, result.getNumberOfErrors());&#010;-&#010;-        // unknown component&#010;-        result = catalog.validateEndpointProperties(""foo:bar?me=you"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getUnknownComponent().equals(""foo""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // invalid boolean but default value&#010;-        result = catalog.validateEndpointProperties(""log:output?showAll=ggg"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""ggg"", result.getInvalidBoolean().get(""showAll""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // dataset&#010;-        result = catalog.validateEndpointProperties(""dataset:foo?minRate=50"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // time pattern&#010;-        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=true&amp;delay=0&amp;period=2s"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // reference lookup&#010;-        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=#fixed&amp;delay=#myDelay"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // optional consumer. prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?consumer.delay=5000&amp;consumer.greedy=true"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // optional without consumer. prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;greedy=true"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // mixed optional without consumer. prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;consumer.greedy=true"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;scheduler.foo=123&amp;scheduler.bar=456"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // stub&#010;-        result = catalog.validateEndpointProperties(""stub:foo?me=123&amp;you=456"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // lenient on&#010;-        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // lenient off&#010;-        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"", true);&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getUnknown().contains(""foo""));&#010;-&#010;-        // data format&#010;-        result = catalog.validateEndpointProperties(""dataformat:string:marshal?charset=utf-8"", true);&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // incapable to parse&#010;-        result = catalog.validateEndpointProperties(""{{getFtpUrl}}?recursive=true"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getIncapable() != null);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void validatePropertiesSummary() throws Exception {&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(""yammer:MESSAGES?blah=yada&amp;accessToken=aaa&amp;consumerKey=&amp;useJson=no&amp;initialDelay=five&amp;pollStrategy=myStrategy"");&#010;-        assertFalse(result.isSuccess());&#010;-        String reason = result.summaryErrorMessage(true);&#010;-        LOG.info(reason);&#010;-&#010;-        result = catalog.validateEndpointProperties(""jms:unknown:myqueue"");&#010;-        assertFalse(result.isSuccess());&#010;-        reason = result.summaryErrorMessage(false);&#010;-        LOG.info(reason);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void validateTimePattern() throws Exception {&#010;-        assertTrue(catalog.validateTimePattern(""0""));&#010;-        assertTrue(catalog.validateTimePattern(""500""));&#010;-        assertTrue(catalog.validateTimePattern(""10000""));&#010;-        assertTrue(catalog.validateTimePattern(""5s""));&#010;-        assertTrue(catalog.validateTimePattern(""5sec""));&#010;-        assertTrue(catalog.validateTimePattern(""5secs""));&#010;-        assertTrue(catalog.validateTimePattern(""3m""));&#010;-        assertTrue(catalog.validateTimePattern(""3min""));&#010;-        assertTrue(catalog.validateTimePattern(""3minutes""));&#010;-        assertTrue(catalog.validateTimePattern(""5m15s""));&#010;-        assertTrue(catalog.validateTimePattern(""1h""));&#010;-        assertTrue(catalog.validateTimePattern(""1hour""));&#010;-        assertTrue(catalog.validateTimePattern(""2hours""));&#010;-&#010;-        assertFalse(catalog.validateTimePattern(""bla""));&#010;-        assertFalse(catalog.validateTimePattern(""2year""));&#010;-        assertFalse(catalog.validateTimePattern(""60darn""));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testEndpointComponentName() throws Exception {&#010;-        String name = catalog.endpointComponentName(""jms:queue:foo"");&#010;-        assertEquals(""jms"", name);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testSimpleExpression() throws Exception {&#010;-        SimpleValidationResult result = catalog.validateSimpleExpression(null, ""${body}"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body}"", result.getSimple());&#010;-&#010;-        result = catalog.validateSimpleExpression(null, ""${body"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""${body"", result.getSimple());&#010;-        LOG.info(result.getError());&#010;-        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol at location 5""));&#010;-        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;-        assertEquals(5, result.getIndex());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testSimplePredicate() throws Exception {&#010;-        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} == 'abc'"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body} == 'abc'"", result.getSimple());&#010;-&#010;-        result = catalog.validateSimplePredicate(null, ""${body} &gt; ${header.size"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""${body} &gt; ${header.size"", result.getSimple());&#010;-        LOG.info(result.getError());&#010;-        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol at location 22""));&#010;-        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;-        assertEquals(22, result.getIndex());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testSimplePredicatePlaceholder() throws Exception {&#010;-        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} contains '{{danger}}'"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body} contains '{{danger}}'"", result.getSimple());&#010;-&#010;-        result = catalog.validateSimplePredicate(null, ""${bdy} contains '{{danger}}'"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""${bdy} contains '{{danger}}'"", result.getSimple());&#010;-        LOG.info(result.getError());&#010;-        assertTrue(result.getError().startsWith(""Unknown function: bdy at location 0""));&#010;-        assertTrue(result.getError().contains(""'{{danger}}'""));&#010;-        assertEquals(""Unknown function: bdy"", result.getShortError());&#010;-        assertEquals(0, result.getIndex());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testValidateLanguage() throws Exception {&#010;-        LanguageValidationResult result = catalog.validateLanguageExpression(null, ""simple"", ""${body}"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body}"", result.getText());&#010;-&#010;-        result = catalog.validateLanguageExpression(null, ""header"", ""foo"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""foo"", result.getText());&#010;-&#010;-        result = catalog.validateLanguagePredicate(null, ""simple"", ""${body} &gt; 10"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body} &gt; 10"", result.getText());&#010;-&#010;-        result = catalog.validateLanguagePredicate(null, ""header"", ""bar"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""bar"", result.getText());&#010;-&#010;-        result = catalog.validateLanguagePredicate(null, ""foobar"", ""bar"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""Unknown language foobar"", result.getError());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testValidateEndpointConsumerOnly() throws Exception {&#010;-        String uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true"";&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false, true, false);&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true&amp;fileExist=Append"";&#010;-        result = catalog.validateEndpointProperties(uri, false, true, false);&#010;-        assertFalse(result.isSuccess());&#010;-&#010;-        assertEquals(""fileExist"", result.getNotConsumerOnly().iterator().next());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testValidateEndpointProducerOnly() throws Exception {&#010;-        String uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append"";&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false, false, true);&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append&amp;delete=true"";&#010;-        result = catalog.validateEndpointProperties(uri, false, false, true);&#010;-        assertFalse(result.isSuccess());&#010;-&#010;-        assertEquals(""delete"", result.getNotProducerOnly().iterator().next());&#010;-    }&#010;-&#010;-}&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C392ff0b6a5e9466c9cdb499eabbaf550%40git.apache.org%3E,2017-04-14 10:52,commits,2.0,324.0,  [3/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
4,325.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java&#010;new file mode 100644&#010;index 0000000..0420708&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java&#010;@@ -0,0 +1,1294 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.lang.reflect.InvocationTargetException;&#010;+import java.lang.reflect.Method;&#010;+import java.net.URI;&#010;+import java.net.URISyntaxException;&#010;+import java.util.ArrayList;&#010;+import java.util.Arrays;&#010;+import java.util.HashMap;&#010;+import java.util.Iterator;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.LinkedHashSet;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+import java.util.Objects;&#010;+import java.util.Set;&#010;+import java.util.TreeMap;&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+import static org.apache.camel.runtimecatalog.CatalogHelper.after;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getNames;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyDefaultValue;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyEnum;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyKind;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyNameFromNameWithPrefix;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyPrefix;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getRow;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isComponentConsumerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isComponentLenientProperties;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isComponentProducerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyBoolean;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyConsumerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyInteger;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyMultiValue;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyNumber;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyObject;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyProducerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyRequired;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.stripOptionalPrefixFromName;&#010;+import static org.apache.camel.runtimecatalog.URISupport.createQueryString;&#010;+import static org.apache.camel.runtimecatalog.URISupport.isEmpty;&#010;+import static org.apache.camel.runtimecatalog.URISupport.normalizeUri;&#010;+import static org.apache.camel.runtimecatalog.URISupport.stripQuery;&#010;+&#010;+/**&#010;+ * Base class for both the runtime RuntimeCamelCatalog from camel-core and the complete CamelCatalog from camel-catalog.&#010;+ */&#010;+public abstract class AbstractCamelCatalog {&#010;+&#010;+    // CHECKSTYLE:OFF&#010;+&#010;+    private static final Pattern SYNTAX_PATTERN = Pattern.compile(""(\\w+)"");&#010;+&#010;+    private SuggestionStrategy suggestionStrategy;&#010;+    private JSonSchemaResolver jsonSchemaResolver;&#010;+&#010;+    public SuggestionStrategy getSuggestionStrategy() {&#010;+        return suggestionStrategy;&#010;+    }&#010;+&#010;+    public void setSuggestionStrategy(SuggestionStrategy suggestionStrategy) {&#010;+        this.suggestionStrategy = suggestionStrategy;&#010;+    }&#010;+&#010;+    public JSonSchemaResolver getJSonSchemaResolver() {&#010;+        return jsonSchemaResolver;&#010;+    }&#010;+&#010;+    public void setJSonSchemaResolver(JSonSchemaResolver resolver) {&#010;+        this.jsonSchemaResolver = resolver;&#010;+    }&#010;+&#010;+    public boolean validateTimePattern(String pattern) {&#010;+        return validateInteger(pattern);&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateEndpointProperties(String uri) {&#010;+        return validateEndpointProperties(uri, false, false, false);&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties) {&#010;+        return validateEndpointProperties(uri, ignoreLenientProperties, false, false);&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateProperties(String scheme, Map&lt;String, String&gt; properties) {&#010;+        EndpointValidationResult result = new EndpointValidationResult(scheme);&#010;+&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+        List&lt;Map&lt;String, String&gt;&gt; componentProps = JSonSchemaHelper.parseJsonSchema(""componentProperties"", json, true);&#010;+&#010;+        // endpoint options have higher priority so remove those from component&#010;+        // that may clash&#010;+        componentProps.stream()&#010;+            .filter(c -&gt; rows.stream().noneMatch(e -&gt; Objects.equals(e.get(""name""), c.get(""name""))))&#010;+            .forEach(rows::add);&#010;+&#010;+        boolean lenient = Boolean.getBoolean(properties.getOrDefault(""lenient"", ""false""));&#010;+&#010;+        // the dataformat component refers to a data format so lets add the properties for the selected&#010;+        // data format to the list of rows&#010;+        if (""dataformat"".equals(scheme)) {&#010;+            String dfName = properties.get(""name"");&#010;+            if (dfName != null) {&#010;+                String dfJson = jsonSchemaResolver.getDataFormatJSonSchema(dfName);&#010;+                List&lt;Map&lt;String, String&gt;&gt; dfRows = JSonSchemaHelper.parseJsonSchema(""properties"", dfJson, true);&#010;+                if (dfRows != null &amp;&amp; !dfRows.isEmpty()) {&#010;+                    rows.addAll(dfRows);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        for (Map.Entry&lt;String, String&gt; property : properties.entrySet()) {&#010;+            String value = property.getValue();&#010;+            String originalName = property.getKey();&#010;+            String name = property.getKey();&#010;+            // the name may be using an optional prefix, so lets strip that because the options&#010;+            // in the schema are listed without the prefix&#010;+            name = stripOptionalPrefixFromName(rows, name);&#010;+            // the name may be using a prefix, so lets see if we can find the real property name&#010;+            String propertyName = getPropertyNameFromNameWithPrefix(rows, name);&#010;+            if (propertyName != null) {&#010;+                name = propertyName;&#010;+            }&#010;+&#010;+            String prefix = getPropertyPrefix(rows, name);&#010;+            String kind = getPropertyKind(rows, name);&#010;+            boolean namePlaceholder = name.startsWith(""{{"") &amp;&amp; name.endsWith(""}}"");&#010;+            boolean valuePlaceholder = value.startsWith(""{{"") || value.startsWith(""${"") || value.startsWith(""$simple{"");&#010;+            boolean lookup = value.startsWith(""#"") &amp;&amp; value.length() &gt; 1;&#010;+            // we cannot evaluate multi values as strict as the others, as we don't know their expected types&#010;+            boolean multiValue = prefix != null &amp;&amp; originalName.startsWith(prefix) &amp;&amp; isPropertyMultiValue(rows, name);&#010;+&#010;+            Map&lt;String, String&gt; row = getRow(rows, name);&#010;+            if (row == null) {&#010;+                // unknown option&#010;+&#010;+                // only add as error if the component is not lenient properties, or not stub component&#010;+                // and the name is not a property placeholder for one or more values&#010;+                if (!namePlaceholder &amp;&amp; !""stub"".equals(scheme)) {&#010;+                    if (lenient) {&#010;+                        // as if we are lenient then the option is a dynamic extra option which we cannot validate&#010;+                        result.addLenient(name);&#010;+                    } else {&#010;+                        // its unknown&#010;+                        result.addUnknown(name);&#010;+                        if (suggestionStrategy != null) {&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(getNames(rows), name);&#010;+                            if (suggestions != null) {&#010;+                                result.addUnknownSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+                    }&#010;+                }&#010;+            } else {&#010;+                /* TODO: we may need to add something in the properties to know if they are related to a producer or consumer&#010;+                if (""parameter"".equals(kind)) {&#010;+                    // consumer only or producer only mode for parameters&#010;+                    if (consumerOnly) {&#010;+                        boolean producer = isPropertyProducerOnly(rows, name);&#010;+                        if (producer) {&#010;+                            // the option is only for producer so you cannot use it in consumer mode&#010;+                            result.addNotConsumerOnly(name);&#010;+                        }&#010;+                    } else if (producerOnly) {&#010;+                        boolean consumer = isPropertyConsumerOnly(rows, name);&#010;+                        if (consumer) {&#010;+                            // the option is only for consumer so you cannot use it in producer mode&#010;+                            result.addNotProducerOnly(name);&#010;+                        }&#010;+                    }&#010;+                }&#010;+                */&#010;+&#010;+                // default value&#010;+                String defaultValue = getPropertyDefaultValue(rows, name);&#010;+                if (defaultValue != null) {&#010;+                    result.addDefaultValue(name, defaultValue);&#010;+                }&#010;+&#010;+                // is required but the value is empty&#010;+                boolean required = isPropertyRequired(rows, name);&#010;+                if (required &amp;&amp; isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+&#010;+                // is enum but the value is not within the enum range&#010;+                // but we can only check if the value is not a placeholder&#010;+                String enums = getPropertyEnum(rows, name);&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; enums != null) {&#010;+                    String[] choices = enums.split("","");&#010;+                    boolean found = false;&#010;+                    for (String s : choices) {&#010;+                        if (value.equalsIgnoreCase(s)) {&#010;+                            found = true;&#010;+                            break;&#010;+                        }&#010;+                    }&#010;+                    if (!found) {&#010;+                        result.addInvalidEnum(name, value);&#010;+                        result.addInvalidEnumChoices(name, choices);&#010;+                        if (suggestionStrategy != null) {&#010;+                            Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;();&#010;+                            names.addAll(Arrays.asList(choices));&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(names, value);&#010;+                            if (suggestions != null) {&#010;+                                result.addInvalidEnumSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+&#010;+                    }&#010;+                }&#010;+&#010;+                // is reference lookup of bean (not applicable for @UriPath, enums, or multi-valued)&#010;+                if (!multiValue &amp;&amp; enums == null &amp;&amp; !""path"".equals(kind) &amp;&amp; isPropertyObject(rows, name)) {&#010;+                    // must start with # and be at least 2 characters&#010;+                    if (!value.startsWith(""#"") || value.length() &lt;= 1) {&#010;+                        result.addInvalidReference(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is boolean&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyBoolean(rows, name)) {&#010;+                    // value must be a boolean&#010;+                    boolean bool = ""true"".equalsIgnoreCase(value) || ""false"".equalsIgnoreCase(value);&#010;+                    if (!bool) {&#010;+                        result.addInvalidBoolean(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is integer&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyInteger(rows, name)) {&#010;+                    // value must be an integer&#010;+                    boolean valid = validateInteger(value);&#010;+                    if (!valid) {&#010;+                        result.addInvalidInteger(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is number&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyNumber(rows, name)) {&#010;+                    // value must be an number&#010;+                    boolean valid = false;&#010;+                    try {&#010;+                        valid = !Double.valueOf(value).isNaN() || !Float.valueOf(value).isNaN();&#010;+                    } catch (Exception e) {&#010;+                        // ignore&#010;+                    }&#010;+                    if (!valid) {&#010;+                        result.addInvalidNumber(name, value);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // now check if all required values are there, and that a default value does not exists&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String name = row.get(""name"");&#010;+            boolean required = isPropertyRequired(rows, name);&#010;+            if (required) {&#010;+                String value = properties.get(name);&#010;+                if (isEmpty(value)) {&#010;+                    value = getPropertyDefaultValue(rows, name);&#010;+                }&#010;+                if (isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        return result;&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties, boolean consumerOnly, boolean producerOnly) {&#010;+        EndpointValidationResult result = new EndpointValidationResult(uri);&#010;+&#010;+        Map&lt;String, String&gt; properties;&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows;&#010;+        boolean lenientProperties;&#010;+        String scheme;&#010;+&#010;+        try {&#010;+            String json = null;&#010;+&#010;+            // parse the uri&#010;+            URI u = normalizeUri(uri);&#010;+            scheme = u.getScheme();&#010;+&#010;+            if (scheme != null) {&#010;+                json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+            }&#010;+            if (json == null) {&#010;+                // if the uri starts with a placeholder then we are also incapable of parsing it as we wasn't able to resolve the component name&#010;+                if (uri.startsWith(""{{"")) {&#010;+                    result.addIncapable(uri);&#010;+                } else if (scheme != null) {&#010;+                    result.addUnknownComponent(scheme);&#010;+                } else {&#010;+                    result.addUnknownComponent(uri);&#010;+                }&#010;+                return result;&#010;+            }&#010;+&#010;+            rows = JSonSchemaHelper.parseJsonSchema(""component"", json, false);&#010;+&#010;+            // is the component capable of both consumer and producer?&#010;+            boolean canConsumeAndProduce = false;&#010;+            if (!isComponentConsumerOnly(rows) &amp;&amp; !isComponentProducerOnly(rows)) {&#010;+                canConsumeAndProduce = true;&#010;+            }&#010;+&#010;+            if (canConsumeAndProduce &amp;&amp; consumerOnly) {&#010;+                // lenient properties is not support in consumer only mode if the component can do both of them&#010;+                lenientProperties = false;&#010;+            } else {&#010;+                // only enable lenient properties if we should not ignore&#010;+                lenientProperties = !ignoreLenientProperties &amp;&amp; isComponentLenientProperties(rows);&#010;+            }&#010;+            rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+            properties = endpointProperties(uri);&#010;+        } catch (URISyntaxException e) {&#010;+            if (uri.startsWith(""{{"")) {&#010;+                // if the uri starts with a placeholder then we are also incapable of parsing it as we wasn't able to resolve the component name&#010;+                result.addIncapable(uri);&#010;+            } else {&#010;+                result.addSyntaxError(e.getMessage());&#010;+            }&#010;+&#010;+            return result;&#010;+        }&#010;+&#010;+        // the dataformat component refers to a data format so lets add the properties for the selected&#010;+        // data format to the list of rows&#010;+        if (""dataformat"".equals(scheme)) {&#010;+            String dfName = properties.get(""name"");&#010;+            if (dfName != null) {&#010;+                String dfJson = jsonSchemaResolver.getDataFormatJSonSchema(dfName);&#010;+                List&lt;Map&lt;String, String&gt;&gt; dfRows = JSonSchemaHelper.parseJsonSchema(""properties"", dfJson, true);&#010;+                if (dfRows != null &amp;&amp; !dfRows.isEmpty()) {&#010;+                    rows.addAll(dfRows);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        for (Map.Entry&lt;String, String&gt; property : properties.entrySet()) {&#010;+            String value = property.getValue();&#010;+            String originalName = property.getKey();&#010;+            String name = property.getKey();&#010;+            // the name may be using an optional prefix, so lets strip that because the options&#010;+            // in the schema are listed without the prefix&#010;+            name = stripOptionalPrefixFromName(rows, name);&#010;+            // the name may be using a prefix, so lets see if we can find the real property name&#010;+            String propertyName = getPropertyNameFromNameWithPrefix(rows, name);&#010;+            if (propertyName != null) {&#010;+                name = propertyName;&#010;+            }&#010;+&#010;+            String prefix = getPropertyPrefix(rows, name);&#010;+            String kind = getPropertyKind(rows, name);&#010;+            boolean namePlaceholder = name.startsWith(""{{"") &amp;&amp; name.endsWith(""}}"");&#010;+            boolean valuePlaceholder = value.startsWith(""{{"") || value.startsWith(""${"") || value.startsWith(""$simple{"");&#010;+            boolean lookup = value.startsWith(""#"") &amp;&amp; value.length() &gt; 1;&#010;+            // we cannot evaluate multi values as strict as the others, as we don't know their expected types&#010;+            boolean mulitValue = prefix != null &amp;&amp; originalName.startsWith(prefix) &amp;&amp; isPropertyMultiValue(rows, name);&#010;+&#010;+            Map&lt;String, String&gt; row = getRow(rows, name);&#010;+            if (row == null) {&#010;+                // unknown option&#010;+&#010;+                // only add as error if the component is not lenient properties, or not stub component&#010;+                // and the name is not a property placeholder for one or more values&#010;+                if (!namePlaceholder &amp;&amp; !""stub"".equals(scheme)) {&#010;+                    if (lenientProperties) {&#010;+                        // as if we are lenient then the option is a dynamic extra option which we cannot validate&#010;+                        result.addLenient(name);&#010;+                    } else {&#010;+                        // its unknown&#010;+                        result.addUnknown(name);&#010;+                        if (suggestionStrategy != null) {&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(getNames(rows), name);&#010;+                            if (suggestions != null) {&#010;+                                result.addUnknownSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+                    }&#010;+                }&#010;+            } else {&#010;+                if (""parameter"".equals(kind)) {&#010;+                    // consumer only or producer only mode for parameters&#010;+                    if (consumerOnly) {&#010;+                        boolean producer = isPropertyProducerOnly(rows, name);&#010;+                        if (producer) {&#010;+                            // the option is only for producer so you cannot use it in consumer mode&#010;+                            result.addNotConsumerOnly(name);&#010;+                        }&#010;+                    } else if (producerOnly) {&#010;+                        boolean consumer = isPropertyConsumerOnly(rows, name);&#010;+                        if (consumer) {&#010;+                            // the option is only for consumer so you cannot use it in producer mode&#010;+                            result.addNotProducerOnly(name);&#010;+                        }&#010;+                    }&#010;+                }&#010;+&#010;+                // default value&#010;+                String defaultValue = getPropertyDefaultValue(rows, name);&#010;+                if (defaultValue != null) {&#010;+                    result.addDefaultValue(name, defaultValue);&#010;+                }&#010;+&#010;+                // is required but the value is empty&#010;+                boolean required = isPropertyRequired(rows, name);&#010;+                if (required &amp;&amp; isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+&#010;+                // is enum but the value is not within the enum range&#010;+                // but we can only check if the value is not a placeholder&#010;+                String enums = getPropertyEnum(rows, name);&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; enums != null) {&#010;+                    String[] choices = enums.split("","");&#010;+                    boolean found = false;&#010;+                    for (String s : choices) {&#010;+                        if (value.equalsIgnoreCase(s)) {&#010;+                            found = true;&#010;+                            break;&#010;+                        }&#010;+                    }&#010;+                    if (!found) {&#010;+                        result.addInvalidEnum(name, value);&#010;+                        result.addInvalidEnumChoices(name, choices);&#010;+                        if (suggestionStrategy != null) {&#010;+                            Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;();&#010;+                            names.addAll(Arrays.asList(choices));&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(names, value);&#010;+                            if (suggestions != null) {&#010;+                                result.addInvalidEnumSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+&#010;+                    }&#010;+                }&#010;+&#010;+                // is reference lookup of bean (not applicable for @UriPath, enums, or multi-valued)&#010;+                if (!mulitValue &amp;&amp; enums == null &amp;&amp; !""path"".equals(kind) &amp;&amp; isPropertyObject(rows, name)) {&#010;+                    // must start with # and be at least 2 characters&#010;+                    if (!value.startsWith(""#"") || value.length() &lt;= 1) {&#010;+                        result.addInvalidReference(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is boolean&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyBoolean(rows, name)) {&#010;+                    // value must be a boolean&#010;+                    boolean bool = ""true"".equalsIgnoreCase(value) || ""false"".equalsIgnoreCase(value);&#010;+                    if (!bool) {&#010;+                        result.addInvalidBoolean(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is integer&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyInteger(rows, name)) {&#010;+                    // value must be an integer&#010;+                    boolean valid = validateInteger(value);&#010;+                    if (!valid) {&#010;+                        result.addInvalidInteger(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is number&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyNumber(rows, name)) {&#010;+                    // value must be an number&#010;+                    boolean valid = false;&#010;+                    try {&#010;+                        valid = !Double.valueOf(value).isNaN() || !Float.valueOf(value).isNaN();&#010;+                    } catch (Exception e) {&#010;+                        // ignore&#010;+                    }&#010;+                    if (!valid) {&#010;+                        result.addInvalidNumber(name, value);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // now check if all required values are there, and that a default value does not exists&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String name = row.get(""name"");&#010;+            boolean required = isPropertyRequired(rows, name);&#010;+            if (required) {&#010;+                String value = properties.get(name);&#010;+                if (isEmpty(value)) {&#010;+                    value = getPropertyDefaultValue(rows, name);&#010;+                }&#010;+                if (isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        return result;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; endpointProperties(String uri) throws URISyntaxException {&#010;+        // need to normalize uri first&#010;+        URI u = normalizeUri(uri);&#010;+        String scheme = u.getScheme();&#010;+&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        if (json == null) {&#010;+            throw new IllegalArgumentException(""Cannot find endpoint with scheme "" + scheme);&#010;+        }&#010;+&#010;+        // grab the syntax&#010;+        String syntax = null;&#010;+        String alternativeSyntax = null;&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""component"", json, false);&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""syntax"")) {&#010;+                syntax = row.get(""syntax"");&#010;+            }&#010;+            if (row.containsKey(""alternativeSyntax"")) {&#010;+                alternativeSyntax = row.get(""alternativeSyntax"");&#010;+            }&#010;+        }&#010;+        if (syntax == null) {&#010;+            throw new IllegalArgumentException(""Endpoint with scheme "" + scheme + "" has no syntax defined in the json schema"");&#010;+        }&#010;+&#010;+        // only if we support alternative syntax, and the uri contains the username and password in the authority&#010;+        // part of the uri, then we would need some special logic to capture that information and strip those&#010;+        // details from the uri, so we can continue parsing the uri using the normal syntax&#010;+        Map&lt;String, String&gt; userInfoOptions = new LinkedHashMap&lt;String, String&gt;();&#010;+        if (alternativeSyntax != null &amp;&amp; alternativeSyntax.contains(""@"")) {&#010;+            // clip the scheme from the syntax&#010;+            alternativeSyntax = after(alternativeSyntax, "":"");&#010;+            // trim so only userinfo&#010;+            int idx = alternativeSyntax.indexOf(""@"");&#010;+            String fields = alternativeSyntax.substring(0, idx);&#010;+            String[] names = fields.split("":"");&#010;+&#010;+            // grab authority part and grab username and/or password&#010;+            String authority = u.getAuthority();&#010;+            if (authority != null &amp;&amp; authority.contains(""@"")) {&#010;+                String username = null;&#010;+                String password = null;&#010;+&#010;+                // grab unserinfo part before @&#010;+                String userInfo = authority.substring(0, authority.indexOf(""@""));&#010;+                String[] parts = userInfo.split("":"");&#010;+                if (parts.length == 2) {&#010;+                    username = parts[0];&#010;+                    password = parts[1];&#010;+                } else {&#010;+                    // only username&#010;+                    username = userInfo;&#010;+                }&#010;+&#010;+                // remember the username and/or password which we add later to the options&#010;+                if (names.length == 2) {&#010;+                    userInfoOptions.put(names[0], username);&#010;+                    if (password != null) {&#010;+                        // password is optional&#010;+                        userInfoOptions.put(names[1], password);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // clip the scheme from the syntax&#010;+        syntax = after(syntax, "":"");&#010;+        // clip the scheme from the uri&#010;+        uri = after(uri, "":"");&#010;+        String uriPath = stripQuery(uri);&#010;+&#010;+        // strip user info from uri path&#010;+        if (!userInfoOptions.isEmpty()) {&#010;+            int idx = uriPath.indexOf('@');&#010;+            if (idx &gt; -1) {&#010;+                uriPath = uriPath.substring(idx + 1);&#010;+            }&#010;+        }&#010;+&#010;+        // strip double slash in the start&#010;+        if (uriPath != null &amp;&amp; uriPath.startsWith(""//"")) {&#010;+            uriPath = uriPath.substring(2);&#010;+        }&#010;+&#010;+        // parse the syntax and find the names of each option&#010;+        Matcher matcher = SYNTAX_PATTERN.matcher(syntax);&#010;+        List&lt;String&gt; word = new ArrayList&lt;String&gt;();&#010;+        while (matcher.find()) {&#010;+            String s = matcher.group(1);&#010;+            if (!scheme.equals(s)) {&#010;+                word.add(s);&#010;+            }&#010;+        }&#010;+        // parse the syntax and find each token between each option&#010;+        String[] tokens = SYNTAX_PATTERN.split(syntax);&#010;+&#010;+        // find the position where each option start/end&#010;+        List&lt;String&gt; word2 = new ArrayList&lt;String&gt;();&#010;+        int prev = 0;&#010;+        int prevPath = 0;&#010;+&#010;+        // special for activemq/jms where the enum for destinationType causes a token issue as it includes a colon&#010;+        // for 'temp:queue' and 'temp:topic' values&#010;+        if (""activemq"".equals(scheme) || ""jms"".equals(scheme)) {&#010;+            if (uriPath.startsWith(""temp:"")) {&#010;+                prevPath = 5;&#010;+            }&#010;+        }&#010;+&#010;+        for (String token : tokens) {&#010;+            if (token.isEmpty()) {&#010;+                continue;&#010;+            }&#010;+&#010;+            // special for some tokens where :// can be used also, eg http://foo&#010;+            int idx = -1;&#010;+            int len = 0;&#010;+            if ("":"".equals(token)) {&#010;+                idx = uriPath.indexOf(""://"", prevPath);&#010;+                len = 3;&#010;+            }&#010;+            if (idx == -1) {&#010;+                idx = uriPath.indexOf(token, prevPath);&#010;+                len = token.length();&#010;+            }&#010;+&#010;+            if (idx &gt; 0) {&#010;+                String option = uriPath.substring(prev, idx);&#010;+                word2.add(option);&#010;+                prev = idx + len;&#010;+                prevPath = prev;&#010;+            }&#010;+        }&#010;+        // special for last or if we did not add anyone&#010;+        if (prev &gt; 0 || word2.isEmpty()) {&#010;+            String option = uriPath.substring(prev);&#010;+            word2.add(option);&#010;+        }&#010;+&#010;+        rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        boolean defaultValueAdded = false;&#010;+&#010;+        // now parse the uri to know which part isw what&#010;+        Map&lt;String, String&gt; options = new LinkedHashMap&lt;String, String&gt;();&#010;+&#010;+        // include the username and password from the userinfo section&#010;+        if (!userInfoOptions.isEmpty()) {&#010;+            options.putAll(userInfoOptions);&#010;+        }&#010;+&#010;+        // word contains the syntax path elements&#010;+        Iterator&lt;String&gt; it = word2.iterator();&#010;+        for (int i = 0; i &lt; word.size(); i++) {&#010;+            String key = word.get(i);&#010;+&#010;+            boolean allOptions = word.size() == word2.size();&#010;+            boolean required = isPropertyRequired(rows, key);&#010;+            String defaultValue = getPropertyDefaultValue(rows, key);&#010;+&#010;+            // we have all options so no problem&#010;+            if (allOptions) {&#010;+                String value = it.next();&#010;+                options.put(key, value);&#010;+            } else {&#010;+                // we have a little problem as we do not not have all options&#010;+                if (!required) {&#010;+                    String value = null;&#010;+&#010;+                    boolean last = i == word.size() - 1;&#010;+                    if (last) {&#010;+                        // if its the last value then use it instead of the default value&#010;+                        value = it.hasNext() ? it.next() : null;&#010;+                        if (value != null) {&#010;+                            options.put(key, value);&#010;+                        } else {&#010;+                            value = defaultValue;&#010;+                        }&#010;+                    }&#010;+                    if (value != null) {&#010;+                        options.put(key, value);&#010;+                        defaultValueAdded = true;&#010;+                    }&#010;+                } else {&#010;+                    String value = it.hasNext() ? it.next() : null;&#010;+                    if (value != null) {&#010;+                        options.put(key, value);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        Map&lt;String, String&gt; answer = new LinkedHashMap&lt;String, String&gt;();&#010;+&#010;+        // remove all options which are using default values and are not required&#010;+        for (Map.Entry&lt;String, String&gt; entry : options.entrySet()) {&#010;+            String key = entry.getKey();&#010;+            String value = entry.getValue();&#010;+&#010;+            if (defaultValueAdded) {&#010;+                boolean required = isPropertyRequired(rows, key);&#010;+                String defaultValue = getPropertyDefaultValue(rows, key);&#010;+&#010;+                if (!required &amp;&amp; defaultValue != null) {&#010;+                    if (defaultValue.equals(value)) {&#010;+                        continue;&#010;+                    }&#010;+                }&#010;+            }&#010;+&#010;+            // we should keep this in the answer&#010;+            answer.put(key, value);&#010;+        }&#010;+&#010;+        // now parse the uri parameters&#010;+        Map&lt;String, Object&gt; parameters = URISupport.parseParameters(u);&#010;+&#010;+        // and covert the values to String so its JMX friendly&#010;+        while (!parameters.isEmpty()) {&#010;+            Map.Entry&lt;String, Object&gt; entry = parameters.entrySet().iterator().next();&#010;+            String key = entry.getKey();&#010;+            String value = entry.getValue() != null ? entry.getValue().toString() : """";&#010;+&#010;+            boolean multiValued = isPropertyMultiValue(rows, key);&#010;+            if (multiValued) {&#010;+                String prefix = getPropertyPrefix(rows, key);&#010;+                // extra all the multi valued options&#010;+                Map&lt;String, Object&gt; values = URISupport.extractProperties(parameters, prefix);&#010;+                // build a string with the extra multi valued options with the prefix and &amp; as separator&#010;+                CollectionStringBuffer csb = new CollectionStringBuffer(""&amp;"");&#010;+                for (Map.Entry&lt;String, Object&gt; multi : values.entrySet()) {&#010;+                    String line = prefix + multi.getKey() + ""="" + (multi.getValue() != null ? multi.getValue().toString() : """");&#010;+                    csb.append(line);&#010;+                }&#010;+                // append the extra multi-values to the existing (which contains the first multi value)&#010;+                if (!csb.isEmpty()) {&#010;+                    value = value + ""&amp;"" + csb.toString();&#010;+                }&#010;+            }&#010;+&#010;+            answer.put(key, value);&#010;+            // remove the parameter as we run in a while loop until no more parameters&#010;+            parameters.remove(key);&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; endpointLenientProperties(String uri) throws URISyntaxException {&#010;+        // need to normalize uri first&#010;+&#010;+        // parse the uri&#010;+        URI u = normalizeUri(uri);&#010;+        String scheme = u.getScheme();&#010;+&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        if (json == null) {&#010;+            throw new IllegalArgumentException(""Cannot find endpoint with scheme "" + scheme);&#010;+        }&#010;+&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        // now parse the uri parameters&#010;+        Map&lt;String, Object&gt; parameters = URISupport.parseParameters(u);&#010;+&#010;+        // all the known options&#010;+        Set&lt;String&gt; names = getNames(rows);&#010;+&#010;+        Map&lt;String, String&gt; answer = new LinkedHashMap&lt;&gt;();&#010;+&#010;+        // and covert the values to String so its JMX friendly&#010;+        parameters.forEach((k, v) -&gt; {&#010;+            String key = k;&#010;+            String value = v != null ? v.toString() : """";&#010;+&#010;+            // is the key a prefix property&#010;+            int dot = key.indexOf('.');&#010;+            if (dot != -1) {&#010;+                String prefix = key.substring(0, dot + 1); // include dot in prefix&#010;+                String option = getPropertyNameFromNameWithPrefix(rows, prefix);&#010;+                if (option == null || !isPropertyMultiValue(rows, option)) {&#010;+                    answer.put(key, value);&#010;+                }&#010;+            } else if (!names.contains(key)) {&#010;+                answer.put(key, value);&#010;+            }&#010;+        });&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    public String endpointComponentName(String uri) {&#010;+        if (uri != null) {&#010;+            int idx = uri.indexOf("":"");&#010;+            if (idx &gt; 0) {&#010;+                return uri.substring(0, idx);&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public String asEndpointUri(String scheme, String json, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, json, ""&amp;"", encode);&#010;+    }&#010;+&#010;+    public String asEndpointUriXml(String scheme, String json, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, json, ""&amp;amp;"", encode);&#010;+    }&#010;+&#010;+    private String doAsEndpointUri(String scheme, String json, String ampersand, boolean encode) throws URISyntaxException {&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        Map&lt;String, String&gt; copy = new HashMap&lt;String, String&gt;();&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String name = row.get(""name"");&#010;+            String required = row.get(""required"");&#010;+            String value = row.get(""value"");&#010;+            String defaultValue = row.get(""defaultValue"");&#010;+&#010;+            // only add if either required, or the value is != default value&#010;+            String valueToAdd = null;&#010;+            if (""true"".equals(required)) {&#010;+                valueToAdd = value != null ? value : defaultValue;&#010;+                if (valueToAdd == null) {&#010;+                    valueToAdd = """";&#010;+                }&#010;+            } else {&#010;+                // if we have a value and no default then add it&#010;+                if (value != null &amp;&amp; defaultValue == null) {&#010;+                    valueToAdd = value;&#010;+                }&#010;+                // otherwise only add if the value is != default value&#010;+                if (value != null &amp;&amp; defaultValue != null &amp;&amp; !value.equals(defaultValue)) {&#010;+                    valueToAdd = value;&#010;+                }&#010;+            }&#010;+&#010;+            if (valueToAdd != null) {&#010;+                copy.put(name, valueToAdd);&#010;+            }&#010;+        }&#010;+&#010;+        return doAsEndpointUri(scheme, copy, ampersand, encode);&#010;+    }&#010;+&#010;+    public String asEndpointUri(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, properties, ""&amp;"", encode);&#010;+    }&#010;+&#010;+    public String asEndpointUriXml(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, properties, ""&amp;amp;"", encode);&#010;+    }&#010;+&#010;+    String doAsEndpointUri(String scheme, Map&lt;String, String&gt; properties, String ampersand, boolean encode) throws URISyntaxException {&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        if (json == null) {&#010;+            throw new IllegalArgumentException(""Cannot find endpoint with scheme "" + scheme);&#010;+        }&#010;+&#010;+        // grab the syntax&#010;+        String syntax = null;&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""component"", json, false);&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""syntax"")) {&#010;+                syntax = row.get(""syntax"");&#010;+                break;&#010;+            }&#010;+        }&#010;+        if (syntax == null) {&#010;+            throw new IllegalArgumentException(""Endpoint with scheme "" + scheme + "" has no syntax defined in the json schema"");&#010;+        }&#010;+&#010;+        // do any properties filtering which can be needed for some special components&#010;+        properties = filterProperties(scheme, properties);&#010;+&#010;+        rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        // clip the scheme from the syntax&#010;+        syntax = after(syntax, "":"");&#010;+&#010;+        String originalSyntax = syntax;&#010;+&#010;+        // build at first according to syntax (use a tree map as we want the uri options sorted)&#010;+        Map&lt;String, String&gt; copy = new TreeMap&lt;String, String&gt;();&#010;+        for (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) {&#010;+            String key = entry.getKey();&#010;+            String value = entry.getValue() != null ? entry.getValue() : """";&#010;+            if (syntax != null &amp;&amp; syntax.contains(key)) {&#010;+                syntax = syntax.replace(key, value);&#010;+            } else {&#010;+                copy.put(key, value);&#010;+            }&#010;+        }&#010;+&#010;+        // do we have all the options the original syntax needs (easy way)&#010;+        String[] keys = syntaxKeys(originalSyntax);&#010;+        boolean hasAllKeys = properties.keySet().containsAll(Arrays.asList(keys));&#010;+&#010;+        // build endpoint uri&#010;+        StringBuilder sb = new StringBuilder();&#010;+        sb.append(scheme);&#010;+        sb.append("":"");&#010;+&#010;+        if (hasAllKeys) {&#010;+            // we have all the keys for the syntax so we can build the uri the easy way&#010;+            sb.append(syntax);&#010;+&#010;+            if (!copy.isEmpty()) {&#010;+                boolean hasQuestionmark = sb.toString().contains(""?"");&#010;+                // the last option may already contain a ? char, if so we should use &amp; instead of ?&#010;+                sb.append(hasQuestionmark ? ampersand : '?');&#010;+                String query = createQueryString(copy, ampersand, encode);&#010;+                sb.append(query);&#010;+            }&#010;+        } else {&#010;+            // TODO: revisit this and see if we can do this in another way&#010;+            // oh darn some options is missing, so we need a complex way of building the uri&#010;+&#010;+            // the tokens between the options in the path&#010;+            String[] tokens = syntax.split(""\\w+"");&#010;+&#010;+            // parse the syntax into each options&#010;+            Matcher matcher = SYNTAX_PATTERN.matcher(originalSyntax);&#010;+            List&lt;String&gt; options = new ArrayList&lt;String&gt;();&#010;+            while (matcher.find()) {&#010;+                String s = matcher.group(1);&#010;+                options.add(s);&#010;+            }&#010;+&#010;+            // need to preserve {{ and }} from the syntax&#010;+            // (we need to use words only as its provisional placeholders)&#010;+            syntax = syntax.replaceAll(""\\{\\{"", ""BEGINCAMELPLACEHOLDER"");&#010;+            syntax = syntax.replaceAll(""\\}\\}"", ""ENDCAMELPLACEHOLDER"");&#010;+&#010;+            // parse the syntax into each options&#010;+            Matcher matcher2 = SYNTAX_PATTERN.matcher(syntax);&#010;+            List&lt;String&gt; options2 = new ArrayList&lt;String&gt;();&#010;+            while (matcher2.find()) {&#010;+                String s = matcher2.group(1);&#010;+                s = s.replaceAll(""BEGINCAMELPLACEHOLDER"", ""\\{\\{"");&#010;+                s = s.replaceAll(""ENDCAMELPLACEHOLDER"", ""\\}\\}"");&#010;+                options2.add(s);&#010;+            }&#010;+&#010;+            // build the endpoint&#010;+            int range = 0;&#010;+            boolean first = true;&#010;+            boolean hasQuestionmark = false;&#010;+            for (int i = 0; i &lt; options.size(); i++) {&#010;+                String key = options.get(i);&#010;+                String key2 = options2.get(i);&#010;+                String token = null;&#010;+                if (tokens.length &gt; i) {&#010;+                    token = tokens[i];&#010;+                }&#010;+&#010;+                boolean contains = properties.containsKey(key);&#010;+                if (!contains) {&#010;+                    // if the key are similar we have no explicit value and can try to find a default value if the option is required&#010;+                    if (isPropertyRequired(rows, key)) {&#010;+                        String value = getPropertyDefaultValue(rows, key);&#010;+                        if (value != null) {&#010;+                            properties.put(key, value);&#010;+                            key2 = value;&#010;+                        }&#010;+                    }&#010;+                }&#010;+&#010;+                // was the option provided?&#010;+                if (properties.containsKey(key)) {&#010;+                    if (!first &amp;&amp; token != null) {&#010;+                        sb.append(token);&#010;+                    }&#010;+                    hasQuestionmark |= key.contains(""?"") || (token != null &amp;&amp; token.contains(""?""));&#010;+                    sb.append(key2);&#010;+                    first = false;&#010;+                }&#010;+                range++;&#010;+            }&#010;+            // append any extra options that was in surplus for the last&#010;+            while (range &lt; options2.size()) {&#010;+                String token = null;&#010;+                if (tokens.length &gt; range) {&#010;+                    token = tokens[range];&#010;+                }&#010;+                String key2 = options2.get(range);&#010;+                sb.append(token);&#010;+                sb.append(key2);&#010;+                hasQuestionmark |= key2.contains(""?"") || (token != null &amp;&amp; token.contains(""?""));&#010;+                range++;&#010;+            }&#010;+&#010;+&#010;+            if (!copy.isEmpty()) {&#010;+                // the last option may already contain a ? char, if so we should use &amp; instead of ?&#010;+                sb.append(hasQuestionmark ? ampersand : '?');&#010;+                String query = createQueryString(copy, ampersand, encode);&#010;+                sb.append(query);&#010;+            }&#010;+        }&#010;+&#010;+        return sb.toString();&#010;+    }&#010;+&#010;+    @Deprecated&#010;+    private static String[] syntaxTokens(String syntax) {&#010;+        // build tokens between the words&#010;+        List&lt;String&gt; tokens = new ArrayList&lt;&gt;();&#010;+        // preserve backwards behavior which had an empty token first&#010;+        tokens.add("""");&#010;+&#010;+        String current = """";&#010;+        for (int i = 0; i &lt; syntax.length(); i++) {&#010;+            char ch = syntax.charAt(i);&#010;+            if (Character.isLetterOrDigit(ch)) {&#010;+                // reset for new current tokens&#010;+                if (current.length() &gt; 0) {&#010;+                    tokens.add(current);&#010;+                    current = """";&#010;+                }&#010;+            } else {&#010;+                current += ch;&#010;+            }&#010;+        }&#010;+        // anything left over?&#010;+        if (current.length() &gt; 0) {&#010;+            tokens.add(current);&#010;+        }&#010;+&#010;+        return tokens.toArray(new String[tokens.size()]);&#010;+    }&#010;+&#010;+    private static String[] syntaxKeys(String syntax) {&#010;+        // build tokens between the separators&#010;+        List&lt;String&gt; tokens = new ArrayList&lt;&gt;();&#010;+&#010;+        String current = """";&#010;+        for (int i = 0; i &lt; syntax.length(); i++) {&#010;+            char ch = syntax.charAt(i);&#010;+            if (Character.isLetterOrDigit(ch)) {&#010;+                current += ch;&#010;+            } else {&#010;+                // reset for new current tokens&#010;+                if (current.length() &gt; 0) {&#010;+                    tokens.add(current);&#010;+                    current = """";&#010;+                }&#010;+            }&#010;+        }&#010;+        // anything left over?&#010;+        if (current.length() &gt; 0) {&#010;+            tokens.add(current);&#010;+        }&#010;+&#010;+        return tokens.toArray(new String[tokens.size()]);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimpleExpression(String simple) {&#010;+        return doValidateSimple(null, simple, false);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimpleExpression(ClassLoader classLoader, String simple) {&#010;+        return doValidateSimple(classLoader, simple, false);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimplePredicate(String simple) {&#010;+        return doValidateSimple(null, simple, true);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimplePredicate(ClassLoader classLoader, String simple) {&#010;+        return doValidateSimple(classLoader, simple, true);&#010;+    }&#010;+&#010;+    private SimpleValidationResult doValidateSimple(ClassLoader classLoader, String simple, boolean predicate) {&#010;+        if (classLoader == null) {&#010;+            classLoader = getClass().getClassLoader();&#010;+        }&#010;+&#010;+        // if there are {{ }}} property placeholders then we need to resolve them to something else&#010;+        // as the simple parse cannot resolve them before parsing as we dont run the actual Camel application&#010;+        // with property placeholders setup so we need to dummy this by replace the {{ }} to something else&#010;+        // therefore we use an more unlikely character: {{XXX}} to ~^XXX^~&#010;+        String resolved = simple.replaceAll(""\\{\\{(.+)\\}\\}"", ""~^$1^~"");&#010;+&#010;+        SimpleValidationResult answer = new SimpleValidationResult(simple);&#010;+&#010;+        Object instance = null;&#010;+        Class clazz = null;&#010;+        try {&#010;+            clazz = classLoader.loadClass(""org.apache.camel.language.simple.SimpleLanguage"");&#010;+            instance = clazz.newInstance();&#010;+        } catch (Exception e) {&#010;+            // ignore&#010;+        }&#010;+&#010;+        if (clazz != null &amp;&amp; instance != null) {&#010;+            Throwable cause = null;&#010;+            try {&#010;+                if (predicate) {&#010;+                    instance.getClass().getMethod(""createPredicate"", String.class).invoke(instance, resolved);&#010;+                } else {&#010;+                    instance.getClass().getMethod(""createExpression"", String.class).invoke(instance, resolved);&#010;+                }&#010;+            } catch (InvocationTargetException e) {&#010;+                cause = e.getTargetException();&#010;+            } catch (Exception e) {&#010;+                cause = e;&#010;+            }&#010;+&#010;+            if (cause != null) {&#010;+&#010;+                // reverse ~^XXX^~ back to {{XXX}}&#010;+                String errMsg = cause.getMessage();&#010;+                errMsg = errMsg.replaceAll(""\\~\\^(.+)\\^\\~"", ""{{$1}}"");&#010;+&#010;+                answer.setError(errMsg);&#010;+&#010;+                // is it simple parser exception then we can grab the index where the problem is&#010;+                if (cause.getClass().getName().equals(""org.apache.camel.language.simple.types.SimpleIllegalSyntaxException"")&#010;+                    || cause.getClass().getName().equals(""org.apache.camel.language.simple.types.SimpleParserException"")) {&#010;+                    try {&#010;+                        // we need to grab the index field from those simple parser exceptions&#010;+                        Method method = cause.getClass().getMethod(""getIndex"");&#010;+                        Object result = method.invoke(cause);&#010;+                        if (result != null) {&#010;+                            int index = (int) result;&#010;+                            answer.setIndex(index);&#010;+                        }&#010;+                    } catch (Throwable i) {&#010;+                        // ignore&#010;+                    }&#010;+                }&#010;+&#010;+                // we need to grab the short message field from this simple syntax exception&#010;+                if (cause.getClass().getName().equals(""org.apache.camel.language.simple.types.SimpleIllegalSyntaxException"")) {&#010;+                    try {&#010;+                        Method method = cause.getClass().getMethod(""getShortMessage"");&#010;+                        Object result = method.invoke(cause);&#010;+                        if (result != null) {&#010;+                            String msg = (String) result;&#010;+                            answer.setShortError(msg);&#010;+                        }&#010;+                    } catch (Throwable i) {&#010;+                        // ignore&#010;+                    }&#010;+&#010;+                    if (answer.getShortError() == null) {&#010;+                        // fallback and try to make existing message short instead&#010;+                        String msg = answer.getError();&#010;+                        // grab everything before "" at location "" which would be regarded as the short message&#010;+                        int idx = msg.indexOf("" at location "");&#010;+                        if (idx &gt; 0) {&#010;+                            msg = msg.substring(0, idx);&#010;+                            answer.setShortError(msg);&#010;+                        }&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    public LanguageValidationResult validateLanguagePredicate(ClassLoader classLoader, String language, String text) {&#010;+        return doValidateLanguage(classLoader, language, text, true);&#010;+    }&#010;+&#010;+    public LanguageValidationResult validateLanguageExpression(ClassLoader classLoader, String language, String text) {&#010;+        return doValidateLanguage(classLoader, language, text, false);&#010;+    }&#010;+&#010;+    private LanguageValidationResult doValidateLanguage(ClassLoader classLoader, String language, String text, boolean predicate) {&#010;+        if (classLoader == null) {&#010;+            classLoader = getClass().getClassLoader();&#010;+        }&#010;+&#010;+        SimpleValidationResult answer = new SimpleValidationResult(text);&#010;+&#010;+        String json = jsonSchemaResolver.getLanguageJSonSchema(language);&#010;+        if (json == null) {&#010;+            answer.setError(""Unknown language "" + language);&#010;+            return answer;&#010;+        }&#010;+&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""language"", json, false);&#010;+        String className = null;&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""javaType"")) {&#010;+                className = row.get(""javaType"");&#010;+            }&#010;+        }&#010;+&#010;+        if (className == null) {&#010;+            answer.setError(""Cannot find javaType for language "" + language);&#010;+            return answer;&#010;+        }&#010;+&#010;+        Object instance = null;&#010;+        Class clazz = null;&#010;+        try {&#010;+            clazz = classLoader.loadClass(className);&#010;+            instance = clazz.newInstance();&#010;+        } catch (Exception e) {&#010;+            // ignore&#010;+        }&#010;+&#010;+        if (clazz != null &amp;&amp; instance != null) {&#010;+            Throwable cause = null;&#010;+            try {&#010;+                if (predicate) {&#010;+                    instance.getClass().getMethod(""createPredicate"", String.class).invoke(instance, text);&#010;+                } else {&#010;+                    instance.getClass().getMethod(""createExpression"", String.class).invoke(instance, text);&#010;+                }&#010;+            } catch (InvocationTargetException e) {&#010;+                cause = e.getTargetException();&#010;+            } catch (Exception e) {&#010;+                cause = e;&#010;+            }&#010;+&#010;+            if (cause != null) {&#010;+                answer.setError(cause.getMessage());&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    /**&#010;+     * Special logic for log endpoints to deal when showAll=true&#010;+     */&#010;+    private Map&lt;String, String&gt; filterProperties(String scheme, Map&lt;String, String&gt; options) {&#010;+        if (""log"".equals(scheme)) {&#010;+            String showAll = options.get(""showAll"");&#010;+            if (""true"".equals(showAll)) {&#010;+                Map&lt;String, String&gt; filtered = new LinkedHashMap&lt;String, String&gt;();&#010;+                // remove all the other showXXX options when showAll=true&#010;+                for (Map.Entry&lt;String, String&gt; entry : options.entrySet()) {&#010;+                    String key = entry.getKey();&#010;+                    boolean skip = key.startsWith(""show"") &amp;&amp; !key.equals(""showAll"");&#010;+                    if (!skip) {&#010;+                        filtered.put(key, entry.getValue());&#010;+                    }&#010;+                }&#010;+                return filtered;&#010;+            }&#010;+        }&#010;+        // use as-is&#010;+        return options;&#010;+    }&#010;+&#010;+    private static boolean validateInteger(String value) {&#010;+        boolean valid = false;&#010;+        try {&#010;+            valid = Integer.valueOf(value) != null;&#010;+        } catch (Exception e) {&#010;+            // ignore&#010;+        }&#010;+        if (!valid) {&#010;+            // it may be a time pattern, such as 5s for 5 seconds = 5000&#010;+            try {&#010;+                TimePatternConverter.toMilliSeconds(value);&#010;+                valid = true;&#010;+            } catch (Exception e) {&#010;+                // ignore&#010;+            }&#010;+        }&#010;+        return valid;&#010;+    }&#010;+&#010;+    // CHECKSTYLE:ON&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java&#010;new file mode 100644&#010;index 0000000..d3a448c&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java&#010;@@ -0,0 +1,80 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.IOException;&#010;+&#010;+import org.apache.camel.CamelContext;&#010;+&#010;+/**&#010;+ * Uses runtime {@link CamelContext} to resolve the JSon schema files.&#010;+ */&#010;+public class CamelContextJSonSchemaResolver implements JSonSchemaResolver {&#010;+&#010;+    private final CamelContext camelContext;&#010;+&#010;+    public CamelContextJSonSchemaResolver(CamelContext camelContext) {&#010;+        this.camelContext = camelContext;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getComponentJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getComponentParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getDataFormatJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getDataFormatParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getLanguageJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getLanguageParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getOtherJSonSchema(String name) {&#010;+        // not supported&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getModelJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getEipParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java&#010;new file mode 100644&#010;index 0000000..1b224df&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java&#010;@@ -0,0 +1,179 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.BufferedReader;&#010;+import java.io.IOException;&#010;+import java.io.InputStream;&#010;+import java.io.InputStreamReader;&#010;+import java.io.LineNumberReader;&#010;+import java.util.List;&#010;+&#010;+public final class CatalogHelper {&#010;+&#010;+    private CatalogHelper() {&#010;+    }&#010;+&#010;+    /**&#010;+     * Loads the entire stream into memory as a String and returns it.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Notice:&lt;/b&gt; This implementation appends a &lt;tt&gt;\n&lt;/tt&gt; as line&#010;+     * terminator at the of the text.&#010;+     * &lt;p/&gt;&#010;+     * Warning, don't use for crazy big streams :)&#010;+     */&#010;+    public static void loadLines(InputStream in, List&lt;String&gt; lines) throws IOException {&#010;+        try (final InputStreamReader isr = new InputStreamReader(in);&#010;+            final BufferedReader reader = new LineNumberReader(isr)) {&#010;+            String line;&#010;+            while ((line = reader.readLine()) != null) {&#010;+                lines.add(line);&#010;+            }&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Loads the entire stream into memory as a String and returns it.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Notice:&lt;/b&gt; This implementation appends a &lt;tt&gt;\n&lt;/tt&gt; as line&#010;+     * terminator at the of the text.&#010;+     * &lt;p/&gt;&#010;+     * Warning, don't use for crazy big streams :)&#010;+     */&#010;+    public static String loadText(InputStream in) throws IOException {&#010;+        StringBuilder builder = new StringBuilder();&#010;+        try (final InputStreamReader isr = new InputStreamReader(in);&#010;+            final BufferedReader reader = new LineNumberReader(isr)) {&#010;+            String line;&#010;+            while ((line = reader.readLine()) != null) {&#010;+                builder.append(line);&#010;+                builder.append(""\n"");&#010;+            }&#010;+            return builder.toString();&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Matches the name with the pattern.&#010;+     *&#010;+     * @param name  the name&#010;+     * @param pattern the pattern&#010;+     * @return &lt;tt&gt;true&lt;/tt&gt; if matched, or &lt;tt&gt;false&lt;/tt&gt; if not&#010;+     */&#010;+    public static boolean matchWildcard(String name, String pattern) {&#010;+        // we have wildcard support in that hence you can match with: file* to match any file endpoints&#010;+        if (pattern.endsWith(""*"") &amp;&amp; name.startsWith(pattern.substring(0, pattern.length() - 1))) {&#010;+            return true;&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    /**&#010;+     * Returns the string after the given token&#010;+     *&#010;+     * @param text  the text&#010;+     * @param after the token&#010;+     * @return the text after the token, or &lt;tt&gt;null&lt;/tt&gt; if text does not contain the token&#010;+     */&#010;+    public static String after(String text, String after) {&#010;+        if (!text.contains(after)) {&#010;+            return null;&#010;+        }&#010;+        return text.substring(text.indexOf(after) + after.length());&#010;+    }&#010;+&#010;+    /**&#010;+     * Returns the string before the given token&#010;+     *&#010;+     * @param text  the text&#010;+     * @param before the token&#010;+     * @return the text before the token, or &lt;tt&gt;null&lt;/tt&gt; if text does not contain the token&#010;+     */&#010;+    public static String before(String text, String before) {&#010;+        if (!text.contains(before)) {&#010;+            return null;&#010;+        }&#010;+        return text.substring(0, text.indexOf(before));&#010;+    }&#010;+&#010;+    /**&#010;+     * Returns the string between the given tokens&#010;+     *&#010;+     * @param text  the text&#010;+     * @param after the before token&#010;+     * @param before the after token&#010;+     * @return the text between the tokens, or &lt;tt&gt;null&lt;/tt&gt; if text does not contain the tokens&#010;+     */&#010;+    public static String between(String text, String after, String before) {&#010;+        text = after(text, after);&#010;+        if (text == null) {&#010;+            return null;&#010;+        }&#010;+        return before(text, before);&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if empty&#010;+     */&#010;+    public static boolean isEmpty(Object value) {&#010;+        return !isNotEmpty(value);&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;b&gt;not&lt;/b&gt; &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if &lt;b&gt;not&lt;/b&gt; empty&#010;+     */&#010;+    public static boolean isNotEmpty(Object value) {&#010;+        if (value == null) {&#010;+            return false;&#010;+        } else if (value instanceof String) {&#010;+            String text = (String) value;&#010;+            return text.trim().length() &gt; 0;&#010;+        } else {&#010;+            return true;&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Removes all leading and ending quotes (single and double) from the string&#010;+     *&#010;+     * @param s  the string&#010;+     * @return the string without leading and ending quotes (single and double)&#010;+     */&#010;+    public static String removeLeadingAndEndingQuotes(String s) {&#010;+        if (isEmpty(s)) {&#010;+            return s;&#010;+        }&#010;+&#010;+        String copy = s.trim();&#010;+        if (copy.startsWith(""'"") &amp;&amp; copy.endsWith(""'"")) {&#010;+            return copy.substring(1, copy.length() - 1);&#010;+        }&#010;+        if (copy.startsWith(""\"""") &amp;&amp; copy.endsWith(""\"""")) {&#010;+            return copy.substring(1, copy.length() - 1);&#010;+        }&#010;+&#010;+        // no quotes, so return as-is&#010;+        return s;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java&#010;new file mode 100644&#010;index 0000000..f6484b8&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java&#010;@@ -0,0 +1,57 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+public class CollectionStringBuffer {&#010;+    private final StringBuilder buffer = new StringBuilder();&#010;+    private String separator;&#010;+    private boolean first = true;&#010;+&#010;+    public CollectionStringBuffer() {&#010;+        this("", "");&#010;+    }&#010;+&#010;+    public CollectionStringBuffer(String separator) {&#010;+        this.separator = separator;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String toString() {&#010;+        return buffer.toString();&#010;+    }&#010;+&#010;+    public void append(Object value) {&#010;+        if (first) {&#010;+            first = false;&#010;+        } else {&#010;+            buffer.append(separator);&#010;+        }&#010;+        buffer.append(value);&#010;+    }&#010;+&#010;+    public String getSeparator() {&#010;+        return separator;&#010;+    }&#010;+&#010;+    public void setSeparator(String separator) {&#010;+        this.separator = separator;&#010;+    }&#010;+&#010;+    public boolean isEmpty() {&#010;+        return first;&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java&#010;new file mode 100644&#010;index 0000000..7648e64&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java&#010;@@ -0,0 +1,136 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.HashMap;&#010;+import java.util.Map;&#010;+&#010;+import org.apache.camel.CamelContext;&#010;+&#010;+/**&#010;+ * Default {@link RuntimeCamelCatalog}.&#010;+ */&#010;+public class DefaultRuntimeCamelCatalog extends AbstractCamelCatalog implements RuntimeCamelCatalog {&#010;+&#010;+    // cache of operation -&gt; result&#010;+    private final Map&lt;String, Object&gt; cache = new HashMap&lt;String, Object&gt;();&#010;+    private boolean caching;&#010;+&#010;+    /**&#010;+     * Creates the {@link RuntimeCamelCatalog} without caching enabled.&#010;+     *&#010;+     * @param camelContext  the camel context&#010;+     */&#010;+    public DefaultRuntimeCamelCatalog(CamelContext camelContext) {&#010;+        this(camelContext, false);&#010;+    }&#010;+&#010;+    /**&#010;+     * Creates the {@link RuntimeCamelCatalog}&#010;+     *&#010;+     * @param camelContext  the camel context&#010;+     * @param caching  whether to use cache&#010;+     */&#010;+    public DefaultRuntimeCamelCatalog(CamelContext camelContext, boolean caching) {&#010;+        this.caching = caching;&#010;+        setJSonSchemaResolver(new CamelContextJSonSchemaResolver(camelContext));&#010;+    }&#010;+&#010;+    @Override&#010;+    public void start() throws Exception {&#010;+        // noop&#010;+    }&#010;+&#010;+    @Override&#010;+    public void stop() throws Exception {&#010;+        cache.clear();&#010;+    }&#010;+&#010;+    @Override&#010;+    public String modelJSonSchema(String name) {&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""model-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getModelJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""model-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String componentJSonSchema(String name) {&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""component-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getComponentJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""component-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String dataFormatJSonSchema(String name) {&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""dataformat-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getDataFormatJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""dataformat-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String languageJSonSchema(String name) {&#010;+        // if we try to look method then its in the bean.json file&#010;+        if (""method"".equals(name)) {&#010;+            name = ""bean"";&#010;+        }&#010;+&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""language-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getLanguageJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""language-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java&#010;new file mode 100644&#010;index 0000000..7d1c657&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java&#010;@@ -0,0 +1,451 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.Serializable;&#010;+import java.util.Arrays;&#010;+import java.util.Collections;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.LinkedHashSet;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+import java.util.Set;&#010;+&#010;+import static org.apache.camel.runtimecatalog.URISupport.isEmpty;&#010;+&#010;+/**&#010;+ * Details result of validating endpoint uri.&#010;+ */&#010;+public class EndpointValidationResult implements Serializable {&#010;+&#010;+    private final String uri;&#010;+    private int errors;&#010;+&#010;+    // general&#010;+    private String syntaxError;&#010;+    private String unknownComponent;&#010;+    private String incapable;&#010;+&#010;+    // options&#010;+    private Set&lt;String&gt; unknown;&#010;+    private Map&lt;String, String[]&gt; unknownSuggestions;&#010;+    private Set&lt;String&gt; lenient;&#010;+    private Set&lt;String&gt; notConsumerOnly;&#010;+    private Set&lt;String&gt; notProducerOnly;&#010;+    private Set&lt;String&gt; required;&#010;+    private Map&lt;String, String&gt; invalidEnum;&#010;+    private Map&lt;String, String[]&gt; invalidEnumChoices;&#010;+    private Map&lt;String, String[]&gt; invalidEnumSuggestions;&#010;+    private Map&lt;String, String&gt; invalidReference;&#010;+    private Map&lt;String, String&gt; invalidBoolean;&#010;+    private Map&lt;String, String&gt; invalidInteger;&#010;+    private Map&lt;String, String&gt; invalidNumber;&#010;+    private Map&lt;String, String&gt; defaultValues;&#010;+&#010;+    public EndpointValidationResult() {&#010;+        this(null);&#010;+    }&#010;+&#010;+    public EndpointValidationResult(String uri) {&#010;+        this.uri = uri;&#010;+    }&#010;+&#010;+    public String getUri() {&#010;+        return uri;&#010;+    }&#010;+&#010;+    public boolean hasErrors() {&#010;+        return errors &gt; 0;&#010;+    }&#010;+&#010;+    public int getNumberOfErrors() {&#010;+        return errors;&#010;+    }&#010;+&#010;+    public boolean isSuccess() {&#010;+        boolean ok = syntaxError == null &amp;&amp; unknownComponent == null &amp;&amp; incapable == null&#010;+                &amp;&amp; unknown == null &amp;&amp; required == null;&#010;+        if (ok) {&#010;+            ok = notConsumerOnly == null &amp;&amp; notProducerOnly == null;&#010;+        }&#010;+        if (ok) {&#010;+            ok = invalidEnum == null &amp;&amp; invalidEnumChoices == null &amp;&amp; invalidReference == null&#010;+                &amp;&amp; invalidBoolean == null &amp;&amp; invalidInteger == null &amp;&amp; invalidNumber == null;&#010;+        }&#010;+        return ok;&#010;+    }&#010;+&#010;+    public void addSyntaxError(String syntaxError) {&#010;+        this.syntaxError = syntaxError;&#010;+        errors++;&#010;+    }&#010;+&#010;+    public void addIncapable(String uri) {&#010;+        this.incapable = uri;&#010;+        errors++;&#010;+    }&#010;+&#010;+    public void addUnknownComponent(String name) {&#010;+        this.unknownComponent = name;&#010;+        errors++;&#010;+    }&#010;+&#010;+    public void addUnknown(String name) {&#010;+        if (unknown == null) {&#010;+            unknown = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!unknown.contains(name)) {&#010;+            unknown.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addUnknownSuggestions(String name, String[] suggestions) {&#010;+        if (unknownSuggestions == null) {&#010;+            unknownSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;+        }&#010;+        unknownSuggestions.put(name, suggestions);&#010;+    }&#010;+&#010;+    public void addLenient(String name) {&#010;+        if (lenient == null) {&#010;+            lenient = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!lenient.contains(name)) {&#010;+            lenient.add(name);&#010;+        }&#010;+    }&#010;+&#010;+    public void addRequired(String name) {&#010;+        if (required == null) {&#010;+            required = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!required.contains(name)) {&#010;+            required.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidEnum(String name, String value) {&#010;+        if (invalidEnum == null) {&#010;+            invalidEnum = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidEnum.containsKey(name)) {&#010;+            invalidEnum.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidEnumChoices(String name, String[] choices) {&#010;+        if (invalidEnumChoices == null) {&#010;+            invalidEnumChoices = new LinkedHashMap&lt;String, String[]&gt;();&#010;+        }&#010;+        invalidEnumChoices.put(name, choices);&#010;+    }&#010;+&#010;+    public void addInvalidEnumSuggestions(String name, String[] suggestions) {&#010;+        if (invalidEnumSuggestions == null) {&#010;+            invalidEnumSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;+        }&#010;+        invalidEnumSuggestions.put(name, suggestions);&#010;+    }&#010;+&#010;+    public void addInvalidReference(String name, String value) {&#010;+        if (invalidReference == null) {&#010;+            invalidReference = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidReference.containsKey(name)) {&#010;+            invalidReference.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidBoolean(String name, String value) {&#010;+        if (invalidBoolean == null) {&#010;+            invalidBoolean = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidBoolean.containsKey(name)) {&#010;+            invalidBoolean.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidInteger(String name, String value) {&#010;+        if (invalidInteger == null) {&#010;+            invalidInteger = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidInteger.containsKey(name)) {&#010;+            invalidInteger.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidNumber(String name, String value) {&#010;+        if (invalidNumber == null) {&#010;+            invalidNumber = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidNumber.containsKey(name)) {&#010;+            invalidNumber.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addDefaultValue(String name, String value)  {&#010;+        if (defaultValues == null) {&#010;+            defaultValues = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        defaultValues.put(name, value);&#010;+    }&#010;+&#010;+    public void addNotConsumerOnly(String name) {&#010;+        if (notConsumerOnly == null) {&#010;+            notConsumerOnly = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!notConsumerOnly.contains(name)) {&#010;+            notConsumerOnly.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addNotProducerOnly(String name) {&#010;+        if (notProducerOnly == null) {&#010;+            notProducerOnly = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!notProducerOnly.contains(name)) {&#010;+            notProducerOnly.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public String getSyntaxError() {&#010;+        return syntaxError;&#010;+    }&#010;+&#010;+    public String getIncapable() {&#010;+        return incapable;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getUnknown() {&#010;+        return unknown;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getLenient() {&#010;+        return lenient;&#010;+    }&#010;+&#010;+    public Map&lt;String, String[]&gt; getUnknownSuggestions() {&#010;+        return unknownSuggestions;&#010;+    }&#010;+&#010;+    public String getUnknownComponent() {&#010;+        return unknownComponent;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getRequired() {&#010;+        return required;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidEnum() {&#010;+        return invalidEnum;&#010;+    }&#010;+&#010;+    public Map&lt;String, String[]&gt; getInvalidEnumChoices() {&#010;+        return invalidEnumChoices;&#010;+    }&#010;+&#010;+    public List&lt;String&gt; getEnumChoices(String optionName) {&#010;+        if (invalidEnumChoices != null) {&#010;+            String[] enums = invalidEnumChoices.get(optionName);&#010;+            if (enums != null) {&#010;+                return Arrays.asList(enums);&#010;+            }&#010;+        }&#010;+&#010;+        return Collections.emptyList();&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidReference() {&#010;+        return invalidReference;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidBoolean() {&#010;+        return invalidBoolean;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidInteger() {&#010;+        return invalidInteger;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidNumber() {&#010;+        return invalidNumber;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getDefaultValues() {&#010;+        return defaultValues;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getNotConsumerOnly() {&#010;+        return notConsumerOnly;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getNotProducerOnly() {&#010;+        return notProducerOnly;&#010;+    }&#010;+&#010;+    /**&#010;+     * A human readable summary of the validation errors.&#010;+     *&#010;+     * @param includeHeader whether to include a header&#010;+     * @return the summary, or &lt;tt&gt;null&lt;/tt&gt; if no validation errors&#010;+     */&#010;+    public String summaryErrorMessage(boolean includeHeader) {&#010;+        if (isSuccess()) {&#010;+            return null;&#010;+        }&#010;+&#010;+        if (incapable != null) {&#010;+            return ""\tIncapable of parsing uri: "" + incapable;&#010;+        } else if (syntaxError != null) {&#010;+            return ""\tSyntax error: "" + syntaxError;&#010;+        } else if (unknownComponent != null) {&#010;+            return ""\tUnknown component: "" + unknownComponent;&#010;+        }&#010;+&#010;+        // for each invalid option build a reason message&#010;+        Map&lt;String, String&gt; options = new LinkedHashMap&lt;String, String&gt;();&#010;+        if (unknown != null) {&#010;+            for (String name : unknown) {&#010;+                if (unknownSuggestions != null &amp;&amp; unknownSuggestions.containsKey(name)) {&#010;+                    String[] suggestions = unknownSuggestions.get(name);&#010;+                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;+                        String str = Arrays.asList(suggestions).toString();&#010;+                        options.put(name, ""Unknown option. Did you mean: "" + str);&#010;+                    } else {&#010;+                        options.put(name, ""Unknown option"");&#010;+                    }&#010;+                } else {&#010;+                    options.put(name, ""Unknown option"");&#010;+                }&#010;+            }&#010;+        }&#010;+        if (notConsumerOnly != null) {&#010;+            for (String name : notConsumerOnly) {&#010;+                options.put(name, ""Option not applicable in consumer only mode"");&#010;+            }&#010;+        }&#010;+        if (notProducerOnly != null) {&#010;+            for (String name : notProducerOnly) {&#010;+                options.put(name, ""Option not applicable in producer only mode"");&#010;+            }&#010;+        }&#010;+        if (required != null) {&#010;+            for (String name : required) {&#010;+                options.put(name, ""Missing required option"");&#010;+            }&#010;+        }&#010;+        if (invalidEnum != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidEnum.entrySet()) {&#010;+                String name = entry.getKey();&#010;+                String[] choices = invalidEnumChoices.get(name);&#010;+                String defaultValue = defaultValues != null ? defaultValues.get(entry.getKey()) : null;&#010;+                String str = Arrays.asList(choices).toString();&#010;+                String msg = ""Invalid enum value: "" + entry.getValue() + "". Possible values: "" + str;&#010;+                if (invalidEnumSuggestions != null) {&#010;+                    String[] suggestions = invalidEnumSuggestions.get(name);&#010;+                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;+                        str = Arrays.asList(suggestions).toString();&#010;+                        msg += "". Did you mean: "" + str;&#010;+                    }&#010;+                }&#010;+                if (defaultValue != null) {&#010;+                    msg += "". Default value: "" + defaultValue;&#010;+                }&#010;+&#010;+                options.put(entry.getKey(), msg);&#010;+            }&#010;+        }&#010;+        if (invalidReference != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidReference.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty reference value"");&#010;+                } else if (!entry.getValue().startsWith(""#"")) {&#010;+                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue() + "" must start with #"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+        if (invalidBoolean != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidBoolean.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty boolean value"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid boolean value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+        if (invalidInteger != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidInteger.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty integer value"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid integer value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+        if (invalidNumber != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidNumber.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty number value"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid number value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // build a table with the error summary nicely formatted&#010;+        // lets use 24 as min length&#010;+        int maxLen = 24;&#010;+        for (String key : options.keySet()) {&#010;+            maxLen = Math.max(maxLen, key.length());&#010;+        }&#010;+        String format = ""%"" + maxLen + ""s    %s"";&#010;+&#010;+        // build the human error summary&#010;+        StringBuilder sb = new StringBuilder();&#010;+        if (includeHeader) {&#010;+            sb.append(""Endpoint validator error\n"");&#010;+            sb.append(""---------------------------------------------------------------------------------------------------------------------------------------\n"");&#010;+            sb.append(""\n"");&#010;+        }&#010;+        if (uri != null) {&#010;+            sb.append(""\t"").append(uri).append(""\n"");&#010;+        } else {&#010;+            sb.append(""\n"");&#010;+        }&#010;+        for (Map.Entry&lt;String, String&gt; option : options.entrySet()) {&#010;+            String out = String.format(format, option.getKey(), option.getValue());&#010;+            sb.append(""\n\t"").append(out);&#010;+        }&#010;+&#010;+        return sb.toString();&#010;+    }&#010;+}&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C0ffd278dae9f48d5849d5bd0dc60655f%40git.apache.org%3E,2017-04-14 10:52,commits,2.0,325.0,  [4/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
5,326.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java b/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&#010;deleted file mode 100644&#010;index 9bb98f0..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&#010;+++ /dev/null&#010;@@ -1,451 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.io.Serializable;&#010;-import java.util.Arrays;&#010;-import java.util.Collections;&#010;-import java.util.LinkedHashMap;&#010;-import java.util.LinkedHashSet;&#010;-import java.util.List;&#010;-import java.util.Map;&#010;-import java.util.Set;&#010;-&#010;-import static org.apache.camel.catalog.URISupport.isEmpty;&#010;-&#010;-/**&#010;- * Details result of validating endpoint uri.&#010;- */&#010;-public class EndpointValidationResult implements Serializable {&#010;-&#010;-    private final String uri;&#010;-    private int errors;&#010;-&#010;-    // general&#010;-    private String syntaxError;&#010;-    private String unknownComponent;&#010;-    private String incapable;&#010;-&#010;-    // options&#010;-    private Set&lt;String&gt; unknown;&#010;-    private Map&lt;String, String[]&gt; unknownSuggestions;&#010;-    private Set&lt;String&gt; lenient;&#010;-    private Set&lt;String&gt; notConsumerOnly;&#010;-    private Set&lt;String&gt; notProducerOnly;&#010;-    private Set&lt;String&gt; required;&#010;-    private Map&lt;String, String&gt; invalidEnum;&#010;-    private Map&lt;String, String[]&gt; invalidEnumChoices;&#010;-    private Map&lt;String, String[]&gt; invalidEnumSuggestions;&#010;-    private Map&lt;String, String&gt; invalidReference;&#010;-    private Map&lt;String, String&gt; invalidBoolean;&#010;-    private Map&lt;String, String&gt; invalidInteger;&#010;-    private Map&lt;String, String&gt; invalidNumber;&#010;-    private Map&lt;String, String&gt; defaultValues;&#010;-&#010;-    public EndpointValidationResult() {&#010;-        this(null);&#010;-    }&#010;-&#010;-    public EndpointValidationResult(String uri) {&#010;-        this.uri = uri;&#010;-    }&#010;-&#010;-    public String getUri() {&#010;-        return uri;&#010;-    }&#010;-&#010;-    public boolean hasErrors() {&#010;-        return errors &gt; 0;&#010;-    }&#010;-&#010;-    public int getNumberOfErrors() {&#010;-        return errors;&#010;-    }&#010;-&#010;-    public boolean isSuccess() {&#010;-        boolean ok = syntaxError == null &amp;&amp; unknownComponent == null &amp;&amp; incapable == null&#010;-                &amp;&amp; unknown == null &amp;&amp; required == null;&#010;-        if (ok) {&#010;-            ok = notConsumerOnly == null &amp;&amp; notProducerOnly == null;&#010;-        }&#010;-        if (ok) {&#010;-            ok = invalidEnum == null &amp;&amp; invalidEnumChoices == null &amp;&amp; invalidReference == null&#010;-                &amp;&amp; invalidBoolean == null &amp;&amp; invalidInteger == null &amp;&amp; invalidNumber == null;&#010;-        }&#010;-        return ok;&#010;-    }&#010;-&#010;-    public void addSyntaxError(String syntaxError) {&#010;-        this.syntaxError = syntaxError;&#010;-        errors++;&#010;-    }&#010;-&#010;-    public void addIncapable(String uri) {&#010;-        this.incapable = uri;&#010;-        errors++;&#010;-    }&#010;-&#010;-    public void addUnknownComponent(String name) {&#010;-        this.unknownComponent = name;&#010;-        errors++;&#010;-    }&#010;-&#010;-    public void addUnknown(String name) {&#010;-        if (unknown == null) {&#010;-            unknown = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!unknown.contains(name)) {&#010;-            unknown.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addUnknownSuggestions(String name, String[] suggestions) {&#010;-        if (unknownSuggestions == null) {&#010;-            unknownSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;-        }&#010;-        unknownSuggestions.put(name, suggestions);&#010;-    }&#010;-&#010;-    public void addLenient(String name) {&#010;-        if (lenient == null) {&#010;-            lenient = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!lenient.contains(name)) {&#010;-            lenient.add(name);&#010;-        }&#010;-    }&#010;-&#010;-    public void addRequired(String name) {&#010;-        if (required == null) {&#010;-            required = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!required.contains(name)) {&#010;-            required.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidEnum(String name, String value) {&#010;-        if (invalidEnum == null) {&#010;-            invalidEnum = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidEnum.containsKey(name)) {&#010;-            invalidEnum.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidEnumChoices(String name, String[] choices) {&#010;-        if (invalidEnumChoices == null) {&#010;-            invalidEnumChoices = new LinkedHashMap&lt;String, String[]&gt;();&#010;-        }&#010;-        invalidEnumChoices.put(name, choices);&#010;-    }&#010;-&#010;-    public void addInvalidEnumSuggestions(String name, String[] suggestions) {&#010;-        if (invalidEnumSuggestions == null) {&#010;-            invalidEnumSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;-        }&#010;-        invalidEnumSuggestions.put(name, suggestions);&#010;-    }&#010;-&#010;-    public void addInvalidReference(String name, String value) {&#010;-        if (invalidReference == null) {&#010;-            invalidReference = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidReference.containsKey(name)) {&#010;-            invalidReference.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidBoolean(String name, String value) {&#010;-        if (invalidBoolean == null) {&#010;-            invalidBoolean = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidBoolean.containsKey(name)) {&#010;-            invalidBoolean.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidInteger(String name, String value) {&#010;-        if (invalidInteger == null) {&#010;-            invalidInteger = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidInteger.containsKey(name)) {&#010;-            invalidInteger.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidNumber(String name, String value) {&#010;-        if (invalidNumber == null) {&#010;-            invalidNumber = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidNumber.containsKey(name)) {&#010;-            invalidNumber.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addDefaultValue(String name, String value)  {&#010;-        if (defaultValues == null) {&#010;-            defaultValues = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        defaultValues.put(name, value);&#010;-    }&#010;-&#010;-    public void addNotConsumerOnly(String name) {&#010;-        if (notConsumerOnly == null) {&#010;-            notConsumerOnly = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!notConsumerOnly.contains(name)) {&#010;-            notConsumerOnly.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addNotProducerOnly(String name) {&#010;-        if (notProducerOnly == null) {&#010;-            notProducerOnly = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!notProducerOnly.contains(name)) {&#010;-            notProducerOnly.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public String getSyntaxError() {&#010;-        return syntaxError;&#010;-    }&#010;-&#010;-    public String getIncapable() {&#010;-        return incapable;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getUnknown() {&#010;-        return unknown;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getLenient() {&#010;-        return lenient;&#010;-    }&#010;-&#010;-    public Map&lt;String, String[]&gt; getUnknownSuggestions() {&#010;-        return unknownSuggestions;&#010;-    }&#010;-&#010;-    public String getUnknownComponent() {&#010;-        return unknownComponent;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getRequired() {&#010;-        return required;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidEnum() {&#010;-        return invalidEnum;&#010;-    }&#010;-&#010;-    public Map&lt;String, String[]&gt; getInvalidEnumChoices() {&#010;-        return invalidEnumChoices;&#010;-    }&#010;-&#010;-    public List&lt;String&gt; getEnumChoices(String optionName) {&#010;-        if (invalidEnumChoices != null) {&#010;-            String[] enums = invalidEnumChoices.get(optionName);&#010;-            if (enums != null) {&#010;-                return Arrays.asList(enums);&#010;-            }&#010;-        }&#010;-&#010;-        return Collections.emptyList();&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidReference() {&#010;-        return invalidReference;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidBoolean() {&#010;-        return invalidBoolean;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidInteger() {&#010;-        return invalidInteger;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidNumber() {&#010;-        return invalidNumber;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getDefaultValues() {&#010;-        return defaultValues;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getNotConsumerOnly() {&#010;-        return notConsumerOnly;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getNotProducerOnly() {&#010;-        return notProducerOnly;&#010;-    }&#010;-&#010;-    /**&#010;-     * A human readable summary of the validation errors.&#010;-     *&#010;-     * @param includeHeader whether to include a header&#010;-     * @return the summary, or &lt;tt&gt;null&lt;/tt&gt; if no validation errors&#010;-     */&#010;-    public String summaryErrorMessage(boolean includeHeader) {&#010;-        if (isSuccess()) {&#010;-            return null;&#010;-        }&#010;-&#010;-        if (incapable != null) {&#010;-            return ""\tIncapable of parsing uri: "" + incapable;&#010;-        } else if (syntaxError != null) {&#010;-            return ""\tSyntax error: "" + syntaxError;&#010;-        } else if (unknownComponent != null) {&#010;-            return ""\tUnknown component: "" + unknownComponent;&#010;-        }&#010;-&#010;-        // for each invalid option build a reason message&#010;-        Map&lt;String, String&gt; options = new LinkedHashMap&lt;String, String&gt;();&#010;-        if (unknown != null) {&#010;-            for (String name : unknown) {&#010;-                if (unknownSuggestions != null &amp;&amp; unknownSuggestions.containsKey(name)) {&#010;-                    String[] suggestions = unknownSuggestions.get(name);&#010;-                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;-                        String str = Arrays.asList(suggestions).toString();&#010;-                        options.put(name, ""Unknown option. Did you mean: "" + str);&#010;-                    } else {&#010;-                        options.put(name, ""Unknown option"");&#010;-                    }&#010;-                } else {&#010;-                    options.put(name, ""Unknown option"");&#010;-                }&#010;-            }&#010;-        }&#010;-        if (notConsumerOnly != null) {&#010;-            for (String name : notConsumerOnly) {&#010;-                options.put(name, ""Option not applicable in consumer only mode"");&#010;-            }&#010;-        }&#010;-        if (notProducerOnly != null) {&#010;-            for (String name : notProducerOnly) {&#010;-                options.put(name, ""Option not applicable in producer only mode"");&#010;-            }&#010;-        }&#010;-        if (required != null) {&#010;-            for (String name : required) {&#010;-                options.put(name, ""Missing required option"");&#010;-            }&#010;-        }&#010;-        if (invalidEnum != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidEnum.entrySet()) {&#010;-                String name = entry.getKey();&#010;-                String[] choices = invalidEnumChoices.get(name);&#010;-                String defaultValue = defaultValues != null ? defaultValues.get(entry.getKey()) : null;&#010;-                String str = Arrays.asList(choices).toString();&#010;-                String msg = ""Invalid enum value: "" + entry.getValue() + "". Possible values: "" + str;&#010;-                if (invalidEnumSuggestions != null) {&#010;-                    String[] suggestions = invalidEnumSuggestions.get(name);&#010;-                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;-                        str = Arrays.asList(suggestions).toString();&#010;-                        msg += "". Did you mean: "" + str;&#010;-                    }&#010;-                }&#010;-                if (defaultValue != null) {&#010;-                    msg += "". Default value: "" + defaultValue;&#010;-                }&#010;-&#010;-                options.put(entry.getKey(), msg);&#010;-            }&#010;-        }&#010;-        if (invalidReference != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidReference.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty reference value"");&#010;-                } else if (!entry.getValue().startsWith(""#"")) {&#010;-                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue() + "" must start with #"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-        if (invalidBoolean != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidBoolean.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty boolean value"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid boolean value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-        if (invalidInteger != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidInteger.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty integer value"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid integer value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-        if (invalidNumber != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidNumber.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty number value"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid number value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-&#010;-        // build a table with the error summary nicely formatted&#010;-        // lets use 24 as min length&#010;-        int maxLen = 24;&#010;-        for (String key : options.keySet()) {&#010;-            maxLen = Math.max(maxLen, key.length());&#010;-        }&#010;-        String format = ""%"" + maxLen + ""s    %s"";&#010;-&#010;-        // build the human error summary&#010;-        StringBuilder sb = new StringBuilder();&#010;-        if (includeHeader) {&#010;-            sb.append(""Endpoint validator error\n"");&#010;-            sb.append(""---------------------------------------------------------------------------------------------------------------------------------------\n"");&#010;-            sb.append(""\n"");&#010;-        }&#010;-        if (uri != null) {&#010;-            sb.append(""\t"").append(uri).append(""\n"");&#010;-        } else {&#010;-            sb.append(""\n"");&#010;-        }&#010;-        for (Map.Entry&lt;String, String&gt; option : options.entrySet()) {&#010;-            String out = String.format(format, option.getKey(), option.getValue());&#010;-            sb.append(""\n\t"").append(out);&#010;-        }&#010;-&#010;-        return sb.toString();&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java b/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&#010;deleted file mode 100644&#010;index 774facd..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&#010;+++ /dev/null&#010;@@ -1,424 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.ArrayList;&#010;-import java.util.LinkedHashMap;&#010;-import java.util.LinkedHashSet;&#010;-import java.util.List;&#010;-import java.util.Map;&#010;-import java.util.Set;&#010;-import java.util.regex.Matcher;&#010;-import java.util.regex.Pattern;&#010;-&#010;-public final class JSonSchemaHelper {&#010;-&#010;-    // 0 = text, 1 = enum, 2 = boolean, 3 = integer or number&#010;-    private static final Pattern PATTERN = Pattern.compile(""\""(.+?)\""|\\[(.+)\\]|(true|false)|(-?\\d+\\.?\\d*)"");&#010;-    private static final String QUOT = ""&amp;quot;"";&#010;-&#010;-    private JSonSchemaHelper() {&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the json schema to split it into a list or rows, where each row contains key value pairs with the metadata&#010;-     *&#010;-     * @param group the group to parse from such as &lt;tt&gt;component&lt;/tt&gt;, &lt;tt&gt;componentProperties&lt;/tt&gt;, or &lt;tt&gt;properties&lt;/tt&gt;.&#010;-     * @param json the json&#010;-     * @return a list of all the rows, where each row is a set of key value pairs with metadata&#010;-     */&#010;-    public static List&lt;Map&lt;String, String&gt;&gt; parseJsonSchema(String group, String json, boolean parseProperties) {&#010;-        List&lt;Map&lt;String, String&gt;&gt; answer = new ArrayList&lt;Map&lt;String, String&gt;&gt;();&#010;-        if (json == null) {&#010;-            return answer;&#010;-        }&#010;-&#010;-        boolean found = false;&#010;-&#010;-        // parse line by line&#010;-        String[] lines = json.split(""\n"");&#010;-        for (String line : lines) {&#010;-            // we need to find the group first&#010;-            if (!found) {&#010;-                String s = line.trim();&#010;-                found = s.startsWith(""\"""" + group + ""\"":"") &amp;&amp; s.endsWith(""{"");&#010;-                continue;&#010;-            }&#010;-&#010;-            // we should stop when we end the group&#010;-            if (line.equals(""  },"") || line.equals(""  }"")) {&#010;-                break;&#010;-            }&#010;-&#010;-            // need to safe encode \"" so we can parse the line&#010;-            line = line.replaceAll(""\""\\\\\""\"""", '""' + QUOT + '""');&#010;-&#010;-            Map&lt;String, String&gt; row = new LinkedHashMap&lt;String, String&gt;();&#010;-            Matcher matcher = PATTERN.matcher(line);&#010;-&#010;-            String key;&#010;-            if (parseProperties) {&#010;-                // when parsing properties the first key is given as name, so the first parsed token is the value of the name&#010;-                key = ""name"";&#010;-            } else {&#010;-                key = null;&#010;-            }&#010;-            while (matcher.find()) {&#010;-                if (key == null) {&#010;-                    key = matcher.group(1);&#010;-                } else {&#010;-                    String value = matcher.group(1);&#010;-                    if (value != null) {&#010;-                        // its text based&#010;-                        value = value.trim();&#010;-                        // decode&#010;-                        value = value.replaceAll(QUOT, ""\"""");&#010;-                        value = decodeJson(value);&#010;-                    }&#010;-                    if (value == null) {&#010;-                        // not text then its maybe an enum?&#010;-                        value = matcher.group(2);&#010;-                        if (value != null) {&#010;-                            // its an enum so strip out "" and trim spaces after comma&#010;-                            value = value.replaceAll(""\"""", """");&#010;-                            value = value.replaceAll("", "", "","");&#010;-                            value = value.trim();&#010;-                        }&#010;-                    }&#010;-                    if (value == null) {&#010;-                        // not text then its maybe a boolean?&#010;-                        value = matcher.group(3);&#010;-                    }&#010;-                    if (value == null) {&#010;-                        // not text then its maybe a integer?&#010;-                        value = matcher.group(4);&#010;-                    }&#010;-                    if (value != null) {&#010;-                        row.put(key, value);&#010;-                    }&#010;-                    // reset&#010;-                    key = null;&#010;-                }&#010;-            }&#010;-            if (!row.isEmpty()) {&#010;-                answer.add(row);&#010;-            }&#010;-        }&#010;-&#010;-        return answer;&#010;-    }&#010;-&#010;-    private static String decodeJson(String value) {&#010;-        // json encodes a \ as \\ so we need to decode from \\ back to \&#010;-        if (""\\\\"".equals(value)) {&#010;-            value = ""\\"";&#010;-        }&#010;-        return value;&#010;-    }&#010;-&#010;-    public static boolean isComponentLenientProperties(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""lenientProperties"")) {&#010;-                return ""true"".equals(row.get(""lenientProperties""));&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isComponentConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""consumerOnly"")) {&#010;-                return ""true"".equals(row.get(""consumerOnly""));&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isComponentProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""producerOnly"")) {&#010;-                return ""true"".equals(row.get(""producerOnly""));&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String labels = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""label"")) {&#010;-                labels = row.get(""label"");&#010;-            }&#010;-            if (found) {&#010;-                return labels != null &amp;&amp; labels.contains(""consumer"");&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String labels = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""label"")) {&#010;-                labels = row.get(""label"");&#010;-            }&#010;-            if (found) {&#010;-                return labels != null &amp;&amp; labels.contains(""producer"");&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyRequired(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            boolean required = false;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""required"")) {&#010;-                required = ""true"".equals(row.get(""required""));&#010;-            }&#010;-            if (found) {&#010;-                return required;&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static String getPropertyKind(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String kind = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""kind"")) {&#010;-                kind = row.get(""kind"");&#010;-            }&#010;-            if (found) {&#010;-                return kind;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static boolean isPropertyBoolean(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""boolean"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyInteger(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""integer"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyNumber(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""number"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyObject(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""object"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static String getPropertyDefaultValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String defaultValue = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""defaultValue"")) {&#010;-                defaultValue = row.get(""defaultValue"");&#010;-            }&#010;-            if (found) {&#010;-                return defaultValue;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static String stripOptionalPrefixFromName(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String optionalPrefix = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""optionalPrefix"")) {&#010;-                optionalPrefix = row.get(""optionalPrefix"");&#010;-            }&#010;-            if (row.containsKey(""name"")) {&#010;-                if (optionalPrefix != null &amp;&amp; name.startsWith(optionalPrefix)) {&#010;-                    name = name.substring(optionalPrefix.length());&#010;-                    // try again&#010;-                    return stripOptionalPrefixFromName(rows, name);&#010;-                } else {&#010;-                    found = name.equals(row.get(""name""));&#010;-                }&#010;-            }&#010;-            if (found) {&#010;-                return name;&#010;-            }&#010;-        }&#010;-        return name;&#010;-    }&#010;-&#010;-    public static String getPropertyEnum(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String enums = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""enum"")) {&#010;-                enums = row.get(""enum"");&#010;-            }&#010;-            if (found) {&#010;-                return enums;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static String getPropertyPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String prefix = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""prefix"")) {&#010;-                prefix = row.get(""prefix"");&#010;-            }&#010;-            if (found) {&#010;-                return prefix;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static boolean isPropertyMultiValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            boolean multiValue = false;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""multiValue"")) {&#010;-                multiValue = ""true"".equals(row.get(""multiValue""));&#010;-            }&#010;-            if (found) {&#010;-                return multiValue;&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static String getPropertyNameFromNameWithPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String propertyName = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                propertyName = row.get(""name"");&#010;-            }&#010;-            if (row.containsKey(""prefix"")) {&#010;-                String preifx = row.get(""prefix"");&#010;-                found = name.startsWith(preifx);&#010;-            }&#010;-            if (found) {&#010;-                return propertyName;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static Map&lt;String, String&gt; getRow(List&lt;Map&lt;String, String&gt;&gt; rows, String key) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (key.equals(row.get(""name""))) {&#010;-                return row;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static Set&lt;String&gt; getNames(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        Set&lt;String&gt; answer = new LinkedHashSet&lt;String&gt;();&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""name"")) {&#010;-                answer.add(row.get(""name""));&#010;-            }&#010;-        }&#010;-        return answer;&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java b/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&#010;deleted file mode 100644&#010;index 9bf09cc..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&#010;+++ /dev/null&#010;@@ -1,64 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-/**&#010;- * Pluggable resolver to load JSon schema files for components, data formats, languages etc.&#010;- */&#010;-public interface JSonSchemaResolver {&#010;-&#010;-    /**&#010;-     * Returns the component information as JSon format.&#010;-     *&#010;-     * @param name the component name&#010;-     * @return component details in JSon&#010;-     */&#010;-    String getComponentJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the data format information as JSon format.&#010;-     *&#010;-     * @param name the data format name&#010;-     * @return data format details in JSon&#010;-     */&#010;-    String getDataFormatJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the language information as JSon format.&#010;-     *&#010;-     * @param name the language name&#010;-     * @return language details in JSon&#010;-     */&#010;-    String getLanguageJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the other (miscellaneous) information as JSon format.&#010;-     *&#010;-     * @param name the other (miscellaneous) name&#010;-     * @return other (miscellaneous) details in JSon&#010;-     */&#010;-    String getOtherJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the model information as JSon format.&#010;-     *&#010;-     * @param name the model name&#010;-     * @return model details in JSon&#010;-     */&#010;-    String getModelJSonSchema(String name);&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java b/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&#010;deleted file mode 100644&#010;index 4a977eb..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&#010;+++ /dev/null&#010;@@ -1,65 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.io.Serializable;&#010;-&#010;-/**&#010;- * Validation result of parsing a language expression or predicate&#010;- */&#010;-public class LanguageValidationResult implements Serializable {&#010;-    private final String text;&#010;-    private String error;&#010;-    private String shortError;&#010;-    private int index;&#010;-&#010;-    public LanguageValidationResult(String text) {&#010;-        this.text = text;&#010;-    }&#010;-&#010;-    public String getText() {&#010;-        return text;&#010;-    }&#010;-&#010;-    public boolean isSuccess() {&#010;-        return error == null;&#010;-    }&#010;-&#010;-    public void setError(String error) {&#010;-        this.error = error;&#010;-    }&#010;-&#010;-    public String getError() {&#010;-        return error;&#010;-    }&#010;-&#010;-    public String getShortError() {&#010;-        return shortError;&#010;-    }&#010;-&#010;-    public void setShortError(String shortError) {&#010;-        this.shortError = shortError;&#010;-    }&#010;-&#010;-    public int getIndex() {&#010;-        return index;&#010;-    }&#010;-&#010;-    public void setIndex(int index) {&#010;-        this.index = index;&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java&#010;deleted file mode 100644&#010;index b46edab..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java&#010;+++ /dev/null&#010;@@ -1,234 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.net.URISyntaxException;&#010;-import java.util.Map;&#010;-&#010;-import org.apache.camel.StaticService;&#010;-&#010;-/**&#010;- * Runtime based CamelCatalog which are included in camel-core that can provided limit CamelCatalog capabilities&#010;- */&#010;-public interface RuntimeCamelCatalog extends StaticService {&#010;-&#010;-    /**&#010;-     * Returns the component information as JSon format.&#010;-     *&#010;-     * @param name the component name&#010;-     * @return component details in JSon&#010;-     */&#010;-    String componentJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the data format information as JSon format.&#010;-     *&#010;-     * @param name the data format name&#010;-     * @return data format details in JSon&#010;-     */&#010;-    String dataFormatJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the language information as JSon format.&#010;-     *&#010;-     * @param name the language name&#010;-     * @return language details in JSon&#010;-     */&#010;-    String languageJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the model information as JSon format.&#010;-     *&#010;-     * @param name the model name&#010;-     * @return model details in JSon&#010;-     */&#010;-    String modelJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Parses the endpoint uri and constructs a key/value properties of each option&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return properties as key value pairs of each endpoint option&#010;-     */&#010;-    Map&lt;String, String&gt; endpointProperties(String uri) throws URISyntaxException;&#010;-&#010;-    /**&#010;-     * Parses the endpoint uri and constructs a key/value properties of only the lenient properties (eg custom options)&#010;-     * &lt;p/&gt;&#010;-     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return properties as key value pairs of each lenient properties&#010;-     */&#010;-    Map&lt;String, String&gt; endpointLenientProperties(String uri) throws URISyntaxException;&#010;-&#010;-    /**&#010;-     * Validates the pattern whether its a valid time pattern.&#010;-     *&#010;-     * @param pattern  the pattern such as 5000, 5s, 5sec, 4min, 4m30s, 1h, etc.&#010;-     * @return &lt;tt&gt;true&lt;/tt&gt; if valid, &lt;tt&gt;false&lt;/tt&gt; if invalid&#010;-     */&#010;-    boolean validateTimePattern(String pattern);&#010;-&#010;-    /**&#010;-     * Validates the properties for the given scheme against component and endpoint&#010;-     *&#010;-     * @param scheme  the endpoint scheme&#010;-     * @param properties  the endpoint properties&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateProperties(String scheme, Map&lt;String, String&gt; properties);&#010;-&#010;-    /**&#010;-     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateEndpointProperties(String uri);&#010;-&#010;-    /**&#010;-     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;-     * &lt;p/&gt;&#010;-     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;-     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;-     * but in the uri because of using lenient properties.&#010;-     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties);&#010;-&#010;-    /**&#010;-     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;-     * &lt;p/&gt;&#010;-     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;-     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;-     * but in the uri because of using lenient properties.&#010;-     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;-     * @param consumerOnly whether the endpoint is only used as a consumer&#010;-     * @param producerOnly whether the endpoint is only used as a producer&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties, boolean consumerOnly, boolean producerOnly);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple expression.&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param simple  the simple expression&#010;-     * @return validation result&#010;-     * @deprecated use {@link #validateSimpleExpression(ClassLoader, String)}&#010;-     */&#010;-    @Deprecated&#010;-    SimpleValidationResult validateSimpleExpression(String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple expression.&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param simple  the simple expression&#010;-     * @return validation result&#010;-     */&#010;-    SimpleValidationResult validateSimpleExpression(ClassLoader classLoader, String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple predicate&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param simple  the simple predicate&#010;-     * @return validation result&#010;-     * @deprecated use {@link #validateSimplePredicate(ClassLoader, String)}&#010;-     */&#010;-    @Deprecated&#010;-    SimpleValidationResult validateSimplePredicate(String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple predicate&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param simple  the simple predicate&#010;-     * @return validation result&#010;-     */&#010;-    SimpleValidationResult validateSimplePredicate(ClassLoader classLoader, String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the language as a predicate&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param language the name of the language&#010;-     * @param text  the predicate text&#010;-     * @return validation result&#010;-     */&#010;-    LanguageValidationResult validateLanguagePredicate(ClassLoader classLoader, String language, String text);&#010;-&#010;-    /**&#010;-     * Parses and validates the language as an expression&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param language the name of the language&#010;-     * @param text  the expression text&#010;-     * @return validation result&#010;-     */&#010;-    LanguageValidationResult validateLanguageExpression(ClassLoader classLoader, String language, String text);&#010;-&#010;-    /**&#010;-     * Returns the component name from the given endpoint uri&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return the component name (aka scheme), or &lt;tt&gt;null&lt;/tt&gt; if not possible to determine&#010;-     */&#010;-    String endpointComponentName(String uri);&#010;-&#010;-    /**&#010;-     * Creates an endpoint uri in Java style from the information from the properties&#010;-     *&#010;-     * @param scheme the endpoint schema&#010;-     * @param properties the properties as key value pairs&#010;-     * @param encode whether to URL encode the returned uri or not&#010;-     * @return the constructed endpoint uri&#010;-     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;-     */&#010;-    String asEndpointUri(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;-&#010;-    /**&#010;-     * Creates an endpoint uri in XML style (eg escape &amp; as &amp;ampl;) from the information from the properties&#010;-     *&#010;-     * @param scheme the endpoint schema&#010;-     * @param properties the properties as key value pairs&#010;-     * @param encode whether to URL encode the returned uri or not&#010;-     * @return the constructed endpoint uri&#010;-     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;-     */&#010;-    String asEndpointUriXml(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java b/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&#010;deleted file mode 100644&#010;index 5c86f23..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&#010;+++ /dev/null&#010;@@ -1,32 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-/**&#010;- * To be backwards compatible, but favor using {@link LanguageValidationResult} instead.&#010;- */&#010;-public class SimpleValidationResult extends LanguageValidationResult {&#010;-&#010;-    public SimpleValidationResult(String text) {&#010;-        super(text);&#010;-    }&#010;-&#010;-    public String getSimple() {&#010;-        return getText();&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java b/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&#010;deleted file mode 100644&#010;index 057d372..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&#010;+++ /dev/null&#010;@@ -1,34 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.Set;&#010;-&#010;-/**&#010;- * Strategy to provide suggestions for unknown endpoint options&#010;- */&#010;-public interface SuggestionStrategy {&#010;-&#010;-    /**&#010;-     * Provides a list of valid option names for a did you mean function.&#010;-     *&#010;-     * @param names         valid names&#010;-     * @param unknownOption unknown option name&#010;-     * @return a list of suggested names (did you mean)&#010;-     */&#010;-    String[] suggestEndpointOptions(Set&lt;String&gt; names, String unknownOption);&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java b/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&#010;deleted file mode 100644&#010;index 4ed843a..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&#010;+++ /dev/null&#010;@@ -1,120 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.regex.Matcher;&#010;-import java.util.regex.Pattern;&#010;-&#010;-/**&#010;- * This class is a copy from camel-core so we can use it independent to validate uris with time patterns&#010;- */&#010;-public final class TimePatternConverter {&#010;-    private static final Pattern NUMBERS_ONLY_STRING_PATTERN = Pattern.compile(""^[-]?(\\d)+$"", Pattern.CASE_INSENSITIVE);&#010;-    private static final Pattern HOUR_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))h(our(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;-    private static final Pattern MINUTES_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))m(in(ute(s)?)?)?"", Pattern.CASE_INSENSITIVE);&#010;-    private static final Pattern SECONDS_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))s(ec(ond)?(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;-&#010;-    /**&#010;-     * Utility classes should not have a public constructor.&#010;-     */&#010;-    private TimePatternConverter() {&#010;-    }&#010;-&#010;-    public static long toMilliSeconds(String source) throws IllegalArgumentException {&#010;-        long milliseconds = 0;&#010;-        boolean foundFlag = false;&#010;-&#010;-        checkCorrectnessOfPattern(source);&#010;-        Matcher matcher;&#010;-&#010;-        matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;-        if (matcher.find()) {&#010;-            // Note: This will also be used for regular numeric strings.&#010;-            //       This String -&gt; long converter will be used for all strings.&#010;-            milliseconds = Long.valueOf(source);&#010;-        } else {&#010;-            matcher = createMatcher(HOUR_REGEX_PATTERN, source);&#010;-            if (matcher.find()) {&#010;-                milliseconds = milliseconds + (3600000 * Long.valueOf(matcher.group(1)));&#010;-                foundFlag = true;&#010;-            }&#010;-&#010;-            matcher = createMatcher(MINUTES_REGEX_PATTERN, source);&#010;-            if (matcher.find()) {&#010;-                long minutes = Long.valueOf(matcher.group(1));&#010;-                if ((minutes &gt; 59) &amp;&amp; foundFlag) {&#010;-                    throw new IllegalArgumentException(""Minutes should contain a valid value between 0 and 59: "" + source);&#010;-                }&#010;-                foundFlag = true;&#010;-                milliseconds = milliseconds + (60000 * minutes);&#010;-            }&#010;-&#010;-            matcher = createMatcher(SECONDS_REGEX_PATTERN, source);&#010;-            if (matcher.find()) {&#010;-                long seconds = Long.valueOf(matcher.group(1));&#010;-                if ((seconds &gt; 59) &amp;&amp; foundFlag) {&#010;-                    throw new IllegalArgumentException(""Seconds should contain a valid value between 0 and 59: "" + source);&#010;-                }&#010;-                foundFlag = true;&#010;-                milliseconds = milliseconds + (1000 * seconds);&#010;-            }&#010;-&#010;-            // No pattern matched... initiating fallback check and conversion (if required).&#010;-            // The source at this point may contain illegal values or special characters&#010;-            if (!foundFlag) {&#010;-                milliseconds = Long.valueOf(source);&#010;-            }&#010;-        }&#010;-&#010;-        return milliseconds;&#010;-    }&#010;-&#010;-    private static void checkCorrectnessOfPattern(String source) {&#010;-        //replace only numbers once&#010;-        Matcher matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;-        String replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        //replace hour string once&#010;-        matcher = createMatcher(HOUR_REGEX_PATTERN, replaceSource);&#010;-        if (matcher.find() &amp;&amp; matcher.find()) {&#010;-            throw new IllegalArgumentException(""Hours should not be specified more then once: "" + source);&#010;-        }&#010;-        replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        //replace minutes once&#010;-        matcher = createMatcher(MINUTES_REGEX_PATTERN, replaceSource);&#010;-        if (matcher.find() &amp;&amp; matcher.find()) {&#010;-            throw new IllegalArgumentException(""Minutes should not be specified more then once: "" + source);&#010;-        }&#010;-        replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        //replace seconds once&#010;-        matcher = createMatcher(SECONDS_REGEX_PATTERN, replaceSource);&#010;-        if (matcher.find() &amp;&amp; matcher.find()) {&#010;-            throw new IllegalArgumentException(""Seconds should not be specified more then once: "" + source);&#010;-        }&#010;-        replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        if (replaceSource.length() &gt; 0) {&#010;-            throw new IllegalArgumentException(""Illegal characters: "" + source);&#010;-        }&#010;-    }&#010;-&#010;-    private static Matcher createMatcher(Pattern pattern, String source) {&#010;-        return pattern.matcher(source);&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java b/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java&#010;deleted file mode 100644&#010;index ea1ecd5..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java&#010;+++ /dev/null&#010;@@ -1,392 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.io.UnsupportedEncodingException;&#010;-import java.net.URI;&#010;-import java.net.URISyntaxException;&#010;-import java.net.URLDecoder;&#010;-import java.net.URLEncoder;&#010;-import java.util.ArrayList;&#010;-import java.util.Iterator;&#010;-import java.util.LinkedHashMap;&#010;-import java.util.List;&#010;-import java.util.Map;&#010;-&#010;-/**&#010;- * Copied from org.apache.camel.util.URISupport&#010;- */&#010;-public final class URISupport {&#010;-&#010;-    public static final String RAW_TOKEN_START = ""RAW("";&#010;-    public static final String RAW_TOKEN_END = "")"";&#010;-&#010;-    private static final String CHARSET = ""UTF-8"";&#010;-&#010;-    private URISupport() {&#010;-        // Helper class&#010;-    }&#010;-&#010;-    /**&#010;-     * Normalizes the URI so unsafe characters is encoded&#010;-     *&#010;-     * @param uri the input uri&#010;-     * @return as URI instance&#010;-     * @throws URISyntaxException is thrown if syntax error in the input uri&#010;-     */&#010;-    public static URI normalizeUri(String uri) throws URISyntaxException {&#010;-        return new URI(UnsafeUriCharactersEncoder.encode(uri, true));&#010;-    }&#010;-&#010;-    public static Map&lt;String, Object&gt; extractProperties(Map&lt;String, Object&gt; properties, String optionPrefix) {&#010;-        Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;(properties.size());&#010;-&#010;-        for (Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; it = properties.entrySet().iterator(); it.hasNext();) {&#010;-            Map.Entry&lt;String, Object&gt; entry = it.next();&#010;-            String name = entry.getKey();&#010;-            if (name.startsWith(optionPrefix)) {&#010;-                Object value = properties.get(name);&#010;-                name = name.substring(optionPrefix.length());&#010;-                rc.put(name, value);&#010;-                it.remove();&#010;-            }&#010;-        }&#010;-&#010;-        return rc;&#010;-    }&#010;-&#010;-    /**&#010;-     * Strips the query parameters from the uri&#010;-     *&#010;-     * @param uri  the uri&#010;-     * @return the uri without the query parameter&#010;-     */&#010;-    public static String stripQuery(String uri) {&#010;-        int idx = uri.indexOf('?');&#010;-        if (idx &gt; -1) {&#010;-            uri = uri.substring(0, idx);&#010;-        }&#010;-        return uri;&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the query parameters of the uri (eg the query part).&#010;-     *&#010;-     * @param uri the uri&#010;-     * @return the parameters, or an empty map if no parameters (eg never null)&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     */&#010;-    public static Map&lt;String, Object&gt; parseParameters(URI uri) throws URISyntaxException {&#010;-        String query = uri.getQuery();&#010;-        if (query == null) {&#010;-            String schemeSpecificPart = uri.getSchemeSpecificPart();&#010;-            int idx = schemeSpecificPart.indexOf('?');&#010;-            if (idx &lt; 0) {&#010;-                // return an empty map&#010;-                return new LinkedHashMap&lt;String, Object&gt;(0);&#010;-            } else {&#010;-                query = schemeSpecificPart.substring(idx + 1);&#010;-            }&#010;-        } else {&#010;-            query = stripPrefix(query, ""?"");&#010;-        }&#010;-        return parseQuery(query);&#010;-    }&#010;-&#010;-    /**&#010;-     * Strips the prefix from the value.&#010;-     * &lt;p/&gt;&#010;-     * Returns the value as-is if not starting with the prefix.&#010;-     *&#010;-     * @param value  the value&#010;-     * @param prefix the prefix to remove from value&#010;-     * @return the value without the prefix&#010;-     */&#010;-    public static String stripPrefix(String value, String prefix) {&#010;-        if (value != null &amp;&amp; value.startsWith(prefix)) {&#010;-            return value.substring(prefix.length());&#010;-        }&#010;-        return value;&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the query part of the uri (eg the parameters).&#010;-     * &lt;p/&gt;&#010;-     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;-     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;-     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;-     *&#010;-     * @param uri the uri&#010;-     * @return the parameters, or an empty map if no parameters (eg never null)&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     * @see #RAW_TOKEN_START&#010;-     * @see #RAW_TOKEN_END&#010;-     */&#010;-    public static Map&lt;String, Object&gt; parseQuery(String uri) throws URISyntaxException {&#010;-        return parseQuery(uri, false);&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the query part of the uri (eg the parameters).&#010;-     * &lt;p/&gt;&#010;-     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;-     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;-     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;-     *&#010;-     * @param uri the uri&#010;-     * @param useRaw whether to force using raw values&#010;-     * @return the parameters, or an empty map if no parameters (eg never null)&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     * @see #RAW_TOKEN_START&#010;-     * @see #RAW_TOKEN_END&#010;-     */&#010;-    public static Map&lt;String, Object&gt; parseQuery(String uri, boolean useRaw) throws URISyntaxException {&#010;-        // must check for trailing &amp; as the uri.split(""&amp;"") will ignore those&#010;-        if (uri != null &amp;&amp; uri.endsWith(""&amp;"")) {&#010;-            throw new URISyntaxException(uri, ""Invalid uri syntax: Trailing &amp; marker found. ""&#010;-                    + ""Check the uri and remove the trailing &amp; marker."");&#010;-        }&#010;-&#010;-        if (isEmpty(uri)) {&#010;-            // return an empty map&#010;-            return new LinkedHashMap&lt;String, Object&gt;(0);&#010;-        }&#010;-&#010;-        // need to parse the uri query parameters manually as we cannot rely on splitting by &amp;,&#010;-        // as &amp; can be used in a parameter value as well.&#010;-&#010;-        try {&#010;-            // use a linked map so the parameters is in the same order&#010;-            Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;();&#010;-&#010;-            boolean isKey = true;&#010;-            boolean isValue = false;&#010;-            boolean isRaw = false;&#010;-            StringBuilder key = new StringBuilder();&#010;-            StringBuilder value = new StringBuilder();&#010;-&#010;-            // parse the uri parameters char by char&#010;-            for (int i = 0; i &lt; uri.length(); i++) {&#010;-                // current char&#010;-                char ch = uri.charAt(i);&#010;-                // look ahead of the next char&#010;-                char next;&#010;-                if (i &lt;= uri.length() - 2) {&#010;-                    next = uri.charAt(i + 1);&#010;-                } else {&#010;-                    next = '\u0000';&#010;-                }&#010;-&#010;-                // are we a raw value&#010;-                isRaw = value.toString().startsWith(RAW_TOKEN_START);&#010;-&#010;-                // if we are in raw mode, then we keep adding until we hit the end marker&#010;-                if (isRaw) {&#010;-                    if (isKey) {&#010;-                        key.append(ch);&#010;-                    } else if (isValue) {&#010;-                        value.append(ch);&#010;-                    }&#010;-&#010;-                    // we only end the raw marker if its )&amp; or at the end of the value&#010;-&#010;-                    boolean end = ch == RAW_TOKEN_END.charAt(0) &amp;&amp; (next == '&amp;' || next == '\u0000');&#010;-                    if (end) {&#010;-                        // raw value end, so add that as a parameter, and reset flags&#010;-                        addParameter(key.toString(), value.toString(), rc, useRaw || isRaw);&#010;-                        key.setLength(0);&#010;-                        value.setLength(0);&#010;-                        isKey = true;&#010;-                        isValue = false;&#010;-                        isRaw = false;&#010;-                        // skip to next as we are in raw mode and have already added the value&#010;-                        i++;&#010;-                    }&#010;-                    continue;&#010;-                }&#010;-&#010;-                // if its a key and there is a = sign then the key ends and we are in value mode&#010;-                if (isKey &amp;&amp; ch == '=') {&#010;-                    isKey = false;&#010;-                    isValue = true;&#010;-                    isRaw = false;&#010;-                    continue;&#010;-                }&#010;-&#010;-                // the &amp; denote parameter is ended&#010;-                if (ch == '&amp;') {&#010;-                    // parameter is ended, as we hit &amp; separator&#010;-                    String aKey = key.toString();&#010;-                    // the key may be a placeholder of options which we then do not know what is&#010;-                    boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;-                    if (validKey) {&#010;-                        addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;-                    }&#010;-                    key.setLength(0);&#010;-                    value.setLength(0);&#010;-                    isKey = true;&#010;-                    isValue = false;&#010;-                    isRaw = false;&#010;-                    continue;&#010;-                }&#010;-&#010;-                // regular char so add it to the key or value&#010;-                if (isKey) {&#010;-                    key.append(ch);&#010;-                } else if (isValue) {&#010;-                    value.append(ch);&#010;-                }&#010;-            }&#010;-&#010;-            // any left over parameters, then add that&#010;-            if (key.length() &gt; 0) {&#010;-                String aKey = key.toString();&#010;-                // the key may be a placeholder of options which we then do not know what is&#010;-                boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;-                if (validKey) {&#010;-                    addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;-                }&#010;-            }&#010;-&#010;-            return rc;&#010;-&#010;-        } catch (UnsupportedEncodingException e) {&#010;-            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;-            se.initCause(e);&#010;-            throw se;&#010;-        }&#010;-    }&#010;-&#010;-    @SuppressWarnings(""unchecked"")&#010;-    private static void addParameter(String name, String value, Map&lt;String, Object&gt; map, boolean isRaw) throws UnsupportedEncodingException {&#010;-        name = URLDecoder.decode(name, CHARSET);&#010;-        if (!isRaw) {&#010;-            // need to replace % with %25&#010;-            value = URLDecoder.decode(value.replaceAll(""%"", ""%25""), CHARSET);&#010;-        }&#010;-&#010;-        // does the key already exist?&#010;-        if (map.containsKey(name)) {&#010;-            // yes it does, so make sure we can support multiple values, but using a list&#010;-            // to hold the multiple values&#010;-            Object existing = map.get(name);&#010;-            List&lt;String&gt; list;&#010;-            if (existing instanceof List) {&#010;-                list = (List&lt;String&gt;) existing;&#010;-            } else {&#010;-                // create a new list to hold the multiple values&#010;-                list = new ArrayList&lt;String&gt;();&#010;-                String s = existing != null ? existing.toString() : null;&#010;-                if (s != null) {&#010;-                    list.add(s);&#010;-                }&#010;-            }&#010;-            list.add(value);&#010;-            map.put(name, list);&#010;-        } else {&#010;-            map.put(name, value);&#010;-        }&#010;-    }&#010;-&#010;-    /**&#010;-     * Assembles a query from the given map.&#010;-     *&#010;-     * @param options  the map with the options (eg key/value pairs)&#010;-     * @param ampersand to use &amp; for Java code, and &amp;amp; for XML&#010;-     * @return a query string with &lt;tt&gt;key1=value&amp;key2=value2&amp;...&lt;/tt&gt;, or an empty string if there is no options.&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     */&#010;-    public static String createQueryString(Map&lt;String, String&gt; options, String ampersand, boolean encode) throws URISyntaxException {&#010;-        try {&#010;-            if (options.size() &gt; 0) {&#010;-                StringBuilder rc = new StringBuilder();&#010;-                boolean first = true;&#010;-                for (Object o : options.keySet()) {&#010;-                    if (first) {&#010;-                        first = false;&#010;-                    } else {&#010;-                        rc.append(ampersand);&#010;-                    }&#010;-&#010;-                    String key = (String) o;&#010;-                    Object value = options.get(key);&#010;-&#010;-                    // use the value as a String&#010;-                    String s = value != null ? value.toString() : null;&#010;-                    appendQueryStringParameter(key, s, rc, encode);&#010;-                }&#010;-                return rc.toString();&#010;-            } else {&#010;-                return """";&#010;-            }&#010;-        } catch (UnsupportedEncodingException e) {&#010;-            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;-            se.initCause(e);&#010;-            throw se;&#010;-        }&#010;-    }&#010;-&#010;-    private static void appendQueryStringParameter(String key, String value, StringBuilder rc, boolean encode) throws UnsupportedEncodingException {&#010;-        if (encode) {&#010;-            rc.append(URLEncoder.encode(key, CHARSET));&#010;-        } else {&#010;-            rc.append(key);&#010;-        }&#010;-        // only append if value is not null&#010;-        if (value != null) {&#010;-            rc.append(""="");&#010;-            if (value.startsWith(RAW_TOKEN_START) &amp;&amp; value.endsWith(RAW_TOKEN_END)) {&#010;-                // do not encode RAW parameters&#010;-                rc.append(value);&#010;-            } else {&#010;-                if (encode) {&#010;-                    rc.append(URLEncoder.encode(value, CHARSET));&#010;-                } else {&#010;-                    rc.append(value);&#010;-                }&#010;-            }&#010;-        }&#010;-    }&#010;-&#010;-    /**&#010;-     * Tests whether the value is &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;-     *&#010;-     * @param value  the value, if its a String it will be tested for text length as well&#010;-     * @return true if empty&#010;-     */&#010;-    public static boolean isEmpty(Object value) {&#010;-        return !isNotEmpty(value);&#010;-    }&#010;-&#010;-    /**&#010;-     * Tests whether the value is &lt;b&gt;not&lt;/b&gt; &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;-     *&#010;-     * @param value  the value, if its a String it will be tested for text length as well&#010;-     * @return true if &lt;b&gt;not&lt;/b&gt; empty&#010;-     */&#010;-    public static boolean isNotEmpty(Object value) {&#010;-        if (value == null) {&#010;-            return false;&#010;-        } else if (value instanceof String) {&#010;-            String text = (String) value;&#010;-            return text.trim().length() &gt; 0;&#010;-        } else {&#010;-            return true;&#010;-        }&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java b/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&#010;deleted file mode 100644&#010;index 563bac2..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&#010;+++ /dev/null&#010;@@ -1,206 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.ArrayList;&#010;-import java.util.BitSet;&#010;-import java.util.List;&#010;-import java.util.regex.Matcher;&#010;-import java.util.regex.Pattern;&#010;-&#010;-/**&#010;- * Encoder for unsafe URI characters.&#010;- * &lt;p/&gt;&#010;- * A good source for details is &lt;a href=""http://en.wikipedia.org/wiki/Url_encode""&gt;wikipedia url encode&lt;/a&gt; article.&#010;- */&#010;-public final class UnsafeUriCharactersEncoder {&#010;-    private static BitSet unsafeCharactersRfc1738;&#010;-    private static BitSet unsafeCharactersHttp;&#010;-    private static final char[] HEX_DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C',&#010;-        'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'};&#010;-    private static final Pattern RAW_PATTERN = Pattern.compile(""RAW\\([^\\)]+\\)"");&#010;-&#010;-    static {&#010;-        unsafeCharactersRfc1738 = new BitSet(256);&#010;-        unsafeCharactersRfc1738.set(' ');&#010;-        unsafeCharactersRfc1738.set('""');&#010;-        unsafeCharactersRfc1738.set('&lt;');&#010;-        unsafeCharactersRfc1738.set('&gt;');&#010;-        unsafeCharactersRfc1738.set('#');&#010;-        unsafeCharactersRfc1738.set('%');&#010;-        unsafeCharactersRfc1738.set('{');&#010;-        unsafeCharactersRfc1738.set('}');&#010;-        unsafeCharactersRfc1738.set('|');&#010;-        unsafeCharactersRfc1738.set('\\');&#010;-        unsafeCharactersRfc1738.set('^');&#010;-        unsafeCharactersRfc1738.set('~');&#010;-        unsafeCharactersRfc1738.set('[');&#010;-        unsafeCharactersRfc1738.set(']');&#010;-        unsafeCharactersRfc1738.set('`');&#010;-    }&#010;-&#010;-    static {&#010;-        unsafeCharactersHttp = new BitSet(256);&#010;-        unsafeCharactersHttp.set(' ');&#010;-        unsafeCharactersHttp.set('""');&#010;-        unsafeCharactersHttp.set('&lt;');&#010;-        unsafeCharactersHttp.set('&gt;');&#010;-        unsafeCharactersHttp.set('#');&#010;-        unsafeCharactersHttp.set('%');&#010;-        unsafeCharactersHttp.set('{');&#010;-        unsafeCharactersHttp.set('}');&#010;-        unsafeCharactersHttp.set('|');&#010;-        unsafeCharactersHttp.set('\\');&#010;-        unsafeCharactersHttp.set('^');&#010;-        unsafeCharactersHttp.set('~');&#010;-        unsafeCharactersHttp.set('`');&#010;-    }&#010;-&#010;-    private UnsafeUriCharactersEncoder() {&#010;-        // util class&#010;-    }&#010;-&#010;-    public static String encode(String s) {&#010;-        return encode(s, unsafeCharactersRfc1738);&#010;-    }&#010;-&#010;-    public static String encodeHttpURI(String s) {&#010;-        return encode(s, unsafeCharactersHttp);&#010;-    }&#010;-&#010;-    public static String encode(String s, BitSet unsafeCharacters) {&#010;-        return encode(s, unsafeCharacters, false);&#010;-    }&#010;-&#010;-    public static String encode(String s, boolean checkRaw) {&#010;-        return encode(s, unsafeCharactersRfc1738, checkRaw);&#010;-    }&#010;-&#010;-    public static String encodeHttpURI(String s, boolean checkRaw) {&#010;-        return encode(s, unsafeCharactersHttp, checkRaw);&#010;-    }&#010;-&#010;-    private static List&lt;Pair&gt; checkRAW(String s) {&#010;-        Matcher matcher = RAW_PATTERN.matcher(s);&#010;-        List&lt;Pair&gt; answer = new ArrayList&lt;Pair&gt;();&#010;-        // Check all occurrences&#010;-        while (matcher.find()) {&#010;-            answer.add(new Pair(matcher.start(), matcher.end()));&#010;-        }&#010;-        return answer;&#010;-    }&#010;-&#010;-    private static boolean isRaw(int index, List&lt;Pair&gt; pairs) {&#010;-        for (Pair pair : pairs) {&#010;-            if (index &lt; pair.left) {&#010;-                return false;&#010;-            } else {&#010;-                if (index &gt;= pair.left) {&#010;-                    if (index &lt;= pair.right) {&#010;-                        return true;&#010;-                    } else {&#010;-                        continue;&#010;-                    }&#010;-                }&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    private static class Pair {&#010;-        int left;&#010;-        int right;&#010;-&#010;-        Pair(int left, int right) {&#010;-            this.left = left;&#010;-            this.right = right;&#010;-        }&#010;-    }&#010;-&#010;-    // Just skip the encode for isRAW part&#010;-    public static String encode(String s, BitSet unsafeCharacters, boolean checkRaw) {&#010;-        List&lt;Pair&gt; rawPairs;&#010;-        if (checkRaw) {&#010;-            rawPairs = checkRAW(s);&#010;-        } else {&#010;-            rawPairs = new ArrayList&lt;Pair&gt;();&#010;-        }&#010;-&#010;-        int n = s == null ? 0 : s.length();&#010;-        if (n == 0) {&#010;-            return s;&#010;-        }&#010;-&#010;-        // First check whether we actually need to encode&#010;-        char chars[] = s.toCharArray();&#010;-        for (int i = 0;;) {&#010;-            // just deal with the ascii character&#010;-            if (chars[i] &gt; 0 &amp;&amp; chars[i] &lt; 128) {&#010;-                if (unsafeCharacters.get(chars[i])) {&#010;-                    break;&#010;-                }&#010;-            }&#010;-            if (++i &gt;= chars.length) {&#010;-                return s;&#010;-            }&#010;-        }&#010;-&#010;-        // okay there are some unsafe characters so we do need to encode&#010;-        // see details at: http://en.wikipedia.org/wiki/Url_encode&#010;-        StringBuilder sb = new StringBuilder();&#010;-        for (int i = 0; i &lt; chars.length; i++) {&#010;-            char ch = chars[i];&#010;-            if (ch &gt; 0 &amp;&amp; ch &lt; 128 &amp;&amp; unsafeCharacters.get(ch)) {&#010;-                // special for % sign as it may be a decimal encoded value&#010;-                if (ch == '%') {&#010;-                    char next = i + 1 &lt; chars.length ? chars[i + 1] : ' ';&#010;-                    char next2 = i + 2 &lt; chars.length ? chars[i + 2] : ' ';&#010;-&#010;-                    if (isHexDigit(next) &amp;&amp; isHexDigit(next2) &amp;&amp; !isRaw(i, rawPairs)) {&#010;-                        // its already encoded (decimal encoded) so just append as is&#010;-                        sb.append(ch);&#010;-                    } else {&#010;-                        // must escape then, as its an unsafe character&#010;-                        appendEscape(sb, (byte) ch);&#010;-                    }&#010;-                } else {&#010;-                    // must escape then, as its an unsafe character&#010;-                    appendEscape(sb, (byte) ch);&#010;-                }&#010;-            } else {&#010;-                sb.append(ch);&#010;-            }&#010;-        }&#010;-        return sb.toString();&#010;-    }&#010;-&#010;-    private static void appendEscape(StringBuilder sb, byte b) {&#010;-        sb.append('%');&#010;-        sb.append(HEX_DIGITS[(b &gt;&gt; 4) &amp; 0x0f]);&#010;-        sb.append(HEX_DIGITS[(b &gt;&gt; 0) &amp; 0x0f]);&#010;-    }&#010;-&#010;-    private static boolean isHexDigit(char ch) {&#010;-        for (char hex : HEX_DIGITS) {&#010;-            if (hex == ch) {&#010;-                return true;&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/package.html&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/package.html b/camel-core/src/main/java/org/apache/camel/catalog/package.html&#010;deleted file mode 100644&#010;index 98786d1..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/package.html&#010;+++ /dev/null&#010;@@ -1,25 +0,0 @@&#010;-&lt;!--&#010;-    Licensed to the Apache Software Foundation (ASF) under one or more&#010;-    contributor license agreements.  See the NOTICE file distributed with&#010;-    this work for additional information regarding copyright ownership.&#010;-    The ASF licenses this file to You under the Apache License, Version 2.0&#010;-    (the ""License""); you may not use this file except in compliance with&#010;-    the License.  You may obtain a copy of the License at&#010;-&#010;-    http://www.apache.org/licenses/LICENSE-2.0&#010;-&#010;-    Unless required by applicable law or agreed to in writing, software&#010;-    distributed under the License is distributed on an ""AS IS"" BASIS,&#010;-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;-    See the License for the specific language governing permissions and&#010;-    limitations under the License.&#010;---&gt;&#010;-&lt;html&gt;&#010;-&lt;head&gt;&#010;-&lt;/head&gt;&#010;-&lt;body&gt;&#010;-&#010;-Camel Catalog&#010;-&#010;-&lt;/body&gt;&#010;-&lt;/html&gt;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java b/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;index 5d19e0d..4013e5f 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;@@ -22,12 +22,12 @@ import java.util.Map;&#010; import org.apache.camel.Component;&#010; import org.apache.camel.ComponentVerifier;&#010; import org.apache.camel.VerifiableComponent;&#010;-import org.apache.camel.catalog.JSonSchemaHelper;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010; import org.apache.camel.impl.verifier.CatalogVerifierCustomizer;&#010; import org.apache.camel.impl.verifier.DefaultComponentVerifier;&#010; import org.apache.camel.impl.verifier.ResultBuilder;&#010; import org.apache.camel.impl.verifier.ResultErrorBuilder;&#010;+import org.apache.camel.runtimecatalog.JSonSchemaHelper;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.RestConsumerFactory;&#010; import org.apache.camel.spi.RestProducerFactory;&#010; import org.apache.camel.util.ObjectHelper;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;index c85ce8c..b53efc8 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;@@ -26,7 +26,6 @@ import java.util.Collections;&#010; import java.util.Comparator;&#010; import java.util.Date;&#010; import java.util.HashMap;&#010;-import java.util.HashSet;&#010; import java.util.Iterator;&#010; import java.util.LinkedHashMap;&#010; import java.util.LinkedHashSet;&#010;@@ -87,8 +86,6 @@ import org.apache.camel.api.management.mbean.ManagedRouteMBean;&#010; import org.apache.camel.builder.DefaultFluentProducerTemplate;&#010; import org.apache.camel.builder.ErrorHandlerBuilder;&#010; import org.apache.camel.builder.ErrorHandlerBuilderSupport;&#010;-import org.apache.camel.catalog.DefaultRuntimeCamelCatalog;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010; import org.apache.camel.component.properties.PropertiesComponent;&#010; import org.apache.camel.impl.converter.BaseTypeConverterRegistry;&#010; import org.apache.camel.impl.converter.DefaultTypeConverter;&#010;@@ -121,6 +118,8 @@ import org.apache.camel.processor.interceptor.Delayer;&#010; import org.apache.camel.processor.interceptor.HandleFault;&#010; import org.apache.camel.processor.interceptor.StreamCaching;&#010; import org.apache.camel.processor.interceptor.Tracer;&#010;+import org.apache.camel.runtimecatalog.DefaultRuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.AsyncProcessorAwaitManager;&#010; import org.apache.camel.spi.CamelContextNameStrategy;&#010; import org.apache.camel.spi.ClassResolver;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java b/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;index b9d9998..f05cdb1 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;@@ -25,8 +25,8 @@ import org.apache.camel.CamelContext;&#010; import org.apache.camel.ComponentVerifier;&#010; import org.apache.camel.NoSuchOptionException;&#010; import org.apache.camel.TypeConverter;&#010;-import org.apache.camel.catalog.EndpointValidationResult;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.EndpointValidationResult;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.util.CamelContextHelper;&#010; import org.apache.camel.util.EndpointHelper;&#010; import org.apache.camel.util.IntrospectionSupport;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;index a09ff7d..9a70390 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;@@ -46,12 +46,9 @@ import org.apache.camel.StartupListener;&#010; import org.apache.camel.TimerListener;&#010; import org.apache.camel.VetoCamelContextStartException;&#010; import org.apache.camel.api.management.PerformanceCounter;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010; import org.apache.camel.impl.ConsumerCache;&#010; import org.apache.camel.impl.DefaultCamelContext;&#010; import org.apache.camel.impl.DefaultEndpointRegistry;&#010;-import org.apache.camel.impl.DefaultTransformerRegistry;&#010;-import org.apache.camel.impl.DefaultValidatorRegistry;&#010; import org.apache.camel.impl.EventDrivenConsumerRoute;&#010; import org.apache.camel.impl.ProducerCache;&#010; import org.apache.camel.impl.ThrottlingExceptionRoutePolicy;&#010;@@ -89,6 +86,7 @@ import org.apache.camel.processor.CamelInternalProcessor;&#010; import org.apache.camel.processor.interceptor.BacklogDebugger;&#010; import org.apache.camel.processor.interceptor.BacklogTracer;&#010; import org.apache.camel.processor.interceptor.Tracer;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.AsyncProcessorAwaitManager;&#010; import org.apache.camel.spi.DataFormat;&#010; import org.apache.camel.spi.EventNotifier;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;index 20d3f28..6a99656 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;@@ -19,7 +19,7 @@ package org.apache.camel.management.mbean;&#010; import org.apache.camel.CamelContext;&#010; import org.apache.camel.api.management.ManagedResource;&#010; import org.apache.camel.api.management.mbean.ManagedRuntimeCamelCatalogMBean;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.ManagementStrategy;&#010; &#010; /**&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C6a3e7fae5cba4f918aede10c3ae6ef26%40git.apache.org%3E,2017-04-14 10:52,commits,2.0,326.0,  [5/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
6,322.0,davscl...@apache.org,"Repository: camel&#010;Updated Branches:&#010;  refs/heads/master d72696455 -&gt; 6b42a3534&#010;&#010;&#010;Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/6b42a353&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/6b42a353&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/6b42a353&#010;&#010;Branch: refs/heads/master&#010;Commit: 6b42a3534120f58180e6194e6bf4f1a284707abc&#010;Parents: c66be7a&#010;Author: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Authored: Fri Apr 14 12:17:14 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:52:40 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; platforms/camel-catalog/pom.xml | 40 ++++++++++++++++++++++++++++++++++--&#010; 1 file changed, 38 insertions(+), 2 deletions(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/6b42a353/platforms/camel-catalog/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/platforms/camel-catalog/pom.xml b/platforms/camel-catalog/pom.xml&#010;index 2be82e0..6c71fcb 100644&#010;--- a/platforms/camel-catalog/pom.xml&#010;+++ b/platforms/camel-catalog/pom.xml&#010;@@ -92,7 +92,7 @@&#010;         &lt;executions&gt;&#010;           &lt;execution&gt;&#010;             &lt;id&gt;copy-resources&lt;/id&gt;&#010;-            &lt;phase&gt;process-sources&lt;/phase&gt;&#010;+            &lt;phase&gt;generate-sources&lt;/phase&gt;&#010;             &lt;goals&gt;&#010;               &lt;goal&gt;copy-resources&lt;/goal&gt;&#010;             &lt;/goals&gt;&#010;@@ -101,7 +101,7 @@&#010;               &lt;overwrite&gt;true&lt;/overwrite&gt;&#010;               &lt;resources&gt;&#010;                 &lt;resource&gt;&#010;-                  &lt;directory&gt;../../camel-core/src/main/java/org/apache/camel/catalog&lt;/directory&gt;&#010;+                  &lt;directory&gt;../../camel-core/src/main/java/org/apache/camel/runtimecatalog&lt;/directory&gt;&#010;                   &lt;!-- the following files are maintained in camel-core and not here,&#010;so they are copied over --&gt;&#010;                   &lt;includes&gt;&#010;                     &lt;include&gt;AbstractCamelCatalog.java&lt;/include&gt;&#010;@@ -123,6 +123,42 @@&#010;           &lt;/execution&gt;&#010;         &lt;/executions&gt;&#010;       &lt;/plugin&gt;&#010;+      &lt;!-- rename runtimecatalog to catalog which is the package name we use here --&gt;&#010;+      &lt;plugin&gt;&#010;+        &lt;groupId&gt;com.google.code.maven-replacer-plugin&lt;/groupId&gt;&#010;+        &lt;artifactId&gt;replacer&lt;/artifactId&gt;&#010;+        &lt;version&gt;1.5.3&lt;/version&gt;&#010;+        &lt;executions&gt;&#010;+          &lt;execution&gt;&#010;+            &lt;phase&gt;process-sources&lt;/phase&gt;&#010;+            &lt;goals&gt;&#010;+              &lt;goal&gt;replace&lt;/goal&gt;&#010;+            &lt;/goals&gt;&#010;+          &lt;/execution&gt;&#010;+        &lt;/executions&gt;&#010;+        &lt;configuration&gt;&#010;+          &lt;includes&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/AbstractCamelCatalog.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/CatalogHelper.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/CollectionStringBuffer.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/URISupport.java&lt;/include&gt;&#010;+          &lt;/includes&gt;&#010;+          &lt;replacements&gt;&#010;+            &lt;replacement&gt;&#010;+              &lt;token&gt;org.apache.camel.runtimecatalog&lt;/token&gt;&#010;+              &lt;value&gt;org.apache.camel.catalog&lt;/value&gt;&#010;+            &lt;/replacement&gt;&#010;+          &lt;/replacements&gt;&#010;+        &lt;/configuration&gt;&#010;+      &lt;/plugin&gt;&#010; &#010;       &lt;!-- generate and include all components in the catalog --&gt;&#010;       &lt;plugin&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cde5de0a2e2ca40e6bcaa03835723a40e%40git.apache.org%3E,2017-04-14 10:52,commits,3.0,322.0,[1/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
7,323.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;b/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;new file mode 100644&#010;index 0000000..309fb8e&#010;--- /dev/null&#010;+++ b/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;@@ -0,0 +1,104 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.net.URISyntaxException;&#010;+import java.util.HashMap;&#010;+import java.util.Map;&#010;+&#010;+import org.junit.Before;&#010;+import org.junit.Test;&#010;+&#010;+import static org.easymock.EasyMock.expect;&#010;+import static org.easymock.EasyMock.mock;&#010;+import static org.easymock.EasyMock.replay;&#010;+import static org.junit.Assert.assertEquals;&#010;+&#010;+public class AbstractCamelCatalogTest {&#010;+&#010;+    AbstractCamelCatalog catalog = new AbstractCamelCatalog() {&#010;+    };&#010;+&#010;+    JSonSchemaResolver resolver;&#010;+&#010;+    @Before&#010;+    public void setupMockCatalog() {&#010;+        resolver = mock(JSonSchemaResolver.class);&#010;+&#010;+        catalog.setJSonSchemaResolver(resolver);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void shouldConstructEndpointUris() throws URISyntaxException {&#010;+        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;+            + ""  \""component\"": {\n""//&#010;+            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;+            + ""  }\n""//&#010;+            + ""}"");&#010;+&#010;+        replay(resolver);&#010;+&#010;+        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;+        properties.put(""param1"", ""value1"");&#010;+        properties.put(""param2"", ""value2"");&#010;+        properties.put(""param3"", ""value3"");&#010;+&#010;+        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;+&#010;+        assertEquals(""comp:value1:value2?param3=value3"", endpointUri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void shouldConstructEndpointUrisWithPropertyPlaceholders() throws URISyntaxException&#010;{&#010;+        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;+            + ""  \""component\"": {\n""//&#010;+            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;+            + ""  }\n""//&#010;+            + ""}"");&#010;+&#010;+        replay(resolver);&#010;+&#010;+        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;+        properties.put(""param1"", ""{{prop1}}"");&#010;+        properties.put(""param2"", ""{{prop2}}"");&#010;+        properties.put(""param3"", ""{{prop3}}"");&#010;+&#010;+        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;+&#010;+        assertEquals(""comp:{{prop1}}:{{prop2}}?param3={{prop3}}"", endpointUri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void shouldConstructEndpointUrisWhenValuesContainTokens() throws URISyntaxException&#010;{&#010;+        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;+            + ""  \""component\"": {\n""//&#010;+            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;+            + ""  }\n""//&#010;+            + ""}"");&#010;+&#010;+        replay(resolver);&#010;+&#010;+        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;+        properties.put(""param1"", ""{value1}"");&#010;+        properties.put(""param2"", ""/value2/"");&#010;+        properties.put(""param3"", ""/value3/{param}"");&#010;+&#010;+        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;+&#010;+        assertEquals(""comp:{value1}:/value2/?param3=/value3/{param}"", endpointUri);&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;b/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;new file mode 100644&#010;index 0000000..dfdd5c5&#010;--- /dev/null&#010;+++ b/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;@@ -0,0 +1,393 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.HashMap;&#010;+import java.util.Map;&#010;+&#010;+import org.apache.camel.impl.DefaultCamelContext;&#010;+import org.junit.BeforeClass;&#010;+import org.junit.Test;&#010;+import org.slf4j.Logger;&#010;+import org.slf4j.LoggerFactory;&#010;+&#010;+import static org.junit.Assert.assertEquals;&#010;+import static org.junit.Assert.assertFalse;&#010;+import static org.junit.Assert.assertNotNull;&#010;+import static org.junit.Assert.assertTrue;&#010;+&#010;+public class RuntimeCamelCatalogTest {&#010;+&#010;+    static RuntimeCamelCatalog catalog;&#010;+&#010;+    private static final Logger LOG = LoggerFactory.getLogger(RuntimeCamelCatalogTest.class);&#010;+&#010;+    @BeforeClass&#010;+    public static void createCamelCatalog() {&#010;+        catalog = new DefaultRuntimeCamelCatalog(new DefaultCamelContext());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testFromCamelContext() throws Exception {&#010;+        String schema = new DefaultCamelContext().getRuntimeCamelCatalog().modelJSonSchema(""choice"");&#010;+        assertNotNull(schema);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testJsonSchema() throws Exception {&#010;+        String schema = catalog.modelJSonSchema(""aggregate"");&#010;+        assertNotNull(schema);&#010;+&#010;+        // lets make it possible to find bean/method using both names&#010;+        schema = catalog.modelJSonSchema(""method"");&#010;+        assertNotNull(schema);&#010;+        schema = catalog.modelJSonSchema(""bean"");&#010;+        assertNotNull(schema);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriMapFile() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""directoryName"", ""src/data/inbox"");&#010;+        map.put(""noop"", ""true"");&#010;+        map.put(""delay"", ""5000"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""file"", map, true);&#010;+        assertEquals(""file:src/data/inbox?delay=5000&amp;noop=true"", uri);&#010;+&#010;+        String uri2 = catalog.asEndpointUriXml(""file"", map, true);&#010;+        assertEquals(""file:src/data/inbox?delay=5000&amp;amp;noop=true"", uri2);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriTimer() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""timerName"", ""foo"");&#010;+        map.put(""period"", ""5000"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;+        assertEquals(""timer:foo?period=5000"", uri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriPropertiesPlaceholders() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""timerName"", ""foo"");&#010;+        map.put(""period"", ""{{howoften}}"");&#010;+        map.put(""repeatCount"", ""5"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;+        assertEquals(""timer:foo?period=%7B%7Bhowoften%7D%7D&amp;repeatCount=5"", uri);&#010;+&#010;+        uri = catalog.asEndpointUri(""timer"", map, false);&#010;+        assertEquals(""timer:foo?period={{howoften}}&amp;repeatCount=5"", uri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriBeanLookup() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""resourceUri"", ""foo.xslt"");&#010;+        map.put(""converter"", ""#myConverter"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""xslt"", map, true);&#010;+        assertEquals(""xslt:foo.xslt?converter=%23myConverter"", uri);&#010;+&#010;+        uri = catalog.asEndpointUri(""xslt"", map, false);&#010;+        assertEquals(""xslt:foo.xslt?converter=#myConverter"", uri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testEndpointPropertiesPlaceholders() throws Exception {&#010;+        Map&lt;String, String&gt; map = catalog.endpointProperties(""timer:foo?period={{howoften}}&amp;repeatCount=5"");&#010;+        assertNotNull(map);&#010;+        assertEquals(3, map.size());&#010;+&#010;+        assertEquals(""foo"", map.get(""timerName""));&#010;+        assertEquals(""{{howoften}}"", map.get(""period""));&#010;+        assertEquals(""5"", map.get(""repeatCount""));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriLog() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""loggerName"", ""foo"");&#010;+        map.put(""loggerLevel"", ""WARN"");&#010;+        map.put(""multiline"", ""true"");&#010;+        map.put(""showAll"", ""true"");&#010;+        map.put(""showBody"", ""false"");&#010;+        map.put(""showBodyType"", ""false"");&#010;+        map.put(""showExchangePattern"", ""false"");&#010;+        map.put(""style"", ""Tab"");&#010;+&#010;+        assertEquals(""log:foo?loggerLevel=WARN&amp;multiline=true&amp;showAll=true&amp;style=Tab"",&#010;catalog.asEndpointUri(""log"", map, false));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriLogShort() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""loggerName"", ""foo"");&#010;+        map.put(""loggerLevel"", ""DEBUG"");&#010;+&#010;+        assertEquals(""log:foo?loggerLevel=DEBUG"", catalog.asEndpointUri(""log"", map, false));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriWithplaceholder() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""name"", ""foo"");&#010;+        map.put(""blockWhenFull"", ""{{block}}"");&#010;+        assertEquals(""seda:foo?blockWhenFull={{block}}"", catalog.asEndpointUri(""seda"", map,&#010;false));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testEndpointPropertiesSedaRequired() throws Exception {&#010;+        Map&lt;String, String&gt; map = catalog.endpointProperties(""seda:foo"");&#010;+        assertNotNull(map);&#010;+        assertEquals(1, map.size());&#010;+&#010;+        assertEquals(""foo"", map.get(""name""));&#010;+&#010;+        map = catalog.endpointProperties(""seda:foo?blockWhenFull=true"");&#010;+        assertNotNull(map);&#010;+        assertEquals(2, map.size());&#010;+&#010;+        assertEquals(""foo"", map.get(""name""));&#010;+        assertEquals(""true"", map.get(""blockWhenFull""));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void validateProperties() throws Exception {&#010;+        // valid&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(""log:mylog"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // unknown&#010;+        result = catalog.validateEndpointProperties(""log:mylog?level=WARN&amp;foo=bar"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getUnknown().contains(""foo""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // enum&#010;+        result = catalog.validateEndpointProperties(""seda:foo?waitForTaskToComplete=blah"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""blah"", result.getInvalidEnum().get(""waitForTaskToComplete""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // reference okay&#010;+        result = catalog.validateEndpointProperties(""seda:foo?queue=#queue"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(0, result.getNumberOfErrors());&#010;+&#010;+        // unknown component&#010;+        result = catalog.validateEndpointProperties(""foo:bar?me=you"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getUnknownComponent().equals(""foo""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // invalid boolean but default value&#010;+        result = catalog.validateEndpointProperties(""log:output?showAll=ggg"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""ggg"", result.getInvalidBoolean().get(""showAll""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // dataset&#010;+        result = catalog.validateEndpointProperties(""dataset:foo?minRate=50"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // time pattern&#010;+        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=true&amp;delay=0&amp;period=2s"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // reference lookup&#010;+        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=#fixed&amp;delay=#myDelay"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // optional consumer. prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?consumer.delay=5000&amp;consumer.greedy=true"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // optional without consumer. prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;greedy=true"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // mixed optional without consumer. prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;consumer.greedy=true"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;scheduler.foo=123&amp;scheduler.bar=456"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // stub&#010;+        result = catalog.validateEndpointProperties(""stub:foo?me=123&amp;you=456"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // lenient on&#010;+        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // lenient off&#010;+        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"",&#010;true);&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getUnknown().contains(""foo""));&#010;+&#010;+        // data format&#010;+        result = catalog.validateEndpointProperties(""dataformat:string:marshal?charset=utf-8"",&#010;true);&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // incapable to parse&#010;+        result = catalog.validateEndpointProperties(""{{getFtpUrl}}?recursive=true"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getIncapable() != null);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void validatePropertiesSummary() throws Exception {&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(""yammer:MESSAGES?blah=yada&amp;accessToken=aaa&amp;consumerKey=&amp;useJson=no&amp;initialDelay=five&amp;pollStrategy=myStrategy"");&#010;+        assertFalse(result.isSuccess());&#010;+        String reason = result.summaryErrorMessage(true);&#010;+        LOG.info(reason);&#010;+&#010;+        result = catalog.validateEndpointProperties(""jms:unknown:myqueue"");&#010;+        assertFalse(result.isSuccess());&#010;+        reason = result.summaryErrorMessage(false);&#010;+        LOG.info(reason);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void validateTimePattern() throws Exception {&#010;+        assertTrue(catalog.validateTimePattern(""0""));&#010;+        assertTrue(catalog.validateTimePattern(""500""));&#010;+        assertTrue(catalog.validateTimePattern(""10000""));&#010;+        assertTrue(catalog.validateTimePattern(""5s""));&#010;+        assertTrue(catalog.validateTimePattern(""5sec""));&#010;+        assertTrue(catalog.validateTimePattern(""5secs""));&#010;+        assertTrue(catalog.validateTimePattern(""3m""));&#010;+        assertTrue(catalog.validateTimePattern(""3min""));&#010;+        assertTrue(catalog.validateTimePattern(""3minutes""));&#010;+        assertTrue(catalog.validateTimePattern(""5m15s""));&#010;+        assertTrue(catalog.validateTimePattern(""1h""));&#010;+        assertTrue(catalog.validateTimePattern(""1hour""));&#010;+        assertTrue(catalog.validateTimePattern(""2hours""));&#010;+&#010;+        assertFalse(catalog.validateTimePattern(""bla""));&#010;+        assertFalse(catalog.validateTimePattern(""2year""));&#010;+        assertFalse(catalog.validateTimePattern(""60darn""));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testEndpointComponentName() throws Exception {&#010;+        String name = catalog.endpointComponentName(""jms:queue:foo"");&#010;+        assertEquals(""jms"", name);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testSimpleExpression() throws Exception {&#010;+        SimpleValidationResult result = catalog.validateSimpleExpression(null, ""${body}"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body}"", result.getSimple());&#010;+&#010;+        result = catalog.validateSimpleExpression(null, ""${body"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""${body"", result.getSimple());&#010;+        LOG.info(result.getError());&#010;+        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol&#010;at location 5""));&#010;+        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;+        assertEquals(5, result.getIndex());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testSimplePredicate() throws Exception {&#010;+        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} ==&#010;'abc'"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body} == 'abc'"", result.getSimple());&#010;+&#010;+        result = catalog.validateSimplePredicate(null, ""${body} &gt; ${header.size"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""${body} &gt; ${header.size"", result.getSimple());&#010;+        LOG.info(result.getError());&#010;+        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol&#010;at location 22""));&#010;+        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;+        assertEquals(22, result.getIndex());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testSimplePredicatePlaceholder() throws Exception {&#010;+        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} contains&#010;'{{danger}}'"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body} contains '{{danger}}'"", result.getSimple());&#010;+&#010;+        result = catalog.validateSimplePredicate(null, ""${bdy} contains '{{danger}}'"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""${bdy} contains '{{danger}}'"", result.getSimple());&#010;+        LOG.info(result.getError());&#010;+        assertTrue(result.getError().startsWith(""Unknown function: bdy at location 0""));&#010;+        assertTrue(result.getError().contains(""'{{danger}}'""));&#010;+        assertEquals(""Unknown function: bdy"", result.getShortError());&#010;+        assertEquals(0, result.getIndex());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testValidateLanguage() throws Exception {&#010;+        LanguageValidationResult result = catalog.validateLanguageExpression(null, ""simple"",&#010;""${body}"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body}"", result.getText());&#010;+&#010;+        result = catalog.validateLanguageExpression(null, ""header"", ""foo"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""foo"", result.getText());&#010;+&#010;+        result = catalog.validateLanguagePredicate(null, ""simple"", ""${body} &gt; 10"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body} &gt; 10"", result.getText());&#010;+&#010;+        result = catalog.validateLanguagePredicate(null, ""header"", ""bar"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""bar"", result.getText());&#010;+&#010;+        result = catalog.validateLanguagePredicate(null, ""foobar"", ""bar"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""Unknown language foobar"", result.getError());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testValidateEndpointConsumerOnly() throws Exception {&#010;+        String uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true"";&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false,&#010;true, false);&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true&amp;fileExist=Append"";&#010;+        result = catalog.validateEndpointProperties(uri, false, true, false);&#010;+        assertFalse(result.isSuccess());&#010;+&#010;+        assertEquals(""fileExist"", result.getNotConsumerOnly().iterator().next());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testValidateEndpointProducerOnly() throws Exception {&#010;+        String uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append"";&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false,&#010;false, true);&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append&amp;delete=true"";&#010;+        result = catalog.validateEndpointProperties(uri, false, false, true);&#010;+        assertFalse(result.isSuccess());&#010;+&#010;+        assertEquals(""delete"", result.getNotProducerOnly().iterator().next());&#010;+    }&#010;+&#010;+}&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C9e3f964e77d045cf840b002cc3565efe%40git.apache.org%3E,2017-04-14 10:52,commits,3.0,323.0,  [2/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
8,324.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java&#010;new file mode 100644&#010;index 0000000..1e69269&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java&#010;@@ -0,0 +1,424 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.ArrayList;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.LinkedHashSet;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+import java.util.Set;&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+public final class JSonSchemaHelper {&#010;+&#010;+    // 0 = text, 1 = enum, 2 = boolean, 3 = integer or number&#010;+    private static final Pattern PATTERN = Pattern.compile(""\""(.+?)\""|\\[(.+)\\]|(true|false)|(-?\\d+\\.?\\d*)"");&#010;+    private static final String QUOT = ""&amp;quot;"";&#010;+&#010;+    private JSonSchemaHelper() {&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the json schema to split it into a list or rows, where each row contains key value pairs with the metadata&#010;+     *&#010;+     * @param group the group to parse from such as &lt;tt&gt;component&lt;/tt&gt;, &lt;tt&gt;componentProperties&lt;/tt&gt;, or &lt;tt&gt;properties&lt;/tt&gt;.&#010;+     * @param json the json&#010;+     * @return a list of all the rows, where each row is a set of key value pairs with metadata&#010;+     */&#010;+    public static List&lt;Map&lt;String, String&gt;&gt; parseJsonSchema(String group, String json, boolean parseProperties) {&#010;+        List&lt;Map&lt;String, String&gt;&gt; answer = new ArrayList&lt;Map&lt;String, String&gt;&gt;();&#010;+        if (json == null) {&#010;+            return answer;&#010;+        }&#010;+&#010;+        boolean found = false;&#010;+&#010;+        // parse line by line&#010;+        String[] lines = json.split(""\n"");&#010;+        for (String line : lines) {&#010;+            // we need to find the group first&#010;+            if (!found) {&#010;+                String s = line.trim();&#010;+                found = s.startsWith(""\"""" + group + ""\"":"") &amp;&amp; s.endsWith(""{"");&#010;+                continue;&#010;+            }&#010;+&#010;+            // we should stop when we end the group&#010;+            if (line.equals(""  },"") || line.equals(""  }"")) {&#010;+                break;&#010;+            }&#010;+&#010;+            // need to safe encode \"" so we can parse the line&#010;+            line = line.replaceAll(""\""\\\\\""\"""", '""' + QUOT + '""');&#010;+&#010;+            Map&lt;String, String&gt; row = new LinkedHashMap&lt;String, String&gt;();&#010;+            Matcher matcher = PATTERN.matcher(line);&#010;+&#010;+            String key;&#010;+            if (parseProperties) {&#010;+                // when parsing properties the first key is given as name, so the first parsed token is the value of the name&#010;+                key = ""name"";&#010;+            } else {&#010;+                key = null;&#010;+            }&#010;+            while (matcher.find()) {&#010;+                if (key == null) {&#010;+                    key = matcher.group(1);&#010;+                } else {&#010;+                    String value = matcher.group(1);&#010;+                    if (value != null) {&#010;+                        // its text based&#010;+                        value = value.trim();&#010;+                        // decode&#010;+                        value = value.replaceAll(QUOT, ""\"""");&#010;+                        value = decodeJson(value);&#010;+                    }&#010;+                    if (value == null) {&#010;+                        // not text then its maybe an enum?&#010;+                        value = matcher.group(2);&#010;+                        if (value != null) {&#010;+                            // its an enum so strip out "" and trim spaces after comma&#010;+                            value = value.replaceAll(""\"""", """");&#010;+                            value = value.replaceAll("", "", "","");&#010;+                            value = value.trim();&#010;+                        }&#010;+                    }&#010;+                    if (value == null) {&#010;+                        // not text then its maybe a boolean?&#010;+                        value = matcher.group(3);&#010;+                    }&#010;+                    if (value == null) {&#010;+                        // not text then its maybe a integer?&#010;+                        value = matcher.group(4);&#010;+                    }&#010;+                    if (value != null) {&#010;+                        row.put(key, value);&#010;+                    }&#010;+                    // reset&#010;+                    key = null;&#010;+                }&#010;+            }&#010;+            if (!row.isEmpty()) {&#010;+                answer.add(row);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    private static String decodeJson(String value) {&#010;+        // json encodes a \ as \\ so we need to decode from \\ back to \&#010;+        if (""\\\\"".equals(value)) {&#010;+            value = ""\\"";&#010;+        }&#010;+        return value;&#010;+    }&#010;+&#010;+    public static boolean isComponentLenientProperties(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""lenientProperties"")) {&#010;+                return ""true"".equals(row.get(""lenientProperties""));&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isComponentConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""consumerOnly"")) {&#010;+                return ""true"".equals(row.get(""consumerOnly""));&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isComponentProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""producerOnly"")) {&#010;+                return ""true"".equals(row.get(""producerOnly""));&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String labels = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""label"")) {&#010;+                labels = row.get(""label"");&#010;+            }&#010;+            if (found) {&#010;+                return labels != null &amp;&amp; labels.contains(""consumer"");&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String labels = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""label"")) {&#010;+                labels = row.get(""label"");&#010;+            }&#010;+            if (found) {&#010;+                return labels != null &amp;&amp; labels.contains(""producer"");&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyRequired(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            boolean required = false;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""required"")) {&#010;+                required = ""true"".equals(row.get(""required""));&#010;+            }&#010;+            if (found) {&#010;+                return required;&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static String getPropertyKind(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String kind = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""kind"")) {&#010;+                kind = row.get(""kind"");&#010;+            }&#010;+            if (found) {&#010;+                return kind;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static boolean isPropertyBoolean(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""boolean"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyInteger(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""integer"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyNumber(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""number"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyObject(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""object"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static String getPropertyDefaultValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String defaultValue = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""defaultValue"")) {&#010;+                defaultValue = row.get(""defaultValue"");&#010;+            }&#010;+            if (found) {&#010;+                return defaultValue;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static String stripOptionalPrefixFromName(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String optionalPrefix = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""optionalPrefix"")) {&#010;+                optionalPrefix = row.get(""optionalPrefix"");&#010;+            }&#010;+            if (row.containsKey(""name"")) {&#010;+                if (optionalPrefix != null &amp;&amp; name.startsWith(optionalPrefix)) {&#010;+                    name = name.substring(optionalPrefix.length());&#010;+                    // try again&#010;+                    return stripOptionalPrefixFromName(rows, name);&#010;+                } else {&#010;+                    found = name.equals(row.get(""name""));&#010;+                }&#010;+            }&#010;+            if (found) {&#010;+                return name;&#010;+            }&#010;+        }&#010;+        return name;&#010;+    }&#010;+&#010;+    public static String getPropertyEnum(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String enums = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""enum"")) {&#010;+                enums = row.get(""enum"");&#010;+            }&#010;+            if (found) {&#010;+                return enums;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static String getPropertyPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String prefix = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""prefix"")) {&#010;+                prefix = row.get(""prefix"");&#010;+            }&#010;+            if (found) {&#010;+                return prefix;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static boolean isPropertyMultiValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            boolean multiValue = false;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""multiValue"")) {&#010;+                multiValue = ""true"".equals(row.get(""multiValue""));&#010;+            }&#010;+            if (found) {&#010;+                return multiValue;&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static String getPropertyNameFromNameWithPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String propertyName = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                propertyName = row.get(""name"");&#010;+            }&#010;+            if (row.containsKey(""prefix"")) {&#010;+                String preifx = row.get(""prefix"");&#010;+                found = name.startsWith(preifx);&#010;+            }&#010;+            if (found) {&#010;+                return propertyName;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static Map&lt;String, String&gt; getRow(List&lt;Map&lt;String, String&gt;&gt; rows, String key) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (key.equals(row.get(""name""))) {&#010;+                return row;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static Set&lt;String&gt; getNames(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        Set&lt;String&gt; answer = new LinkedHashSet&lt;String&gt;();&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""name"")) {&#010;+                answer.add(row.get(""name""));&#010;+            }&#010;+        }&#010;+        return answer;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java&#010;new file mode 100644&#010;index 0000000..dbd6f45&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java&#010;@@ -0,0 +1,64 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+/**&#010;+ * Pluggable resolver to load JSon schema files for components, data formats, languages etc.&#010;+ */&#010;+public interface JSonSchemaResolver {&#010;+&#010;+    /**&#010;+     * Returns the component information as JSon format.&#010;+     *&#010;+     * @param name the component name&#010;+     * @return component details in JSon&#010;+     */&#010;+    String getComponentJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the data format information as JSon format.&#010;+     *&#010;+     * @param name the data format name&#010;+     * @return data format details in JSon&#010;+     */&#010;+    String getDataFormatJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the language information as JSon format.&#010;+     *&#010;+     * @param name the language name&#010;+     * @return language details in JSon&#010;+     */&#010;+    String getLanguageJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the other (miscellaneous) information as JSon format.&#010;+     *&#010;+     * @param name the other (miscellaneous) name&#010;+     * @return other (miscellaneous) details in JSon&#010;+     */&#010;+    String getOtherJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the model information as JSon format.&#010;+     *&#010;+     * @param name the model name&#010;+     * @return model details in JSon&#010;+     */&#010;+    String getModelJSonSchema(String name);&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java&#010;new file mode 100644&#010;index 0000000..dbb5525&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java&#010;@@ -0,0 +1,65 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.Serializable;&#010;+&#010;+/**&#010;+ * Validation result of parsing a language expression or predicate&#010;+ */&#010;+public class LanguageValidationResult implements Serializable {&#010;+    private final String text;&#010;+    private String error;&#010;+    private String shortError;&#010;+    private int index;&#010;+&#010;+    public LanguageValidationResult(String text) {&#010;+        this.text = text;&#010;+    }&#010;+&#010;+    public String getText() {&#010;+        return text;&#010;+    }&#010;+&#010;+    public boolean isSuccess() {&#010;+        return error == null;&#010;+    }&#010;+&#010;+    public void setError(String error) {&#010;+        this.error = error;&#010;+    }&#010;+&#010;+    public String getError() {&#010;+        return error;&#010;+    }&#010;+&#010;+    public String getShortError() {&#010;+        return shortError;&#010;+    }&#010;+&#010;+    public void setShortError(String shortError) {&#010;+        this.shortError = shortError;&#010;+    }&#010;+&#010;+    public int getIndex() {&#010;+        return index;&#010;+    }&#010;+&#010;+    public void setIndex(int index) {&#010;+        this.index = index;&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java&#010;new file mode 100644&#010;index 0000000..86c4b53&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java&#010;@@ -0,0 +1,234 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.net.URISyntaxException;&#010;+import java.util.Map;&#010;+&#010;+import org.apache.camel.StaticService;&#010;+&#010;+/**&#010;+ * Runtime based CamelCatalog which are included in camel-core that can provided limit CamelCatalog capabilities&#010;+ */&#010;+public interface RuntimeCamelCatalog extends StaticService {&#010;+&#010;+    /**&#010;+     * Returns the component information as JSon format.&#010;+     *&#010;+     * @param name the component name&#010;+     * @return component details in JSon&#010;+     */&#010;+    String componentJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the data format information as JSon format.&#010;+     *&#010;+     * @param name the data format name&#010;+     * @return data format details in JSon&#010;+     */&#010;+    String dataFormatJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the language information as JSon format.&#010;+     *&#010;+     * @param name the language name&#010;+     * @return language details in JSon&#010;+     */&#010;+    String languageJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the model information as JSon format.&#010;+     *&#010;+     * @param name the model name&#010;+     * @return model details in JSon&#010;+     */&#010;+    String modelJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Parses the endpoint uri and constructs a key/value properties of each option&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return properties as key value pairs of each endpoint option&#010;+     */&#010;+    Map&lt;String, String&gt; endpointProperties(String uri) throws URISyntaxException;&#010;+&#010;+    /**&#010;+     * Parses the endpoint uri and constructs a key/value properties of only the lenient properties (eg custom options)&#010;+     * &lt;p/&gt;&#010;+     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return properties as key value pairs of each lenient properties&#010;+     */&#010;+    Map&lt;String, String&gt; endpointLenientProperties(String uri) throws URISyntaxException;&#010;+&#010;+    /**&#010;+     * Validates the pattern whether its a valid time pattern.&#010;+     *&#010;+     * @param pattern  the pattern such as 5000, 5s, 5sec, 4min, 4m30s, 1h, etc.&#010;+     * @return &lt;tt&gt;true&lt;/tt&gt; if valid, &lt;tt&gt;false&lt;/tt&gt; if invalid&#010;+     */&#010;+    boolean validateTimePattern(String pattern);&#010;+&#010;+    /**&#010;+     * Validates the properties for the given scheme against component and endpoint&#010;+     *&#010;+     * @param scheme  the endpoint scheme&#010;+     * @param properties  the endpoint properties&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateProperties(String scheme, Map&lt;String, String&gt; properties);&#010;+&#010;+    /**&#010;+     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateEndpointProperties(String uri);&#010;+&#010;+    /**&#010;+     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;+     * &lt;p/&gt;&#010;+     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;+     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;+     * but in the uri because of using lenient properties.&#010;+     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties);&#010;+&#010;+    /**&#010;+     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;+     * &lt;p/&gt;&#010;+     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;+     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;+     * but in the uri because of using lenient properties.&#010;+     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;+     * @param consumerOnly whether the endpoint is only used as a consumer&#010;+     * @param producerOnly whether the endpoint is only used as a producer&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties, boolean consumerOnly, boolean producerOnly);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple expression.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param simple  the simple expression&#010;+     * @return validation result&#010;+     * @deprecated use {@link #validateSimpleExpression(ClassLoader, String)}&#010;+     */&#010;+    @Deprecated&#010;+    SimpleValidationResult validateSimpleExpression(String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple expression.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param simple  the simple expression&#010;+     * @return validation result&#010;+     */&#010;+    SimpleValidationResult validateSimpleExpression(ClassLoader classLoader, String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple predicate&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param simple  the simple predicate&#010;+     * @return validation result&#010;+     * @deprecated use {@link #validateSimplePredicate(ClassLoader, String)}&#010;+     */&#010;+    @Deprecated&#010;+    SimpleValidationResult validateSimplePredicate(String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple predicate&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param simple  the simple predicate&#010;+     * @return validation result&#010;+     */&#010;+    SimpleValidationResult validateSimplePredicate(ClassLoader classLoader, String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the language as a predicate&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param language the name of the language&#010;+     * @param text  the predicate text&#010;+     * @return validation result&#010;+     */&#010;+    LanguageValidationResult validateLanguagePredicate(ClassLoader classLoader, String language, String text);&#010;+&#010;+    /**&#010;+     * Parses and validates the language as an expression&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param language the name of the language&#010;+     * @param text  the expression text&#010;+     * @return validation result&#010;+     */&#010;+    LanguageValidationResult validateLanguageExpression(ClassLoader classLoader, String language, String text);&#010;+&#010;+    /**&#010;+     * Returns the component name from the given endpoint uri&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return the component name (aka scheme), or &lt;tt&gt;null&lt;/tt&gt; if not possible to determine&#010;+     */&#010;+    String endpointComponentName(String uri);&#010;+&#010;+    /**&#010;+     * Creates an endpoint uri in Java style from the information from the properties&#010;+     *&#010;+     * @param scheme the endpoint schema&#010;+     * @param properties the properties as key value pairs&#010;+     * @param encode whether to URL encode the returned uri or not&#010;+     * @return the constructed endpoint uri&#010;+     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;+     */&#010;+    String asEndpointUri(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;+&#010;+    /**&#010;+     * Creates an endpoint uri in XML style (eg escape &amp; as &amp;ampl;) from the information from the properties&#010;+     *&#010;+     * @param scheme the endpoint schema&#010;+     * @param properties the properties as key value pairs&#010;+     * @param encode whether to URL encode the returned uri or not&#010;+     * @return the constructed endpoint uri&#010;+     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;+     */&#010;+    String asEndpointUriXml(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java&#010;new file mode 100644&#010;index 0000000..1b8dd0e&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java&#010;@@ -0,0 +1,32 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+/**&#010;+ * To be backwards compatible, but favor using {@link LanguageValidationResult} instead.&#010;+ */&#010;+public class SimpleValidationResult extends LanguageValidationResult {&#010;+&#010;+    public SimpleValidationResult(String text) {&#010;+        super(text);&#010;+    }&#010;+&#010;+    public String getSimple() {&#010;+        return getText();&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java&#010;new file mode 100644&#010;index 0000000..e29afc6&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java&#010;@@ -0,0 +1,34 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.Set;&#010;+&#010;+/**&#010;+ * Strategy to provide suggestions for unknown endpoint options&#010;+ */&#010;+public interface SuggestionStrategy {&#010;+&#010;+    /**&#010;+     * Provides a list of valid option names for a did you mean function.&#010;+     *&#010;+     * @param names         valid names&#010;+     * @param unknownOption unknown option name&#010;+     * @return a list of suggested names (did you mean)&#010;+     */&#010;+    String[] suggestEndpointOptions(Set&lt;String&gt; names, String unknownOption);&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java&#010;new file mode 100644&#010;index 0000000..ed5585c&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java&#010;@@ -0,0 +1,120 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+/**&#010;+ * This class is a copy from camel-core so we can use it independent to validate uris with time patterns&#010;+ */&#010;+public final class TimePatternConverter {&#010;+    private static final Pattern NUMBERS_ONLY_STRING_PATTERN = Pattern.compile(""^[-]?(\\d)+$"", Pattern.CASE_INSENSITIVE);&#010;+    private static final Pattern HOUR_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))h(our(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;+    private static final Pattern MINUTES_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))m(in(ute(s)?)?)?"", Pattern.CASE_INSENSITIVE);&#010;+    private static final Pattern SECONDS_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))s(ec(ond)?(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;+&#010;+    /**&#010;+     * Utility classes should not have a public constructor.&#010;+     */&#010;+    private TimePatternConverter() {&#010;+    }&#010;+&#010;+    public static long toMilliSeconds(String source) throws IllegalArgumentException {&#010;+        long milliseconds = 0;&#010;+        boolean foundFlag = false;&#010;+&#010;+        checkCorrectnessOfPattern(source);&#010;+        Matcher matcher;&#010;+&#010;+        matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;+        if (matcher.find()) {&#010;+            // Note: This will also be used for regular numeric strings.&#010;+            //       This String -&gt; long converter will be used for all strings.&#010;+            milliseconds = Long.valueOf(source);&#010;+        } else {&#010;+            matcher = createMatcher(HOUR_REGEX_PATTERN, source);&#010;+            if (matcher.find()) {&#010;+                milliseconds = milliseconds + (3600000 * Long.valueOf(matcher.group(1)));&#010;+                foundFlag = true;&#010;+            }&#010;+&#010;+            matcher = createMatcher(MINUTES_REGEX_PATTERN, source);&#010;+            if (matcher.find()) {&#010;+                long minutes = Long.valueOf(matcher.group(1));&#010;+                if ((minutes &gt; 59) &amp;&amp; foundFlag) {&#010;+                    throw new IllegalArgumentException(""Minutes should contain a valid value between 0 and 59: "" + source);&#010;+                }&#010;+                foundFlag = true;&#010;+                milliseconds = milliseconds + (60000 * minutes);&#010;+            }&#010;+&#010;+            matcher = createMatcher(SECONDS_REGEX_PATTERN, source);&#010;+            if (matcher.find()) {&#010;+                long seconds = Long.valueOf(matcher.group(1));&#010;+                if ((seconds &gt; 59) &amp;&amp; foundFlag) {&#010;+                    throw new IllegalArgumentException(""Seconds should contain a valid value between 0 and 59: "" + source);&#010;+                }&#010;+                foundFlag = true;&#010;+                milliseconds = milliseconds + (1000 * seconds);&#010;+            }&#010;+&#010;+            // No pattern matched... initiating fallback check and conversion (if required).&#010;+            // The source at this point may contain illegal values or special characters&#010;+            if (!foundFlag) {&#010;+                milliseconds = Long.valueOf(source);&#010;+            }&#010;+        }&#010;+&#010;+        return milliseconds;&#010;+    }&#010;+&#010;+    private static void checkCorrectnessOfPattern(String source) {&#010;+        //replace only numbers once&#010;+        Matcher matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;+        String replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        //replace hour string once&#010;+        matcher = createMatcher(HOUR_REGEX_PATTERN, replaceSource);&#010;+        if (matcher.find() &amp;&amp; matcher.find()) {&#010;+            throw new IllegalArgumentException(""Hours should not be specified more then once: "" + source);&#010;+        }&#010;+        replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        //replace minutes once&#010;+        matcher = createMatcher(MINUTES_REGEX_PATTERN, replaceSource);&#010;+        if (matcher.find() &amp;&amp; matcher.find()) {&#010;+            throw new IllegalArgumentException(""Minutes should not be specified more then once: "" + source);&#010;+        }&#010;+        replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        //replace seconds once&#010;+        matcher = createMatcher(SECONDS_REGEX_PATTERN, replaceSource);&#010;+        if (matcher.find() &amp;&amp; matcher.find()) {&#010;+            throw new IllegalArgumentException(""Seconds should not be specified more then once: "" + source);&#010;+        }&#010;+        replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        if (replaceSource.length() &gt; 0) {&#010;+            throw new IllegalArgumentException(""Illegal characters: "" + source);&#010;+        }&#010;+    }&#010;+&#010;+    private static Matcher createMatcher(Pattern pattern, String source) {&#010;+        return pattern.matcher(source);&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java&#010;new file mode 100644&#010;index 0000000..8389590&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java&#010;@@ -0,0 +1,392 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.UnsupportedEncodingException;&#010;+import java.net.URI;&#010;+import java.net.URISyntaxException;&#010;+import java.net.URLDecoder;&#010;+import java.net.URLEncoder;&#010;+import java.util.ArrayList;&#010;+import java.util.Iterator;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+&#010;+/**&#010;+ * Copied from org.apache.camel.util.URISupport&#010;+ */&#010;+public final class URISupport {&#010;+&#010;+    public static final String RAW_TOKEN_START = ""RAW("";&#010;+    public static final String RAW_TOKEN_END = "")"";&#010;+&#010;+    private static final String CHARSET = ""UTF-8"";&#010;+&#010;+    private URISupport() {&#010;+        // Helper class&#010;+    }&#010;+&#010;+    /**&#010;+     * Normalizes the URI so unsafe characters is encoded&#010;+     *&#010;+     * @param uri the input uri&#010;+     * @return as URI instance&#010;+     * @throws URISyntaxException is thrown if syntax error in the input uri&#010;+     */&#010;+    public static URI normalizeUri(String uri) throws URISyntaxException {&#010;+        return new URI(UnsafeUriCharactersEncoder.encode(uri, true));&#010;+    }&#010;+&#010;+    public static Map&lt;String, Object&gt; extractProperties(Map&lt;String, Object&gt; properties, String optionPrefix) {&#010;+        Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;(properties.size());&#010;+&#010;+        for (Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; it = properties.entrySet().iterator(); it.hasNext();) {&#010;+            Map.Entry&lt;String, Object&gt; entry = it.next();&#010;+            String name = entry.getKey();&#010;+            if (name.startsWith(optionPrefix)) {&#010;+                Object value = properties.get(name);&#010;+                name = name.substring(optionPrefix.length());&#010;+                rc.put(name, value);&#010;+                it.remove();&#010;+            }&#010;+        }&#010;+&#010;+        return rc;&#010;+    }&#010;+&#010;+    /**&#010;+     * Strips the query parameters from the uri&#010;+     *&#010;+     * @param uri  the uri&#010;+     * @return the uri without the query parameter&#010;+     */&#010;+    public static String stripQuery(String uri) {&#010;+        int idx = uri.indexOf('?');&#010;+        if (idx &gt; -1) {&#010;+            uri = uri.substring(0, idx);&#010;+        }&#010;+        return uri;&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the query parameters of the uri (eg the query part).&#010;+     *&#010;+     * @param uri the uri&#010;+     * @return the parameters, or an empty map if no parameters (eg never null)&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     */&#010;+    public static Map&lt;String, Object&gt; parseParameters(URI uri) throws URISyntaxException {&#010;+        String query = uri.getQuery();&#010;+        if (query == null) {&#010;+            String schemeSpecificPart = uri.getSchemeSpecificPart();&#010;+            int idx = schemeSpecificPart.indexOf('?');&#010;+            if (idx &lt; 0) {&#010;+                // return an empty map&#010;+                return new LinkedHashMap&lt;String, Object&gt;(0);&#010;+            } else {&#010;+                query = schemeSpecificPart.substring(idx + 1);&#010;+            }&#010;+        } else {&#010;+            query = stripPrefix(query, ""?"");&#010;+        }&#010;+        return parseQuery(query);&#010;+    }&#010;+&#010;+    /**&#010;+     * Strips the prefix from the value.&#010;+     * &lt;p/&gt;&#010;+     * Returns the value as-is if not starting with the prefix.&#010;+     *&#010;+     * @param value  the value&#010;+     * @param prefix the prefix to remove from value&#010;+     * @return the value without the prefix&#010;+     */&#010;+    public static String stripPrefix(String value, String prefix) {&#010;+        if (value != null &amp;&amp; value.startsWith(prefix)) {&#010;+            return value.substring(prefix.length());&#010;+        }&#010;+        return value;&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the query part of the uri (eg the parameters).&#010;+     * &lt;p/&gt;&#010;+     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;+     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;+     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;+     *&#010;+     * @param uri the uri&#010;+     * @return the parameters, or an empty map if no parameters (eg never null)&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     * @see #RAW_TOKEN_START&#010;+     * @see #RAW_TOKEN_END&#010;+     */&#010;+    public static Map&lt;String, Object&gt; parseQuery(String uri) throws URISyntaxException {&#010;+        return parseQuery(uri, false);&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the query part of the uri (eg the parameters).&#010;+     * &lt;p/&gt;&#010;+     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;+     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;+     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;+     *&#010;+     * @param uri the uri&#010;+     * @param useRaw whether to force using raw values&#010;+     * @return the parameters, or an empty map if no parameters (eg never null)&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     * @see #RAW_TOKEN_START&#010;+     * @see #RAW_TOKEN_END&#010;+     */&#010;+    public static Map&lt;String, Object&gt; parseQuery(String uri, boolean useRaw) throws URISyntaxException {&#010;+        // must check for trailing &amp; as the uri.split(""&amp;"") will ignore those&#010;+        if (uri != null &amp;&amp; uri.endsWith(""&amp;"")) {&#010;+            throw new URISyntaxException(uri, ""Invalid uri syntax: Trailing &amp; marker found. ""&#010;+                    + ""Check the uri and remove the trailing &amp; marker."");&#010;+        }&#010;+&#010;+        if (isEmpty(uri)) {&#010;+            // return an empty map&#010;+            return new LinkedHashMap&lt;String, Object&gt;(0);&#010;+        }&#010;+&#010;+        // need to parse the uri query parameters manually as we cannot rely on splitting by &amp;,&#010;+        // as &amp; can be used in a parameter value as well.&#010;+&#010;+        try {&#010;+            // use a linked map so the parameters is in the same order&#010;+            Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;();&#010;+&#010;+            boolean isKey = true;&#010;+            boolean isValue = false;&#010;+            boolean isRaw = false;&#010;+            StringBuilder key = new StringBuilder();&#010;+            StringBuilder value = new StringBuilder();&#010;+&#010;+            // parse the uri parameters char by char&#010;+            for (int i = 0; i &lt; uri.length(); i++) {&#010;+                // current char&#010;+                char ch = uri.charAt(i);&#010;+                // look ahead of the next char&#010;+                char next;&#010;+                if (i &lt;= uri.length() - 2) {&#010;+                    next = uri.charAt(i + 1);&#010;+                } else {&#010;+                    next = '\u0000';&#010;+                }&#010;+&#010;+                // are we a raw value&#010;+                isRaw = value.toString().startsWith(RAW_TOKEN_START);&#010;+&#010;+                // if we are in raw mode, then we keep adding until we hit the end marker&#010;+                if (isRaw) {&#010;+                    if (isKey) {&#010;+                        key.append(ch);&#010;+                    } else if (isValue) {&#010;+                        value.append(ch);&#010;+                    }&#010;+&#010;+                    // we only end the raw marker if its )&amp; or at the end of the value&#010;+&#010;+                    boolean end = ch == RAW_TOKEN_END.charAt(0) &amp;&amp; (next == '&amp;' || next == '\u0000');&#010;+                    if (end) {&#010;+                        // raw value end, so add that as a parameter, and reset flags&#010;+                        addParameter(key.toString(), value.toString(), rc, useRaw || isRaw);&#010;+                        key.setLength(0);&#010;+                        value.setLength(0);&#010;+                        isKey = true;&#010;+                        isValue = false;&#010;+                        isRaw = false;&#010;+                        // skip to next as we are in raw mode and have already added the value&#010;+                        i++;&#010;+                    }&#010;+                    continue;&#010;+                }&#010;+&#010;+                // if its a key and there is a = sign then the key ends and we are in value mode&#010;+                if (isKey &amp;&amp; ch == '=') {&#010;+                    isKey = false;&#010;+                    isValue = true;&#010;+                    isRaw = false;&#010;+                    continue;&#010;+                }&#010;+&#010;+                // the &amp; denote parameter is ended&#010;+                if (ch == '&amp;') {&#010;+                    // parameter is ended, as we hit &amp; separator&#010;+                    String aKey = key.toString();&#010;+                    // the key may be a placeholder of options which we then do not know what is&#010;+                    boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;+                    if (validKey) {&#010;+                        addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;+                    }&#010;+                    key.setLength(0);&#010;+                    value.setLength(0);&#010;+                    isKey = true;&#010;+                    isValue = false;&#010;+                    isRaw = false;&#010;+                    continue;&#010;+                }&#010;+&#010;+                // regular char so add it to the key or value&#010;+                if (isKey) {&#010;+                    key.append(ch);&#010;+                } else if (isValue) {&#010;+                    value.append(ch);&#010;+                }&#010;+            }&#010;+&#010;+            // any left over parameters, then add that&#010;+            if (key.length() &gt; 0) {&#010;+                String aKey = key.toString();&#010;+                // the key may be a placeholder of options which we then do not know what is&#010;+                boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;+                if (validKey) {&#010;+                    addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;+                }&#010;+            }&#010;+&#010;+            return rc;&#010;+&#010;+        } catch (UnsupportedEncodingException e) {&#010;+            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;+            se.initCause(e);&#010;+            throw se;&#010;+        }&#010;+    }&#010;+&#010;+    @SuppressWarnings(""unchecked"")&#010;+    private static void addParameter(String name, String value, Map&lt;String, Object&gt; map, boolean isRaw) throws UnsupportedEncodingException {&#010;+        name = URLDecoder.decode(name, CHARSET);&#010;+        if (!isRaw) {&#010;+            // need to replace % with %25&#010;+            value = URLDecoder.decode(value.replaceAll(""%"", ""%25""), CHARSET);&#010;+        }&#010;+&#010;+        // does the key already exist?&#010;+        if (map.containsKey(name)) {&#010;+            // yes it does, so make sure we can support multiple values, but using a list&#010;+            // to hold the multiple values&#010;+            Object existing = map.get(name);&#010;+            List&lt;String&gt; list;&#010;+            if (existing instanceof List) {&#010;+                list = (List&lt;String&gt;) existing;&#010;+            } else {&#010;+                // create a new list to hold the multiple values&#010;+                list = new ArrayList&lt;String&gt;();&#010;+                String s = existing != null ? existing.toString() : null;&#010;+                if (s != null) {&#010;+                    list.add(s);&#010;+                }&#010;+            }&#010;+            list.add(value);&#010;+            map.put(name, list);&#010;+        } else {&#010;+            map.put(name, value);&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Assembles a query from the given map.&#010;+     *&#010;+     * @param options  the map with the options (eg key/value pairs)&#010;+     * @param ampersand to use &amp; for Java code, and &amp;amp; for XML&#010;+     * @return a query string with &lt;tt&gt;key1=value&amp;key2=value2&amp;...&lt;/tt&gt;, or an empty string if there is no options.&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     */&#010;+    public static String createQueryString(Map&lt;String, String&gt; options, String ampersand, boolean encode) throws URISyntaxException {&#010;+        try {&#010;+            if (options.size() &gt; 0) {&#010;+                StringBuilder rc = new StringBuilder();&#010;+                boolean first = true;&#010;+                for (Object o : options.keySet()) {&#010;+                    if (first) {&#010;+                        first = false;&#010;+                    } else {&#010;+                        rc.append(ampersand);&#010;+                    }&#010;+&#010;+                    String key = (String) o;&#010;+                    Object value = options.get(key);&#010;+&#010;+                    // use the value as a String&#010;+                    String s = value != null ? value.toString() : null;&#010;+                    appendQueryStringParameter(key, s, rc, encode);&#010;+                }&#010;+                return rc.toString();&#010;+            } else {&#010;+                return """";&#010;+            }&#010;+        } catch (UnsupportedEncodingException e) {&#010;+            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;+            se.initCause(e);&#010;+            throw se;&#010;+        }&#010;+    }&#010;+&#010;+    private static void appendQueryStringParameter(String key, String value, StringBuilder rc, boolean encode) throws UnsupportedEncodingException {&#010;+        if (encode) {&#010;+            rc.append(URLEncoder.encode(key, CHARSET));&#010;+        } else {&#010;+            rc.append(key);&#010;+        }&#010;+        // only append if value is not null&#010;+        if (value != null) {&#010;+            rc.append(""="");&#010;+            if (value.startsWith(RAW_TOKEN_START) &amp;&amp; value.endsWith(RAW_TOKEN_END)) {&#010;+                // do not encode RAW parameters&#010;+                rc.append(value);&#010;+            } else {&#010;+                if (encode) {&#010;+                    rc.append(URLEncoder.encode(value, CHARSET));&#010;+                } else {&#010;+                    rc.append(value);&#010;+                }&#010;+            }&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if empty&#010;+     */&#010;+    public static boolean isEmpty(Object value) {&#010;+        return !isNotEmpty(value);&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;b&gt;not&lt;/b&gt; &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if &lt;b&gt;not&lt;/b&gt; empty&#010;+     */&#010;+    public static boolean isNotEmpty(Object value) {&#010;+        if (value == null) {&#010;+            return false;&#010;+        } else if (value instanceof String) {&#010;+            String text = (String) value;&#010;+            return text.trim().length() &gt; 0;&#010;+        } else {&#010;+            return true;&#010;+        }&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java&#010;new file mode 100644&#010;index 0000000..a11c810&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java&#010;@@ -0,0 +1,206 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.ArrayList;&#010;+import java.util.BitSet;&#010;+import java.util.List;&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+/**&#010;+ * Encoder for unsafe URI characters.&#010;+ * &lt;p/&gt;&#010;+ * A good source for details is &lt;a href=""http://en.wikipedia.org/wiki/Url_encode""&gt;wikipedia url encode&lt;/a&gt; article.&#010;+ */&#010;+public final class UnsafeUriCharactersEncoder {&#010;+    private static BitSet unsafeCharactersRfc1738;&#010;+    private static BitSet unsafeCharactersHttp;&#010;+    private static final char[] HEX_DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C',&#010;+        'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'};&#010;+    private static final Pattern RAW_PATTERN = Pattern.compile(""RAW\\([^\\)]+\\)"");&#010;+&#010;+    static {&#010;+        unsafeCharactersRfc1738 = new BitSet(256);&#010;+        unsafeCharactersRfc1738.set(' ');&#010;+        unsafeCharactersRfc1738.set('""');&#010;+        unsafeCharactersRfc1738.set('&lt;');&#010;+        unsafeCharactersRfc1738.set('&gt;');&#010;+        unsafeCharactersRfc1738.set('#');&#010;+        unsafeCharactersRfc1738.set('%');&#010;+        unsafeCharactersRfc1738.set('{');&#010;+        unsafeCharactersRfc1738.set('}');&#010;+        unsafeCharactersRfc1738.set('|');&#010;+        unsafeCharactersRfc1738.set('\\');&#010;+        unsafeCharactersRfc1738.set('^');&#010;+        unsafeCharactersRfc1738.set('~');&#010;+        unsafeCharactersRfc1738.set('[');&#010;+        unsafeCharactersRfc1738.set(']');&#010;+        unsafeCharactersRfc1738.set('`');&#010;+    }&#010;+&#010;+    static {&#010;+        unsafeCharactersHttp = new BitSet(256);&#010;+        unsafeCharactersHttp.set(' ');&#010;+        unsafeCharactersHttp.set('""');&#010;+        unsafeCharactersHttp.set('&lt;');&#010;+        unsafeCharactersHttp.set('&gt;');&#010;+        unsafeCharactersHttp.set('#');&#010;+        unsafeCharactersHttp.set('%');&#010;+        unsafeCharactersHttp.set('{');&#010;+        unsafeCharactersHttp.set('}');&#010;+        unsafeCharactersHttp.set('|');&#010;+        unsafeCharactersHttp.set('\\');&#010;+        unsafeCharactersHttp.set('^');&#010;+        unsafeCharactersHttp.set('~');&#010;+        unsafeCharactersHttp.set('`');&#010;+    }&#010;+&#010;+    private UnsafeUriCharactersEncoder() {&#010;+        // util class&#010;+    }&#010;+&#010;+    public static String encode(String s) {&#010;+        return encode(s, unsafeCharactersRfc1738);&#010;+    }&#010;+&#010;+    public static String encodeHttpURI(String s) {&#010;+        return encode(s, unsafeCharactersHttp);&#010;+    }&#010;+&#010;+    public static String encode(String s, BitSet unsafeCharacters) {&#010;+        return encode(s, unsafeCharacters, false);&#010;+    }&#010;+&#010;+    public static String encode(String s, boolean checkRaw) {&#010;+        return encode(s, unsafeCharactersRfc1738, checkRaw);&#010;+    }&#010;+&#010;+    public static String encodeHttpURI(String s, boolean checkRaw) {&#010;+        return encode(s, unsafeCharactersHttp, checkRaw);&#010;+    }&#010;+&#010;+    private static List&lt;Pair&gt; checkRAW(String s) {&#010;+        Matcher matcher = RAW_PATTERN.matcher(s);&#010;+        List&lt;Pair&gt; answer = new ArrayList&lt;Pair&gt;();&#010;+        // Check all occurrences&#010;+        while (matcher.find()) {&#010;+            answer.add(new Pair(matcher.start(), matcher.end()));&#010;+        }&#010;+        return answer;&#010;+    }&#010;+&#010;+    private static boolean isRaw(int index, List&lt;Pair&gt; pairs) {&#010;+        for (Pair pair : pairs) {&#010;+            if (index &lt; pair.left) {&#010;+                return false;&#010;+            } else {&#010;+                if (index &gt;= pair.left) {&#010;+                    if (index &lt;= pair.right) {&#010;+                        return true;&#010;+                    } else {&#010;+                        continue;&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    private static class Pair {&#010;+        int left;&#010;+        int right;&#010;+&#010;+        Pair(int left, int right) {&#010;+            this.left = left;&#010;+            this.right = right;&#010;+        }&#010;+    }&#010;+&#010;+    // Just skip the encode for isRAW part&#010;+    public static String encode(String s, BitSet unsafeCharacters, boolean checkRaw) {&#010;+        List&lt;Pair&gt; rawPairs;&#010;+        if (checkRaw) {&#010;+            rawPairs = checkRAW(s);&#010;+        } else {&#010;+            rawPairs = new ArrayList&lt;Pair&gt;();&#010;+        }&#010;+&#010;+        int n = s == null ? 0 : s.length();&#010;+        if (n == 0) {&#010;+            return s;&#010;+        }&#010;+&#010;+        // First check whether we actually need to encode&#010;+        char chars[] = s.toCharArray();&#010;+        for (int i = 0;;) {&#010;+            // just deal with the ascii character&#010;+            if (chars[i] &gt; 0 &amp;&amp; chars[i] &lt; 128) {&#010;+                if (unsafeCharacters.get(chars[i])) {&#010;+                    break;&#010;+                }&#010;+            }&#010;+            if (++i &gt;= chars.length) {&#010;+                return s;&#010;+            }&#010;+        }&#010;+&#010;+        // okay there are some unsafe characters so we do need to encode&#010;+        // see details at: http://en.wikipedia.org/wiki/Url_encode&#010;+        StringBuilder sb = new StringBuilder();&#010;+        for (int i = 0; i &lt; chars.length; i++) {&#010;+            char ch = chars[i];&#010;+            if (ch &gt; 0 &amp;&amp; ch &lt; 128 &amp;&amp; unsafeCharacters.get(ch)) {&#010;+                // special for % sign as it may be a decimal encoded value&#010;+                if (ch == '%') {&#010;+                    char next = i + 1 &lt; chars.length ? chars[i + 1] : ' ';&#010;+                    char next2 = i + 2 &lt; chars.length ? chars[i + 2] : ' ';&#010;+&#010;+                    if (isHexDigit(next) &amp;&amp; isHexDigit(next2) &amp;&amp; !isRaw(i, rawPairs)) {&#010;+                        // its already encoded (decimal encoded) so just append as is&#010;+                        sb.append(ch);&#010;+                    } else {&#010;+                        // must escape then, as its an unsafe character&#010;+                        appendEscape(sb, (byte) ch);&#010;+                    }&#010;+                } else {&#010;+                    // must escape then, as its an unsafe character&#010;+                    appendEscape(sb, (byte) ch);&#010;+                }&#010;+            } else {&#010;+                sb.append(ch);&#010;+            }&#010;+        }&#010;+        return sb.toString();&#010;+    }&#010;+&#010;+    private static void appendEscape(StringBuilder sb, byte b) {&#010;+        sb.append('%');&#010;+        sb.append(HEX_DIGITS[(b &gt;&gt; 4) &amp; 0x0f]);&#010;+        sb.append(HEX_DIGITS[(b &gt;&gt; 0) &amp; 0x0f]);&#010;+    }&#010;+&#010;+    private static boolean isHexDigit(char ch) {&#010;+        for (char hex : HEX_DIGITS) {&#010;+            if (hex == ch) {&#010;+                return true;&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html b/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html&#010;new file mode 100644&#010;index 0000000..2f15a04&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html&#010;@@ -0,0 +1,25 @@&#010;+&lt;!--&#010;+    Licensed to the Apache Software Foundation (ASF) under one or more&#010;+    contributor license agreements.  See the NOTICE file distributed with&#010;+    this work for additional information regarding copyright ownership.&#010;+    The ASF licenses this file to You under the Apache License, Version 2.0&#010;+    (the ""License""); you may not use this file except in compliance with&#010;+    the License.  You may obtain a copy of the License at&#010;+&#010;+    http://www.apache.org/licenses/LICENSE-2.0&#010;+&#010;+    Unless required by applicable law or agreed to in writing, software&#010;+    distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+    See the License for the specific language governing permissions and&#010;+    limitations under the License.&#010;+--&gt;&#010;+&lt;html&gt;&#010;+&lt;head&gt;&#010;+&lt;/head&gt;&#010;+&lt;body&gt;&#010;+&#010;+Runtime Camel Catalog&#010;+&#010;+&lt;/body&gt;&#010;+&lt;/html&gt;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java b/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;index fd22f55..a32c109 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;@@ -37,8 +37,8 @@ import org.apache.camel.PollingConsumer;&#010; import org.apache.camel.Processor;&#010; import org.apache.camel.ResolveEndpointFailedException;&#010; import org.apache.camel.Route;&#010;-import org.apache.camel.catalog.DefaultRuntimeCamelCatalog;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.DefaultRuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.BrowsableEndpoint;&#010; import org.slf4j.Logger;&#010; import org.slf4j.LoggerFactory;&#010;@@ -523,7 +523,7 @@ public final class EndpointHelper {&#010;      * @param uri          the endpoint uri&#010;      * @return a map for each option in the uri with the corresponding information from the json&#010;      * @throws Exception is thrown in case of error&#010;-     * @deprecated use {@link org.apache.camel.catalog.RuntimeCamelCatalog#endpointProperties(String)}&#010;+     * @deprecated use {@link org.apache.camel.runtimecatalog.RuntimeCamelCatalog#endpointProperties(String)}&#010;      */&#010;     @Deprecated&#010;     public static Map&lt;String, Object&gt; endpointProperties(CamelContext camelContext, String uri) throws Exception {&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java b/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java&#010;deleted file mode 100644&#010;index ed7e997..0000000&#010;--- a/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java&#010;+++ /dev/null&#010;@@ -1,104 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.net.URISyntaxException;&#010;-import java.util.HashMap;&#010;-import java.util.Map;&#010;-&#010;-import org.junit.Before;&#010;-import org.junit.Test;&#010;-&#010;-import static org.easymock.EasyMock.expect;&#010;-import static org.easymock.EasyMock.mock;&#010;-import static org.easymock.EasyMock.replay;&#010;-import static org.junit.Assert.assertEquals;&#010;-&#010;-public class AbstractCamelCatalogTest {&#010;-&#010;-    AbstractCamelCatalog catalog = new AbstractCamelCatalog() {&#010;-    };&#010;-&#010;-    JSonSchemaResolver resolver;&#010;-&#010;-    @Before&#010;-    public void setupMockCatalog() {&#010;-        resolver = mock(JSonSchemaResolver.class);&#010;-&#010;-        catalog.setJSonSchemaResolver(resolver);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void shouldConstructEndpointUris() throws URISyntaxException {&#010;-        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;-            + ""  \""component\"": {\n""//&#010;-            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;-            + ""  }\n""//&#010;-            + ""}"");&#010;-&#010;-        replay(resolver);&#010;-&#010;-        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;-        properties.put(""param1"", ""value1"");&#010;-        properties.put(""param2"", ""value2"");&#010;-        properties.put(""param3"", ""value3"");&#010;-&#010;-        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;-&#010;-        assertEquals(""comp:value1:value2?param3=value3"", endpointUri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void shouldConstructEndpointUrisWithPropertyPlaceholders() throws URISyntaxException {&#010;-        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;-            + ""  \""component\"": {\n""//&#010;-            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;-            + ""  }\n""//&#010;-            + ""}"");&#010;-&#010;-        replay(resolver);&#010;-&#010;-        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;-        properties.put(""param1"", ""{{prop1}}"");&#010;-        properties.put(""param2"", ""{{prop2}}"");&#010;-        properties.put(""param3"", ""{{prop3}}"");&#010;-&#010;-        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;-&#010;-        assertEquals(""comp:{{prop1}}:{{prop2}}?param3={{prop3}}"", endpointUri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void shouldConstructEndpointUrisWhenValuesContainTokens() throws URISyntaxException {&#010;-        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;-            + ""  \""component\"": {\n""//&#010;-            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;-            + ""  }\n""//&#010;-            + ""}"");&#010;-&#010;-        replay(resolver);&#010;-&#010;-        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;-        properties.put(""param1"", ""{value1}"");&#010;-        properties.put(""param2"", ""/value2/"");&#010;-        properties.put(""param3"", ""/value3/{param}"");&#010;-&#010;-        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;-&#010;-        assertEquals(""comp:{value1}:/value2/?param3=/value3/{param}"", endpointUri);&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java b/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java&#010;deleted file mode 100644&#010;index 78e51a2..0000000&#010;--- a/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java&#010;+++ /dev/null&#010;@@ -1,393 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.HashMap;&#010;-import java.util.Map;&#010;-&#010;-import org.apache.camel.impl.DefaultCamelContext;&#010;-import org.junit.BeforeClass;&#010;-import org.junit.Test;&#010;-import org.slf4j.Logger;&#010;-import org.slf4j.LoggerFactory;&#010;-&#010;-import static org.junit.Assert.assertEquals;&#010;-import static org.junit.Assert.assertFalse;&#010;-import static org.junit.Assert.assertNotNull;&#010;-import static org.junit.Assert.assertTrue;&#010;-&#010;-public class RuntimeCamelCatalogTest {&#010;-&#010;-    static RuntimeCamelCatalog catalog;&#010;-&#010;-    private static final Logger LOG = LoggerFactory.getLogger(RuntimeCamelCatalogTest.class);&#010;-&#010;-    @BeforeClass&#010;-    public static void createCamelCatalog() {&#010;-        catalog = new DefaultRuntimeCamelCatalog(new DefaultCamelContext());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testFromCamelContext() throws Exception {&#010;-        String schema = new DefaultCamelContext().getRuntimeCamelCatalog().modelJSonSchema(""choice"");&#010;-        assertNotNull(schema);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testJsonSchema() throws Exception {&#010;-        String schema = catalog.modelJSonSchema(""aggregate"");&#010;-        assertNotNull(schema);&#010;-&#010;-        // lets make it possible to find bean/method using both names&#010;-        schema = catalog.modelJSonSchema(""method"");&#010;-        assertNotNull(schema);&#010;-        schema = catalog.modelJSonSchema(""bean"");&#010;-        assertNotNull(schema);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriMapFile() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""directoryName"", ""src/data/inbox"");&#010;-        map.put(""noop"", ""true"");&#010;-        map.put(""delay"", ""5000"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""file"", map, true);&#010;-        assertEquals(""file:src/data/inbox?delay=5000&amp;noop=true"", uri);&#010;-&#010;-        String uri2 = catalog.asEndpointUriXml(""file"", map, true);&#010;-        assertEquals(""file:src/data/inbox?delay=5000&amp;amp;noop=true"", uri2);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriTimer() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""timerName"", ""foo"");&#010;-        map.put(""period"", ""5000"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;-        assertEquals(""timer:foo?period=5000"", uri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriPropertiesPlaceholders() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""timerName"", ""foo"");&#010;-        map.put(""period"", ""{{howoften}}"");&#010;-        map.put(""repeatCount"", ""5"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;-        assertEquals(""timer:foo?period=%7B%7Bhowoften%7D%7D&amp;repeatCount=5"", uri);&#010;-&#010;-        uri = catalog.asEndpointUri(""timer"", map, false);&#010;-        assertEquals(""timer:foo?period={{howoften}}&amp;repeatCount=5"", uri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriBeanLookup() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""resourceUri"", ""foo.xslt"");&#010;-        map.put(""converter"", ""#myConverter"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""xslt"", map, true);&#010;-        assertEquals(""xslt:foo.xslt?converter=%23myConverter"", uri);&#010;-&#010;-        uri = catalog.asEndpointUri(""xslt"", map, false);&#010;-        assertEquals(""xslt:foo.xslt?converter=#myConverter"", uri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testEndpointPropertiesPlaceholders() throws Exception {&#010;-        Map&lt;String, String&gt; map = catalog.endpointProperties(""timer:foo?period={{howoften}}&amp;repeatCount=5"");&#010;-        assertNotNull(map);&#010;-        assertEquals(3, map.size());&#010;-&#010;-        assertEquals(""foo"", map.get(""timerName""));&#010;-        assertEquals(""{{howoften}}"", map.get(""period""));&#010;-        assertEquals(""5"", map.get(""repeatCount""));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriLog() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""loggerName"", ""foo"");&#010;-        map.put(""loggerLevel"", ""WARN"");&#010;-        map.put(""multiline"", ""true"");&#010;-        map.put(""showAll"", ""true"");&#010;-        map.put(""showBody"", ""false"");&#010;-        map.put(""showBodyType"", ""false"");&#010;-        map.put(""showExchangePattern"", ""false"");&#010;-        map.put(""style"", ""Tab"");&#010;-&#010;-        assertEquals(""log:foo?loggerLevel=WARN&amp;multiline=true&amp;showAll=true&amp;style=Tab"", catalog.asEndpointUri(""log"", map, false));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriLogShort() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""loggerName"", ""foo"");&#010;-        map.put(""loggerLevel"", ""DEBUG"");&#010;-&#010;-        assertEquals(""log:foo?loggerLevel=DEBUG"", catalog.asEndpointUri(""log"", map, false));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriWithplaceholder() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""name"", ""foo"");&#010;-        map.put(""blockWhenFull"", ""{{block}}"");&#010;-        assertEquals(""seda:foo?blockWhenFull={{block}}"", catalog.asEndpointUri(""seda"", map, false));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testEndpointPropertiesSedaRequired() throws Exception {&#010;-        Map&lt;String, String&gt; map = catalog.endpointProperties(""seda:foo"");&#010;-        assertNotNull(map);&#010;-        assertEquals(1, map.size());&#010;-&#010;-        assertEquals(""foo"", map.get(""name""));&#010;-&#010;-        map = catalog.endpointProperties(""seda:foo?blockWhenFull=true"");&#010;-        assertNotNull(map);&#010;-        assertEquals(2, map.size());&#010;-&#010;-        assertEquals(""foo"", map.get(""name""));&#010;-        assertEquals(""true"", map.get(""blockWhenFull""));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void validateProperties() throws Exception {&#010;-        // valid&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(""log:mylog"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // unknown&#010;-        result = catalog.validateEndpointProperties(""log:mylog?level=WARN&amp;foo=bar"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getUnknown().contains(""foo""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // enum&#010;-        result = catalog.validateEndpointProperties(""seda:foo?waitForTaskToComplete=blah"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""blah"", result.getInvalidEnum().get(""waitForTaskToComplete""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // reference okay&#010;-        result = catalog.validateEndpointProperties(""seda:foo?queue=#queue"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(0, result.getNumberOfErrors());&#010;-&#010;-        // unknown component&#010;-        result = catalog.validateEndpointProperties(""foo:bar?me=you"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getUnknownComponent().equals(""foo""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // invalid boolean but default value&#010;-        result = catalog.validateEndpointProperties(""log:output?showAll=ggg"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""ggg"", result.getInvalidBoolean().get(""showAll""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // dataset&#010;-        result = catalog.validateEndpointProperties(""dataset:foo?minRate=50"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // time pattern&#010;-        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=true&amp;delay=0&amp;period=2s"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // reference lookup&#010;-        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=#fixed&amp;delay=#myDelay"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // optional consumer. prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?consumer.delay=5000&amp;consumer.greedy=true"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // optional without consumer. prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;greedy=true"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // mixed optional without consumer. prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;consumer.greedy=true"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;scheduler.foo=123&amp;scheduler.bar=456"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // stub&#010;-        result = catalog.validateEndpointProperties(""stub:foo?me=123&amp;you=456"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // lenient on&#010;-        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // lenient off&#010;-        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"", true);&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getUnknown().contains(""foo""));&#010;-&#010;-        // data format&#010;-        result = catalog.validateEndpointProperties(""dataformat:string:marshal?charset=utf-8"", true);&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // incapable to parse&#010;-        result = catalog.validateEndpointProperties(""{{getFtpUrl}}?recursive=true"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getIncapable() != null);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void validatePropertiesSummary() throws Exception {&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(""yammer:MESSAGES?blah=yada&amp;accessToken=aaa&amp;consumerKey=&amp;useJson=no&amp;initialDelay=five&amp;pollStrategy=myStrategy"");&#010;-        assertFalse(result.isSuccess());&#010;-        String reason = result.summaryErrorMessage(true);&#010;-        LOG.info(reason);&#010;-&#010;-        result = catalog.validateEndpointProperties(""jms:unknown:myqueue"");&#010;-        assertFalse(result.isSuccess());&#010;-        reason = result.summaryErrorMessage(false);&#010;-        LOG.info(reason);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void validateTimePattern() throws Exception {&#010;-        assertTrue(catalog.validateTimePattern(""0""));&#010;-        assertTrue(catalog.validateTimePattern(""500""));&#010;-        assertTrue(catalog.validateTimePattern(""10000""));&#010;-        assertTrue(catalog.validateTimePattern(""5s""));&#010;-        assertTrue(catalog.validateTimePattern(""5sec""));&#010;-        assertTrue(catalog.validateTimePattern(""5secs""));&#010;-        assertTrue(catalog.validateTimePattern(""3m""));&#010;-        assertTrue(catalog.validateTimePattern(""3min""));&#010;-        assertTrue(catalog.validateTimePattern(""3minutes""));&#010;-        assertTrue(catalog.validateTimePattern(""5m15s""));&#010;-        assertTrue(catalog.validateTimePattern(""1h""));&#010;-        assertTrue(catalog.validateTimePattern(""1hour""));&#010;-        assertTrue(catalog.validateTimePattern(""2hours""));&#010;-&#010;-        assertFalse(catalog.validateTimePattern(""bla""));&#010;-        assertFalse(catalog.validateTimePattern(""2year""));&#010;-        assertFalse(catalog.validateTimePattern(""60darn""));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testEndpointComponentName() throws Exception {&#010;-        String name = catalog.endpointComponentName(""jms:queue:foo"");&#010;-        assertEquals(""jms"", name);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testSimpleExpression() throws Exception {&#010;-        SimpleValidationResult result = catalog.validateSimpleExpression(null, ""${body}"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body}"", result.getSimple());&#010;-&#010;-        result = catalog.validateSimpleExpression(null, ""${body"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""${body"", result.getSimple());&#010;-        LOG.info(result.getError());&#010;-        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol at location 5""));&#010;-        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;-        assertEquals(5, result.getIndex());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testSimplePredicate() throws Exception {&#010;-        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} == 'abc'"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body} == 'abc'"", result.getSimple());&#010;-&#010;-        result = catalog.validateSimplePredicate(null, ""${body} &gt; ${header.size"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""${body} &gt; ${header.size"", result.getSimple());&#010;-        LOG.info(result.getError());&#010;-        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol at location 22""));&#010;-        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;-        assertEquals(22, result.getIndex());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testSimplePredicatePlaceholder() throws Exception {&#010;-        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} contains '{{danger}}'"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body} contains '{{danger}}'"", result.getSimple());&#010;-&#010;-        result = catalog.validateSimplePredicate(null, ""${bdy} contains '{{danger}}'"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""${bdy} contains '{{danger}}'"", result.getSimple());&#010;-        LOG.info(result.getError());&#010;-        assertTrue(result.getError().startsWith(""Unknown function: bdy at location 0""));&#010;-        assertTrue(result.getError().contains(""'{{danger}}'""));&#010;-        assertEquals(""Unknown function: bdy"", result.getShortError());&#010;-        assertEquals(0, result.getIndex());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testValidateLanguage() throws Exception {&#010;-        LanguageValidationResult result = catalog.validateLanguageExpression(null, ""simple"", ""${body}"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body}"", result.getText());&#010;-&#010;-        result = catalog.validateLanguageExpression(null, ""header"", ""foo"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""foo"", result.getText());&#010;-&#010;-        result = catalog.validateLanguagePredicate(null, ""simple"", ""${body} &gt; 10"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body} &gt; 10"", result.getText());&#010;-&#010;-        result = catalog.validateLanguagePredicate(null, ""header"", ""bar"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""bar"", result.getText());&#010;-&#010;-        result = catalog.validateLanguagePredicate(null, ""foobar"", ""bar"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""Unknown language foobar"", result.getError());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testValidateEndpointConsumerOnly() throws Exception {&#010;-        String uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true"";&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false, true, false);&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true&amp;fileExist=Append"";&#010;-        result = catalog.validateEndpointProperties(uri, false, true, false);&#010;-        assertFalse(result.isSuccess());&#010;-&#010;-        assertEquals(""fileExist"", result.getNotConsumerOnly().iterator().next());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testValidateEndpointProducerOnly() throws Exception {&#010;-        String uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append"";&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false, false, true);&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append&amp;delete=true"";&#010;-        result = catalog.validateEndpointProperties(uri, false, false, true);&#010;-        assertFalse(result.isSuccess());&#010;-&#010;-        assertEquals(""delete"", result.getNotProducerOnly().iterator().next());&#010;-    }&#010;-&#010;-}&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C392ff0b6a5e9466c9cdb499eabbaf550%40git.apache.org%3E,2017-04-14 10:52,commits,3.0,324.0,  [3/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
9,325.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java&#010;new file mode 100644&#010;index 0000000..0420708&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java&#010;@@ -0,0 +1,1294 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.lang.reflect.InvocationTargetException;&#010;+import java.lang.reflect.Method;&#010;+import java.net.URI;&#010;+import java.net.URISyntaxException;&#010;+import java.util.ArrayList;&#010;+import java.util.Arrays;&#010;+import java.util.HashMap;&#010;+import java.util.Iterator;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.LinkedHashSet;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+import java.util.Objects;&#010;+import java.util.Set;&#010;+import java.util.TreeMap;&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+import static org.apache.camel.runtimecatalog.CatalogHelper.after;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getNames;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyDefaultValue;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyEnum;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyKind;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyNameFromNameWithPrefix;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyPrefix;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getRow;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isComponentConsumerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isComponentLenientProperties;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isComponentProducerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyBoolean;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyConsumerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyInteger;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyMultiValue;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyNumber;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyObject;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyProducerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyRequired;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.stripOptionalPrefixFromName;&#010;+import static org.apache.camel.runtimecatalog.URISupport.createQueryString;&#010;+import static org.apache.camel.runtimecatalog.URISupport.isEmpty;&#010;+import static org.apache.camel.runtimecatalog.URISupport.normalizeUri;&#010;+import static org.apache.camel.runtimecatalog.URISupport.stripQuery;&#010;+&#010;+/**&#010;+ * Base class for both the runtime RuntimeCamelCatalog from camel-core and the complete CamelCatalog from camel-catalog.&#010;+ */&#010;+public abstract class AbstractCamelCatalog {&#010;+&#010;+    // CHECKSTYLE:OFF&#010;+&#010;+    private static final Pattern SYNTAX_PATTERN = Pattern.compile(""(\\w+)"");&#010;+&#010;+    private SuggestionStrategy suggestionStrategy;&#010;+    private JSonSchemaResolver jsonSchemaResolver;&#010;+&#010;+    public SuggestionStrategy getSuggestionStrategy() {&#010;+        return suggestionStrategy;&#010;+    }&#010;+&#010;+    public void setSuggestionStrategy(SuggestionStrategy suggestionStrategy) {&#010;+        this.suggestionStrategy = suggestionStrategy;&#010;+    }&#010;+&#010;+    public JSonSchemaResolver getJSonSchemaResolver() {&#010;+        return jsonSchemaResolver;&#010;+    }&#010;+&#010;+    public void setJSonSchemaResolver(JSonSchemaResolver resolver) {&#010;+        this.jsonSchemaResolver = resolver;&#010;+    }&#010;+&#010;+    public boolean validateTimePattern(String pattern) {&#010;+        return validateInteger(pattern);&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateEndpointProperties(String uri) {&#010;+        return validateEndpointProperties(uri, false, false, false);&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties) {&#010;+        return validateEndpointProperties(uri, ignoreLenientProperties, false, false);&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateProperties(String scheme, Map&lt;String, String&gt; properties) {&#010;+        EndpointValidationResult result = new EndpointValidationResult(scheme);&#010;+&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+        List&lt;Map&lt;String, String&gt;&gt; componentProps = JSonSchemaHelper.parseJsonSchema(""componentProperties"", json, true);&#010;+&#010;+        // endpoint options have higher priority so remove those from component&#010;+        // that may clash&#010;+        componentProps.stream()&#010;+            .filter(c -&gt; rows.stream().noneMatch(e -&gt; Objects.equals(e.get(""name""), c.get(""name""))))&#010;+            .forEach(rows::add);&#010;+&#010;+        boolean lenient = Boolean.getBoolean(properties.getOrDefault(""lenient"", ""false""));&#010;+&#010;+        // the dataformat component refers to a data format so lets add the properties for the selected&#010;+        // data format to the list of rows&#010;+        if (""dataformat"".equals(scheme)) {&#010;+            String dfName = properties.get(""name"");&#010;+            if (dfName != null) {&#010;+                String dfJson = jsonSchemaResolver.getDataFormatJSonSchema(dfName);&#010;+                List&lt;Map&lt;String, String&gt;&gt; dfRows = JSonSchemaHelper.parseJsonSchema(""properties"", dfJson, true);&#010;+                if (dfRows != null &amp;&amp; !dfRows.isEmpty()) {&#010;+                    rows.addAll(dfRows);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        for (Map.Entry&lt;String, String&gt; property : properties.entrySet()) {&#010;+            String value = property.getValue();&#010;+            String originalName = property.getKey();&#010;+            String name = property.getKey();&#010;+            // the name may be using an optional prefix, so lets strip that because the options&#010;+            // in the schema are listed without the prefix&#010;+            name = stripOptionalPrefixFromName(rows, name);&#010;+            // the name may be using a prefix, so lets see if we can find the real property name&#010;+            String propertyName = getPropertyNameFromNameWithPrefix(rows, name);&#010;+            if (propertyName != null) {&#010;+                name = propertyName;&#010;+            }&#010;+&#010;+            String prefix = getPropertyPrefix(rows, name);&#010;+            String kind = getPropertyKind(rows, name);&#010;+            boolean namePlaceholder = name.startsWith(""{{"") &amp;&amp; name.endsWith(""}}"");&#010;+            boolean valuePlaceholder = value.startsWith(""{{"") || value.startsWith(""${"") || value.startsWith(""$simple{"");&#010;+            boolean lookup = value.startsWith(""#"") &amp;&amp; value.length() &gt; 1;&#010;+            // we cannot evaluate multi values as strict as the others, as we don't know their expected types&#010;+            boolean multiValue = prefix != null &amp;&amp; originalName.startsWith(prefix) &amp;&amp; isPropertyMultiValue(rows, name);&#010;+&#010;+            Map&lt;String, String&gt; row = getRow(rows, name);&#010;+            if (row == null) {&#010;+                // unknown option&#010;+&#010;+                // only add as error if the component is not lenient properties, or not stub component&#010;+                // and the name is not a property placeholder for one or more values&#010;+                if (!namePlaceholder &amp;&amp; !""stub"".equals(scheme)) {&#010;+                    if (lenient) {&#010;+                        // as if we are lenient then the option is a dynamic extra option which we cannot validate&#010;+                        result.addLenient(name);&#010;+                    } else {&#010;+                        // its unknown&#010;+                        result.addUnknown(name);&#010;+                        if (suggestionStrategy != null) {&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(getNames(rows), name);&#010;+                            if (suggestions != null) {&#010;+                                result.addUnknownSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+                    }&#010;+                }&#010;+            } else {&#010;+                /* TODO: we may need to add something in the properties to know if they are related to a producer or consumer&#010;+                if (""parameter"".equals(kind)) {&#010;+                    // consumer only or producer only mode for parameters&#010;+                    if (consumerOnly) {&#010;+                        boolean producer = isPropertyProducerOnly(rows, name);&#010;+                        if (producer) {&#010;+                            // the option is only for producer so you cannot use it in consumer mode&#010;+                            result.addNotConsumerOnly(name);&#010;+                        }&#010;+                    } else if (producerOnly) {&#010;+                        boolean consumer = isPropertyConsumerOnly(rows, name);&#010;+                        if (consumer) {&#010;+                            // the option is only for consumer so you cannot use it in producer mode&#010;+                            result.addNotProducerOnly(name);&#010;+                        }&#010;+                    }&#010;+                }&#010;+                */&#010;+&#010;+                // default value&#010;+                String defaultValue = getPropertyDefaultValue(rows, name);&#010;+                if (defaultValue != null) {&#010;+                    result.addDefaultValue(name, defaultValue);&#010;+                }&#010;+&#010;+                // is required but the value is empty&#010;+                boolean required = isPropertyRequired(rows, name);&#010;+                if (required &amp;&amp; isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+&#010;+                // is enum but the value is not within the enum range&#010;+                // but we can only check if the value is not a placeholder&#010;+                String enums = getPropertyEnum(rows, name);&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; enums != null) {&#010;+                    String[] choices = enums.split("","");&#010;+                    boolean found = false;&#010;+                    for (String s : choices) {&#010;+                        if (value.equalsIgnoreCase(s)) {&#010;+                            found = true;&#010;+                            break;&#010;+                        }&#010;+                    }&#010;+                    if (!found) {&#010;+                        result.addInvalidEnum(name, value);&#010;+                        result.addInvalidEnumChoices(name, choices);&#010;+                        if (suggestionStrategy != null) {&#010;+                            Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;();&#010;+                            names.addAll(Arrays.asList(choices));&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(names, value);&#010;+                            if (suggestions != null) {&#010;+                                result.addInvalidEnumSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+&#010;+                    }&#010;+                }&#010;+&#010;+                // is reference lookup of bean (not applicable for @UriPath, enums, or multi-valued)&#010;+                if (!multiValue &amp;&amp; enums == null &amp;&amp; !""path"".equals(kind) &amp;&amp; isPropertyObject(rows, name)) {&#010;+                    // must start with # and be at least 2 characters&#010;+                    if (!value.startsWith(""#"") || value.length() &lt;= 1) {&#010;+                        result.addInvalidReference(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is boolean&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyBoolean(rows, name)) {&#010;+                    // value must be a boolean&#010;+                    boolean bool = ""true"".equalsIgnoreCase(value) || ""false"".equalsIgnoreCase(value);&#010;+                    if (!bool) {&#010;+                        result.addInvalidBoolean(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is integer&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyInteger(rows, name)) {&#010;+                    // value must be an integer&#010;+                    boolean valid = validateInteger(value);&#010;+                    if (!valid) {&#010;+                        result.addInvalidInteger(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is number&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyNumber(rows, name)) {&#010;+                    // value must be an number&#010;+                    boolean valid = false;&#010;+                    try {&#010;+                        valid = !Double.valueOf(value).isNaN() || !Float.valueOf(value).isNaN();&#010;+                    } catch (Exception e) {&#010;+                        // ignore&#010;+                    }&#010;+                    if (!valid) {&#010;+                        result.addInvalidNumber(name, value);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // now check if all required values are there, and that a default value does not exists&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String name = row.get(""name"");&#010;+            boolean required = isPropertyRequired(rows, name);&#010;+            if (required) {&#010;+                String value = properties.get(name);&#010;+                if (isEmpty(value)) {&#010;+                    value = getPropertyDefaultValue(rows, name);&#010;+                }&#010;+                if (isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        return result;&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties, boolean consumerOnly, boolean producerOnly) {&#010;+        EndpointValidationResult result = new EndpointValidationResult(uri);&#010;+&#010;+        Map&lt;String, String&gt; properties;&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows;&#010;+        boolean lenientProperties;&#010;+        String scheme;&#010;+&#010;+        try {&#010;+            String json = null;&#010;+&#010;+            // parse the uri&#010;+            URI u = normalizeUri(uri);&#010;+            scheme = u.getScheme();&#010;+&#010;+            if (scheme != null) {&#010;+                json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+            }&#010;+            if (json == null) {&#010;+                // if the uri starts with a placeholder then we are also incapable of parsing it as we wasn't able to resolve the component name&#010;+                if (uri.startsWith(""{{"")) {&#010;+                    result.addIncapable(uri);&#010;+                } else if (scheme != null) {&#010;+                    result.addUnknownComponent(scheme);&#010;+                } else {&#010;+                    result.addUnknownComponent(uri);&#010;+                }&#010;+                return result;&#010;+            }&#010;+&#010;+            rows = JSonSchemaHelper.parseJsonSchema(""component"", json, false);&#010;+&#010;+            // is the component capable of both consumer and producer?&#010;+            boolean canConsumeAndProduce = false;&#010;+            if (!isComponentConsumerOnly(rows) &amp;&amp; !isComponentProducerOnly(rows)) {&#010;+                canConsumeAndProduce = true;&#010;+            }&#010;+&#010;+            if (canConsumeAndProduce &amp;&amp; consumerOnly) {&#010;+                // lenient properties is not support in consumer only mode if the component can do both of them&#010;+                lenientProperties = false;&#010;+            } else {&#010;+                // only enable lenient properties if we should not ignore&#010;+                lenientProperties = !ignoreLenientProperties &amp;&amp; isComponentLenientProperties(rows);&#010;+            }&#010;+            rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+            properties = endpointProperties(uri);&#010;+        } catch (URISyntaxException e) {&#010;+            if (uri.startsWith(""{{"")) {&#010;+                // if the uri starts with a placeholder then we are also incapable of parsing it as we wasn't able to resolve the component name&#010;+                result.addIncapable(uri);&#010;+            } else {&#010;+                result.addSyntaxError(e.getMessage());&#010;+            }&#010;+&#010;+            return result;&#010;+        }&#010;+&#010;+        // the dataformat component refers to a data format so lets add the properties for the selected&#010;+        // data format to the list of rows&#010;+        if (""dataformat"".equals(scheme)) {&#010;+            String dfName = properties.get(""name"");&#010;+            if (dfName != null) {&#010;+                String dfJson = jsonSchemaResolver.getDataFormatJSonSchema(dfName);&#010;+                List&lt;Map&lt;String, String&gt;&gt; dfRows = JSonSchemaHelper.parseJsonSchema(""properties"", dfJson, true);&#010;+                if (dfRows != null &amp;&amp; !dfRows.isEmpty()) {&#010;+                    rows.addAll(dfRows);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        for (Map.Entry&lt;String, String&gt; property : properties.entrySet()) {&#010;+            String value = property.getValue();&#010;+            String originalName = property.getKey();&#010;+            String name = property.getKey();&#010;+            // the name may be using an optional prefix, so lets strip that because the options&#010;+            // in the schema are listed without the prefix&#010;+            name = stripOptionalPrefixFromName(rows, name);&#010;+            // the name may be using a prefix, so lets see if we can find the real property name&#010;+            String propertyName = getPropertyNameFromNameWithPrefix(rows, name);&#010;+            if (propertyName != null) {&#010;+                name = propertyName;&#010;+            }&#010;+&#010;+            String prefix = getPropertyPrefix(rows, name);&#010;+            String kind = getPropertyKind(rows, name);&#010;+            boolean namePlaceholder = name.startsWith(""{{"") &amp;&amp; name.endsWith(""}}"");&#010;+            boolean valuePlaceholder = value.startsWith(""{{"") || value.startsWith(""${"") || value.startsWith(""$simple{"");&#010;+            boolean lookup = value.startsWith(""#"") &amp;&amp; value.length() &gt; 1;&#010;+            // we cannot evaluate multi values as strict as the others, as we don't know their expected types&#010;+            boolean mulitValue = prefix != null &amp;&amp; originalName.startsWith(prefix) &amp;&amp; isPropertyMultiValue(rows, name);&#010;+&#010;+            Map&lt;String, String&gt; row = getRow(rows, name);&#010;+            if (row == null) {&#010;+                // unknown option&#010;+&#010;+                // only add as error if the component is not lenient properties, or not stub component&#010;+                // and the name is not a property placeholder for one or more values&#010;+                if (!namePlaceholder &amp;&amp; !""stub"".equals(scheme)) {&#010;+                    if (lenientProperties) {&#010;+                        // as if we are lenient then the option is a dynamic extra option which we cannot validate&#010;+                        result.addLenient(name);&#010;+                    } else {&#010;+                        // its unknown&#010;+                        result.addUnknown(name);&#010;+                        if (suggestionStrategy != null) {&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(getNames(rows), name);&#010;+                            if (suggestions != null) {&#010;+                                result.addUnknownSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+                    }&#010;+                }&#010;+            } else {&#010;+                if (""parameter"".equals(kind)) {&#010;+                    // consumer only or producer only mode for parameters&#010;+                    if (consumerOnly) {&#010;+                        boolean producer = isPropertyProducerOnly(rows, name);&#010;+                        if (producer) {&#010;+                            // the option is only for producer so you cannot use it in consumer mode&#010;+                            result.addNotConsumerOnly(name);&#010;+                        }&#010;+                    } else if (producerOnly) {&#010;+                        boolean consumer = isPropertyConsumerOnly(rows, name);&#010;+                        if (consumer) {&#010;+                            // the option is only for consumer so you cannot use it in producer mode&#010;+                            result.addNotProducerOnly(name);&#010;+                        }&#010;+                    }&#010;+                }&#010;+&#010;+                // default value&#010;+                String defaultValue = getPropertyDefaultValue(rows, name);&#010;+                if (defaultValue != null) {&#010;+                    result.addDefaultValue(name, defaultValue);&#010;+                }&#010;+&#010;+                // is required but the value is empty&#010;+                boolean required = isPropertyRequired(rows, name);&#010;+                if (required &amp;&amp; isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+&#010;+                // is enum but the value is not within the enum range&#010;+                // but we can only check if the value is not a placeholder&#010;+                String enums = getPropertyEnum(rows, name);&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; enums != null) {&#010;+                    String[] choices = enums.split("","");&#010;+                    boolean found = false;&#010;+                    for (String s : choices) {&#010;+                        if (value.equalsIgnoreCase(s)) {&#010;+                            found = true;&#010;+                            break;&#010;+                        }&#010;+                    }&#010;+                    if (!found) {&#010;+                        result.addInvalidEnum(name, value);&#010;+                        result.addInvalidEnumChoices(name, choices);&#010;+                        if (suggestionStrategy != null) {&#010;+                            Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;();&#010;+                            names.addAll(Arrays.asList(choices));&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(names, value);&#010;+                            if (suggestions != null) {&#010;+                                result.addInvalidEnumSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+&#010;+                    }&#010;+                }&#010;+&#010;+                // is reference lookup of bean (not applicable for @UriPath, enums, or multi-valued)&#010;+                if (!mulitValue &amp;&amp; enums == null &amp;&amp; !""path"".equals(kind) &amp;&amp; isPropertyObject(rows, name)) {&#010;+                    // must start with # and be at least 2 characters&#010;+                    if (!value.startsWith(""#"") || value.length() &lt;= 1) {&#010;+                        result.addInvalidReference(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is boolean&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyBoolean(rows, name)) {&#010;+                    // value must be a boolean&#010;+                    boolean bool = ""true"".equalsIgnoreCase(value) || ""false"".equalsIgnoreCase(value);&#010;+                    if (!bool) {&#010;+                        result.addInvalidBoolean(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is integer&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyInteger(rows, name)) {&#010;+                    // value must be an integer&#010;+                    boolean valid = validateInteger(value);&#010;+                    if (!valid) {&#010;+                        result.addInvalidInteger(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is number&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyNumber(rows, name)) {&#010;+                    // value must be an number&#010;+                    boolean valid = false;&#010;+                    try {&#010;+                        valid = !Double.valueOf(value).isNaN() || !Float.valueOf(value).isNaN();&#010;+                    } catch (Exception e) {&#010;+                        // ignore&#010;+                    }&#010;+                    if (!valid) {&#010;+                        result.addInvalidNumber(name, value);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // now check if all required values are there, and that a default value does not exists&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String name = row.get(""name"");&#010;+            boolean required = isPropertyRequired(rows, name);&#010;+            if (required) {&#010;+                String value = properties.get(name);&#010;+                if (isEmpty(value)) {&#010;+                    value = getPropertyDefaultValue(rows, name);&#010;+                }&#010;+                if (isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        return result;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; endpointProperties(String uri) throws URISyntaxException {&#010;+        // need to normalize uri first&#010;+        URI u = normalizeUri(uri);&#010;+        String scheme = u.getScheme();&#010;+&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        if (json == null) {&#010;+            throw new IllegalArgumentException(""Cannot find endpoint with scheme "" + scheme);&#010;+        }&#010;+&#010;+        // grab the syntax&#010;+        String syntax = null;&#010;+        String alternativeSyntax = null;&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""component"", json, false);&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""syntax"")) {&#010;+                syntax = row.get(""syntax"");&#010;+            }&#010;+            if (row.containsKey(""alternativeSyntax"")) {&#010;+                alternativeSyntax = row.get(""alternativeSyntax"");&#010;+            }&#010;+        }&#010;+        if (syntax == null) {&#010;+            throw new IllegalArgumentException(""Endpoint with scheme "" + scheme + "" has no syntax defined in the json schema"");&#010;+        }&#010;+&#010;+        // only if we support alternative syntax, and the uri contains the username and password in the authority&#010;+        // part of the uri, then we would need some special logic to capture that information and strip those&#010;+        // details from the uri, so we can continue parsing the uri using the normal syntax&#010;+        Map&lt;String, String&gt; userInfoOptions = new LinkedHashMap&lt;String, String&gt;();&#010;+        if (alternativeSyntax != null &amp;&amp; alternativeSyntax.contains(""@"")) {&#010;+            // clip the scheme from the syntax&#010;+            alternativeSyntax = after(alternativeSyntax, "":"");&#010;+            // trim so only userinfo&#010;+            int idx = alternativeSyntax.indexOf(""@"");&#010;+            String fields = alternativeSyntax.substring(0, idx);&#010;+            String[] names = fields.split("":"");&#010;+&#010;+            // grab authority part and grab username and/or password&#010;+            String authority = u.getAuthority();&#010;+            if (authority != null &amp;&amp; authority.contains(""@"")) {&#010;+                String username = null;&#010;+                String password = null;&#010;+&#010;+                // grab unserinfo part before @&#010;+                String userInfo = authority.substring(0, authority.indexOf(""@""));&#010;+                String[] parts = userInfo.split("":"");&#010;+                if (parts.length == 2) {&#010;+                    username = parts[0];&#010;+                    password = parts[1];&#010;+                } else {&#010;+                    // only username&#010;+                    username = userInfo;&#010;+                }&#010;+&#010;+                // remember the username and/or password which we add later to the options&#010;+                if (names.length == 2) {&#010;+                    userInfoOptions.put(names[0], username);&#010;+                    if (password != null) {&#010;+                        // password is optional&#010;+                        userInfoOptions.put(names[1], password);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // clip the scheme from the syntax&#010;+        syntax = after(syntax, "":"");&#010;+        // clip the scheme from the uri&#010;+        uri = after(uri, "":"");&#010;+        String uriPath = stripQuery(uri);&#010;+&#010;+        // strip user info from uri path&#010;+        if (!userInfoOptions.isEmpty()) {&#010;+            int idx = uriPath.indexOf('@');&#010;+            if (idx &gt; -1) {&#010;+                uriPath = uriPath.substring(idx + 1);&#010;+            }&#010;+        }&#010;+&#010;+        // strip double slash in the start&#010;+        if (uriPath != null &amp;&amp; uriPath.startsWith(""//"")) {&#010;+            uriPath = uriPath.substring(2);&#010;+        }&#010;+&#010;+        // parse the syntax and find the names of each option&#010;+        Matcher matcher = SYNTAX_PATTERN.matcher(syntax);&#010;+        List&lt;String&gt; word = new ArrayList&lt;String&gt;();&#010;+        while (matcher.find()) {&#010;+            String s = matcher.group(1);&#010;+            if (!scheme.equals(s)) {&#010;+                word.add(s);&#010;+            }&#010;+        }&#010;+        // parse the syntax and find each token between each option&#010;+        String[] tokens = SYNTAX_PATTERN.split(syntax);&#010;+&#010;+        // find the position where each option start/end&#010;+        List&lt;String&gt; word2 = new ArrayList&lt;String&gt;();&#010;+        int prev = 0;&#010;+        int prevPath = 0;&#010;+&#010;+        // special for activemq/jms where the enum for destinationType causes a token issue as it includes a colon&#010;+        // for 'temp:queue' and 'temp:topic' values&#010;+        if (""activemq"".equals(scheme) || ""jms"".equals(scheme)) {&#010;+            if (uriPath.startsWith(""temp:"")) {&#010;+                prevPath = 5;&#010;+            }&#010;+        }&#010;+&#010;+        for (String token : tokens) {&#010;+            if (token.isEmpty()) {&#010;+                continue;&#010;+            }&#010;+&#010;+            // special for some tokens where :// can be used also, eg http://foo&#010;+            int idx = -1;&#010;+            int len = 0;&#010;+            if ("":"".equals(token)) {&#010;+                idx = uriPath.indexOf(""://"", prevPath);&#010;+                len = 3;&#010;+            }&#010;+            if (idx == -1) {&#010;+                idx = uriPath.indexOf(token, prevPath);&#010;+                len = token.length();&#010;+            }&#010;+&#010;+            if (idx &gt; 0) {&#010;+                String option = uriPath.substring(prev, idx);&#010;+                word2.add(option);&#010;+                prev = idx + len;&#010;+                prevPath = prev;&#010;+            }&#010;+        }&#010;+        // special for last or if we did not add anyone&#010;+        if (prev &gt; 0 || word2.isEmpty()) {&#010;+            String option = uriPath.substring(prev);&#010;+            word2.add(option);&#010;+        }&#010;+&#010;+        rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        boolean defaultValueAdded = false;&#010;+&#010;+        // now parse the uri to know which part isw what&#010;+        Map&lt;String, String&gt; options = new LinkedHashMap&lt;String, String&gt;();&#010;+&#010;+        // include the username and password from the userinfo section&#010;+        if (!userInfoOptions.isEmpty()) {&#010;+            options.putAll(userInfoOptions);&#010;+        }&#010;+&#010;+        // word contains the syntax path elements&#010;+        Iterator&lt;String&gt; it = word2.iterator();&#010;+        for (int i = 0; i &lt; word.size(); i++) {&#010;+            String key = word.get(i);&#010;+&#010;+            boolean allOptions = word.size() == word2.size();&#010;+            boolean required = isPropertyRequired(rows, key);&#010;+            String defaultValue = getPropertyDefaultValue(rows, key);&#010;+&#010;+            // we have all options so no problem&#010;+            if (allOptions) {&#010;+                String value = it.next();&#010;+                options.put(key, value);&#010;+            } else {&#010;+                // we have a little problem as we do not not have all options&#010;+                if (!required) {&#010;+                    String value = null;&#010;+&#010;+                    boolean last = i == word.size() - 1;&#010;+                    if (last) {&#010;+                        // if its the last value then use it instead of the default value&#010;+                        value = it.hasNext() ? it.next() : null;&#010;+                        if (value != null) {&#010;+                            options.put(key, value);&#010;+                        } else {&#010;+                            value = defaultValue;&#010;+                        }&#010;+                    }&#010;+                    if (value != null) {&#010;+                        options.put(key, value);&#010;+                        defaultValueAdded = true;&#010;+                    }&#010;+                } else {&#010;+                    String value = it.hasNext() ? it.next() : null;&#010;+                    if (value != null) {&#010;+                        options.put(key, value);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        Map&lt;String, String&gt; answer = new LinkedHashMap&lt;String, String&gt;();&#010;+&#010;+        // remove all options which are using default values and are not required&#010;+        for (Map.Entry&lt;String, String&gt; entry : options.entrySet()) {&#010;+            String key = entry.getKey();&#010;+            String value = entry.getValue();&#010;+&#010;+            if (defaultValueAdded) {&#010;+                boolean required = isPropertyRequired(rows, key);&#010;+                String defaultValue = getPropertyDefaultValue(rows, key);&#010;+&#010;+                if (!required &amp;&amp; defaultValue != null) {&#010;+                    if (defaultValue.equals(value)) {&#010;+                        continue;&#010;+                    }&#010;+                }&#010;+            }&#010;+&#010;+            // we should keep this in the answer&#010;+            answer.put(key, value);&#010;+        }&#010;+&#010;+        // now parse the uri parameters&#010;+        Map&lt;String, Object&gt; parameters = URISupport.parseParameters(u);&#010;+&#010;+        // and covert the values to String so its JMX friendly&#010;+        while (!parameters.isEmpty()) {&#010;+            Map.Entry&lt;String, Object&gt; entry = parameters.entrySet().iterator().next();&#010;+            String key = entry.getKey();&#010;+            String value = entry.getValue() != null ? entry.getValue().toString() : """";&#010;+&#010;+            boolean multiValued = isPropertyMultiValue(rows, key);&#010;+            if (multiValued) {&#010;+                String prefix = getPropertyPrefix(rows, key);&#010;+                // extra all the multi valued options&#010;+                Map&lt;String, Object&gt; values = URISupport.extractProperties(parameters, prefix);&#010;+                // build a string with the extra multi valued options with the prefix and &amp; as separator&#010;+                CollectionStringBuffer csb = new CollectionStringBuffer(""&amp;"");&#010;+                for (Map.Entry&lt;String, Object&gt; multi : values.entrySet()) {&#010;+                    String line = prefix + multi.getKey() + ""="" + (multi.getValue() != null ? multi.getValue().toString() : """");&#010;+                    csb.append(line);&#010;+                }&#010;+                // append the extra multi-values to the existing (which contains the first multi value)&#010;+                if (!csb.isEmpty()) {&#010;+                    value = value + ""&amp;"" + csb.toString();&#010;+                }&#010;+            }&#010;+&#010;+            answer.put(key, value);&#010;+            // remove the parameter as we run in a while loop until no more parameters&#010;+            parameters.remove(key);&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; endpointLenientProperties(String uri) throws URISyntaxException {&#010;+        // need to normalize uri first&#010;+&#010;+        // parse the uri&#010;+        URI u = normalizeUri(uri);&#010;+        String scheme = u.getScheme();&#010;+&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        if (json == null) {&#010;+            throw new IllegalArgumentException(""Cannot find endpoint with scheme "" + scheme);&#010;+        }&#010;+&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        // now parse the uri parameters&#010;+        Map&lt;String, Object&gt; parameters = URISupport.parseParameters(u);&#010;+&#010;+        // all the known options&#010;+        Set&lt;String&gt; names = getNames(rows);&#010;+&#010;+        Map&lt;String, String&gt; answer = new LinkedHashMap&lt;&gt;();&#010;+&#010;+        // and covert the values to String so its JMX friendly&#010;+        parameters.forEach((k, v) -&gt; {&#010;+            String key = k;&#010;+            String value = v != null ? v.toString() : """";&#010;+&#010;+            // is the key a prefix property&#010;+            int dot = key.indexOf('.');&#010;+            if (dot != -1) {&#010;+                String prefix = key.substring(0, dot + 1); // include dot in prefix&#010;+                String option = getPropertyNameFromNameWithPrefix(rows, prefix);&#010;+                if (option == null || !isPropertyMultiValue(rows, option)) {&#010;+                    answer.put(key, value);&#010;+                }&#010;+            } else if (!names.contains(key)) {&#010;+                answer.put(key, value);&#010;+            }&#010;+        });&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    public String endpointComponentName(String uri) {&#010;+        if (uri != null) {&#010;+            int idx = uri.indexOf("":"");&#010;+            if (idx &gt; 0) {&#010;+                return uri.substring(0, idx);&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public String asEndpointUri(String scheme, String json, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, json, ""&amp;"", encode);&#010;+    }&#010;+&#010;+    public String asEndpointUriXml(String scheme, String json, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, json, ""&amp;amp;"", encode);&#010;+    }&#010;+&#010;+    private String doAsEndpointUri(String scheme, String json, String ampersand, boolean encode) throws URISyntaxException {&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        Map&lt;String, String&gt; copy = new HashMap&lt;String, String&gt;();&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String name = row.get(""name"");&#010;+            String required = row.get(""required"");&#010;+            String value = row.get(""value"");&#010;+            String defaultValue = row.get(""defaultValue"");&#010;+&#010;+            // only add if either required, or the value is != default value&#010;+            String valueToAdd = null;&#010;+            if (""true"".equals(required)) {&#010;+                valueToAdd = value != null ? value : defaultValue;&#010;+                if (valueToAdd == null) {&#010;+                    valueToAdd = """";&#010;+                }&#010;+            } else {&#010;+                // if we have a value and no default then add it&#010;+                if (value != null &amp;&amp; defaultValue == null) {&#010;+                    valueToAdd = value;&#010;+                }&#010;+                // otherwise only add if the value is != default value&#010;+                if (value != null &amp;&amp; defaultValue != null &amp;&amp; !value.equals(defaultValue)) {&#010;+                    valueToAdd = value;&#010;+                }&#010;+            }&#010;+&#010;+            if (valueToAdd != null) {&#010;+                copy.put(name, valueToAdd);&#010;+            }&#010;+        }&#010;+&#010;+        return doAsEndpointUri(scheme, copy, ampersand, encode);&#010;+    }&#010;+&#010;+    public String asEndpointUri(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, properties, ""&amp;"", encode);&#010;+    }&#010;+&#010;+    public String asEndpointUriXml(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, properties, ""&amp;amp;"", encode);&#010;+    }&#010;+&#010;+    String doAsEndpointUri(String scheme, Map&lt;String, String&gt; properties, String ampersand, boolean encode) throws URISyntaxException {&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        if (json == null) {&#010;+            throw new IllegalArgumentException(""Cannot find endpoint with scheme "" + scheme);&#010;+        }&#010;+&#010;+        // grab the syntax&#010;+        String syntax = null;&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""component"", json, false);&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""syntax"")) {&#010;+                syntax = row.get(""syntax"");&#010;+                break;&#010;+            }&#010;+        }&#010;+        if (syntax == null) {&#010;+            throw new IllegalArgumentException(""Endpoint with scheme "" + scheme + "" has no syntax defined in the json schema"");&#010;+        }&#010;+&#010;+        // do any properties filtering which can be needed for some special components&#010;+        properties = filterProperties(scheme, properties);&#010;+&#010;+        rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        // clip the scheme from the syntax&#010;+        syntax = after(syntax, "":"");&#010;+&#010;+        String originalSyntax = syntax;&#010;+&#010;+        // build at first according to syntax (use a tree map as we want the uri options sorted)&#010;+        Map&lt;String, String&gt; copy = new TreeMap&lt;String, String&gt;();&#010;+        for (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) {&#010;+            String key = entry.getKey();&#010;+            String value = entry.getValue() != null ? entry.getValue() : """";&#010;+            if (syntax != null &amp;&amp; syntax.contains(key)) {&#010;+                syntax = syntax.replace(key, value);&#010;+            } else {&#010;+                copy.put(key, value);&#010;+            }&#010;+        }&#010;+&#010;+        // do we have all the options the original syntax needs (easy way)&#010;+        String[] keys = syntaxKeys(originalSyntax);&#010;+        boolean hasAllKeys = properties.keySet().containsAll(Arrays.asList(keys));&#010;+&#010;+        // build endpoint uri&#010;+        StringBuilder sb = new StringBuilder();&#010;+        sb.append(scheme);&#010;+        sb.append("":"");&#010;+&#010;+        if (hasAllKeys) {&#010;+            // we have all the keys for the syntax so we can build the uri the easy way&#010;+            sb.append(syntax);&#010;+&#010;+            if (!copy.isEmpty()) {&#010;+                boolean hasQuestionmark = sb.toString().contains(""?"");&#010;+                // the last option may already contain a ? char, if so we should use &amp; instead of ?&#010;+                sb.append(hasQuestionmark ? ampersand : '?');&#010;+                String query = createQueryString(copy, ampersand, encode);&#010;+                sb.append(query);&#010;+            }&#010;+        } else {&#010;+            // TODO: revisit this and see if we can do this in another way&#010;+            // oh darn some options is missing, so we need a complex way of building the uri&#010;+&#010;+            // the tokens between the options in the path&#010;+            String[] tokens = syntax.split(""\\w+"");&#010;+&#010;+            // parse the syntax into each options&#010;+            Matcher matcher = SYNTAX_PATTERN.matcher(originalSyntax);&#010;+            List&lt;String&gt; options = new ArrayList&lt;String&gt;();&#010;+            while (matcher.find()) {&#010;+                String s = matcher.group(1);&#010;+                options.add(s);&#010;+            }&#010;+&#010;+            // need to preserve {{ and }} from the syntax&#010;+            // (we need to use words only as its provisional placeholders)&#010;+            syntax = syntax.replaceAll(""\\{\\{"", ""BEGINCAMELPLACEHOLDER"");&#010;+            syntax = syntax.replaceAll(""\\}\\}"", ""ENDCAMELPLACEHOLDER"");&#010;+&#010;+            // parse the syntax into each options&#010;+            Matcher matcher2 = SYNTAX_PATTERN.matcher(syntax);&#010;+            List&lt;String&gt; options2 = new ArrayList&lt;String&gt;();&#010;+            while (matcher2.find()) {&#010;+                String s = matcher2.group(1);&#010;+                s = s.replaceAll(""BEGINCAMELPLACEHOLDER"", ""\\{\\{"");&#010;+                s = s.replaceAll(""ENDCAMELPLACEHOLDER"", ""\\}\\}"");&#010;+                options2.add(s);&#010;+            }&#010;+&#010;+            // build the endpoint&#010;+            int range = 0;&#010;+            boolean first = true;&#010;+            boolean hasQuestionmark = false;&#010;+            for (int i = 0; i &lt; options.size(); i++) {&#010;+                String key = options.get(i);&#010;+                String key2 = options2.get(i);&#010;+                String token = null;&#010;+                if (tokens.length &gt; i) {&#010;+                    token = tokens[i];&#010;+                }&#010;+&#010;+                boolean contains = properties.containsKey(key);&#010;+                if (!contains) {&#010;+                    // if the key are similar we have no explicit value and can try to find a default value if the option is required&#010;+                    if (isPropertyRequired(rows, key)) {&#010;+                        String value = getPropertyDefaultValue(rows, key);&#010;+                        if (value != null) {&#010;+                            properties.put(key, value);&#010;+                            key2 = value;&#010;+                        }&#010;+                    }&#010;+                }&#010;+&#010;+                // was the option provided?&#010;+                if (properties.containsKey(key)) {&#010;+                    if (!first &amp;&amp; token != null) {&#010;+                        sb.append(token);&#010;+                    }&#010;+                    hasQuestionmark |= key.contains(""?"") || (token != null &amp;&amp; token.contains(""?""));&#010;+                    sb.append(key2);&#010;+                    first = false;&#010;+                }&#010;+                range++;&#010;+            }&#010;+            // append any extra options that was in surplus for the last&#010;+            while (range &lt; options2.size()) {&#010;+                String token = null;&#010;+                if (tokens.length &gt; range) {&#010;+                    token = tokens[range];&#010;+                }&#010;+                String key2 = options2.get(range);&#010;+                sb.append(token);&#010;+                sb.append(key2);&#010;+                hasQuestionmark |= key2.contains(""?"") || (token != null &amp;&amp; token.contains(""?""));&#010;+                range++;&#010;+            }&#010;+&#010;+&#010;+            if (!copy.isEmpty()) {&#010;+                // the last option may already contain a ? char, if so we should use &amp; instead of ?&#010;+                sb.append(hasQuestionmark ? ampersand : '?');&#010;+                String query = createQueryString(copy, ampersand, encode);&#010;+                sb.append(query);&#010;+            }&#010;+        }&#010;+&#010;+        return sb.toString();&#010;+    }&#010;+&#010;+    @Deprecated&#010;+    private static String[] syntaxTokens(String syntax) {&#010;+        // build tokens between the words&#010;+        List&lt;String&gt; tokens = new ArrayList&lt;&gt;();&#010;+        // preserve backwards behavior which had an empty token first&#010;+        tokens.add("""");&#010;+&#010;+        String current = """";&#010;+        for (int i = 0; i &lt; syntax.length(); i++) {&#010;+            char ch = syntax.charAt(i);&#010;+            if (Character.isLetterOrDigit(ch)) {&#010;+                // reset for new current tokens&#010;+                if (current.length() &gt; 0) {&#010;+                    tokens.add(current);&#010;+                    current = """";&#010;+                }&#010;+            } else {&#010;+                current += ch;&#010;+            }&#010;+        }&#010;+        // anything left over?&#010;+        if (current.length() &gt; 0) {&#010;+            tokens.add(current);&#010;+        }&#010;+&#010;+        return tokens.toArray(new String[tokens.size()]);&#010;+    }&#010;+&#010;+    private static String[] syntaxKeys(String syntax) {&#010;+        // build tokens between the separators&#010;+        List&lt;String&gt; tokens = new ArrayList&lt;&gt;();&#010;+&#010;+        String current = """";&#010;+        for (int i = 0; i &lt; syntax.length(); i++) {&#010;+            char ch = syntax.charAt(i);&#010;+            if (Character.isLetterOrDigit(ch)) {&#010;+                current += ch;&#010;+            } else {&#010;+                // reset for new current tokens&#010;+                if (current.length() &gt; 0) {&#010;+                    tokens.add(current);&#010;+                    current = """";&#010;+                }&#010;+            }&#010;+        }&#010;+        // anything left over?&#010;+        if (current.length() &gt; 0) {&#010;+            tokens.add(current);&#010;+        }&#010;+&#010;+        return tokens.toArray(new String[tokens.size()]);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimpleExpression(String simple) {&#010;+        return doValidateSimple(null, simple, false);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimpleExpression(ClassLoader classLoader, String simple) {&#010;+        return doValidateSimple(classLoader, simple, false);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimplePredicate(String simple) {&#010;+        return doValidateSimple(null, simple, true);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimplePredicate(ClassLoader classLoader, String simple) {&#010;+        return doValidateSimple(classLoader, simple, true);&#010;+    }&#010;+&#010;+    private SimpleValidationResult doValidateSimple(ClassLoader classLoader, String simple, boolean predicate) {&#010;+        if (classLoader == null) {&#010;+            classLoader = getClass().getClassLoader();&#010;+        }&#010;+&#010;+        // if there are {{ }}} property placeholders then we need to resolve them to something else&#010;+        // as the simple parse cannot resolve them before parsing as we dont run the actual Camel application&#010;+        // with property placeholders setup so we need to dummy this by replace the {{ }} to something else&#010;+        // therefore we use an more unlikely character: {{XXX}} to ~^XXX^~&#010;+        String resolved = simple.replaceAll(""\\{\\{(.+)\\}\\}"", ""~^$1^~"");&#010;+&#010;+        SimpleValidationResult answer = new SimpleValidationResult(simple);&#010;+&#010;+        Object instance = null;&#010;+        Class clazz = null;&#010;+        try {&#010;+            clazz = classLoader.loadClass(""org.apache.camel.language.simple.SimpleLanguage"");&#010;+            instance = clazz.newInstance();&#010;+        } catch (Exception e) {&#010;+            // ignore&#010;+        }&#010;+&#010;+        if (clazz != null &amp;&amp; instance != null) {&#010;+            Throwable cause = null;&#010;+            try {&#010;+                if (predicate) {&#010;+                    instance.getClass().getMethod(""createPredicate"", String.class).invoke(instance, resolved);&#010;+                } else {&#010;+                    instance.getClass().getMethod(""createExpression"", String.class).invoke(instance, resolved);&#010;+                }&#010;+            } catch (InvocationTargetException e) {&#010;+                cause = e.getTargetException();&#010;+            } catch (Exception e) {&#010;+                cause = e;&#010;+            }&#010;+&#010;+            if (cause != null) {&#010;+&#010;+                // reverse ~^XXX^~ back to {{XXX}}&#010;+                String errMsg = cause.getMessage();&#010;+                errMsg = errMsg.replaceAll(""\\~\\^(.+)\\^\\~"", ""{{$1}}"");&#010;+&#010;+                answer.setError(errMsg);&#010;+&#010;+                // is it simple parser exception then we can grab the index where the problem is&#010;+                if (cause.getClass().getName().equals(""org.apache.camel.language.simple.types.SimpleIllegalSyntaxException"")&#010;+                    || cause.getClass().getName().equals(""org.apache.camel.language.simple.types.SimpleParserException"")) {&#010;+                    try {&#010;+                        // we need to grab the index field from those simple parser exceptions&#010;+                        Method method = cause.getClass().getMethod(""getIndex"");&#010;+                        Object result = method.invoke(cause);&#010;+                        if (result != null) {&#010;+                            int index = (int) result;&#010;+                            answer.setIndex(index);&#010;+                        }&#010;+                    } catch (Throwable i) {&#010;+                        // ignore&#010;+                    }&#010;+                }&#010;+&#010;+                // we need to grab the short message field from this simple syntax exception&#010;+                if (cause.getClass().getName().equals(""org.apache.camel.language.simple.types.SimpleIllegalSyntaxException"")) {&#010;+                    try {&#010;+                        Method method = cause.getClass().getMethod(""getShortMessage"");&#010;+                        Object result = method.invoke(cause);&#010;+                        if (result != null) {&#010;+                            String msg = (String) result;&#010;+                            answer.setShortError(msg);&#010;+                        }&#010;+                    } catch (Throwable i) {&#010;+                        // ignore&#010;+                    }&#010;+&#010;+                    if (answer.getShortError() == null) {&#010;+                        // fallback and try to make existing message short instead&#010;+                        String msg = answer.getError();&#010;+                        // grab everything before "" at location "" which would be regarded as the short message&#010;+                        int idx = msg.indexOf("" at location "");&#010;+                        if (idx &gt; 0) {&#010;+                            msg = msg.substring(0, idx);&#010;+                            answer.setShortError(msg);&#010;+                        }&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    public LanguageValidationResult validateLanguagePredicate(ClassLoader classLoader, String language, String text) {&#010;+        return doValidateLanguage(classLoader, language, text, true);&#010;+    }&#010;+&#010;+    public LanguageValidationResult validateLanguageExpression(ClassLoader classLoader, String language, String text) {&#010;+        return doValidateLanguage(classLoader, language, text, false);&#010;+    }&#010;+&#010;+    private LanguageValidationResult doValidateLanguage(ClassLoader classLoader, String language, String text, boolean predicate) {&#010;+        if (classLoader == null) {&#010;+            classLoader = getClass().getClassLoader();&#010;+        }&#010;+&#010;+        SimpleValidationResult answer = new SimpleValidationResult(text);&#010;+&#010;+        String json = jsonSchemaResolver.getLanguageJSonSchema(language);&#010;+        if (json == null) {&#010;+            answer.setError(""Unknown language "" + language);&#010;+            return answer;&#010;+        }&#010;+&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""language"", json, false);&#010;+        String className = null;&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""javaType"")) {&#010;+                className = row.get(""javaType"");&#010;+            }&#010;+        }&#010;+&#010;+        if (className == null) {&#010;+            answer.setError(""Cannot find javaType for language "" + language);&#010;+            return answer;&#010;+        }&#010;+&#010;+        Object instance = null;&#010;+        Class clazz = null;&#010;+        try {&#010;+            clazz = classLoader.loadClass(className);&#010;+            instance = clazz.newInstance();&#010;+        } catch (Exception e) {&#010;+            // ignore&#010;+        }&#010;+&#010;+        if (clazz != null &amp;&amp; instance != null) {&#010;+            Throwable cause = null;&#010;+            try {&#010;+                if (predicate) {&#010;+                    instance.getClass().getMethod(""createPredicate"", String.class).invoke(instance, text);&#010;+                } else {&#010;+                    instance.getClass().getMethod(""createExpression"", String.class).invoke(instance, text);&#010;+                }&#010;+            } catch (InvocationTargetException e) {&#010;+                cause = e.getTargetException();&#010;+            } catch (Exception e) {&#010;+                cause = e;&#010;+            }&#010;+&#010;+            if (cause != null) {&#010;+                answer.setError(cause.getMessage());&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    /**&#010;+     * Special logic for log endpoints to deal when showAll=true&#010;+     */&#010;+    private Map&lt;String, String&gt; filterProperties(String scheme, Map&lt;String, String&gt; options) {&#010;+        if (""log"".equals(scheme)) {&#010;+            String showAll = options.get(""showAll"");&#010;+            if (""true"".equals(showAll)) {&#010;+                Map&lt;String, String&gt; filtered = new LinkedHashMap&lt;String, String&gt;();&#010;+                // remove all the other showXXX options when showAll=true&#010;+                for (Map.Entry&lt;String, String&gt; entry : options.entrySet()) {&#010;+                    String key = entry.getKey();&#010;+                    boolean skip = key.startsWith(""show"") &amp;&amp; !key.equals(""showAll"");&#010;+                    if (!skip) {&#010;+                        filtered.put(key, entry.getValue());&#010;+                    }&#010;+                }&#010;+                return filtered;&#010;+            }&#010;+        }&#010;+        // use as-is&#010;+        return options;&#010;+    }&#010;+&#010;+    private static boolean validateInteger(String value) {&#010;+        boolean valid = false;&#010;+        try {&#010;+            valid = Integer.valueOf(value) != null;&#010;+        } catch (Exception e) {&#010;+            // ignore&#010;+        }&#010;+        if (!valid) {&#010;+            // it may be a time pattern, such as 5s for 5 seconds = 5000&#010;+            try {&#010;+                TimePatternConverter.toMilliSeconds(value);&#010;+                valid = true;&#010;+            } catch (Exception e) {&#010;+                // ignore&#010;+            }&#010;+        }&#010;+        return valid;&#010;+    }&#010;+&#010;+    // CHECKSTYLE:ON&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java&#010;new file mode 100644&#010;index 0000000..d3a448c&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java&#010;@@ -0,0 +1,80 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.IOException;&#010;+&#010;+import org.apache.camel.CamelContext;&#010;+&#010;+/**&#010;+ * Uses runtime {@link CamelContext} to resolve the JSon schema files.&#010;+ */&#010;+public class CamelContextJSonSchemaResolver implements JSonSchemaResolver {&#010;+&#010;+    private final CamelContext camelContext;&#010;+&#010;+    public CamelContextJSonSchemaResolver(CamelContext camelContext) {&#010;+        this.camelContext = camelContext;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getComponentJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getComponentParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getDataFormatJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getDataFormatParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getLanguageJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getLanguageParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getOtherJSonSchema(String name) {&#010;+        // not supported&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getModelJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getEipParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java&#010;new file mode 100644&#010;index 0000000..1b224df&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java&#010;@@ -0,0 +1,179 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.BufferedReader;&#010;+import java.io.IOException;&#010;+import java.io.InputStream;&#010;+import java.io.InputStreamReader;&#010;+import java.io.LineNumberReader;&#010;+import java.util.List;&#010;+&#010;+public final class CatalogHelper {&#010;+&#010;+    private CatalogHelper() {&#010;+    }&#010;+&#010;+    /**&#010;+     * Loads the entire stream into memory as a String and returns it.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Notice:&lt;/b&gt; This implementation appends a &lt;tt&gt;\n&lt;/tt&gt; as line&#010;+     * terminator at the of the text.&#010;+     * &lt;p/&gt;&#010;+     * Warning, don't use for crazy big streams :)&#010;+     */&#010;+    public static void loadLines(InputStream in, List&lt;String&gt; lines) throws IOException {&#010;+        try (final InputStreamReader isr = new InputStreamReader(in);&#010;+            final BufferedReader reader = new LineNumberReader(isr)) {&#010;+            String line;&#010;+            while ((line = reader.readLine()) != null) {&#010;+                lines.add(line);&#010;+            }&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Loads the entire stream into memory as a String and returns it.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Notice:&lt;/b&gt; This implementation appends a &lt;tt&gt;\n&lt;/tt&gt; as line&#010;+     * terminator at the of the text.&#010;+     * &lt;p/&gt;&#010;+     * Warning, don't use for crazy big streams :)&#010;+     */&#010;+    public static String loadText(InputStream in) throws IOException {&#010;+        StringBuilder builder = new StringBuilder();&#010;+        try (final InputStreamReader isr = new InputStreamReader(in);&#010;+            final BufferedReader reader = new LineNumberReader(isr)) {&#010;+            String line;&#010;+            while ((line = reader.readLine()) != null) {&#010;+                builder.append(line);&#010;+                builder.append(""\n"");&#010;+            }&#010;+            return builder.toString();&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Matches the name with the pattern.&#010;+     *&#010;+     * @param name  the name&#010;+     * @param pattern the pattern&#010;+     * @return &lt;tt&gt;true&lt;/tt&gt; if matched, or &lt;tt&gt;false&lt;/tt&gt; if not&#010;+     */&#010;+    public static boolean matchWildcard(String name, String pattern) {&#010;+        // we have wildcard support in that hence you can match with: file* to match any file endpoints&#010;+        if (pattern.endsWith(""*"") &amp;&amp; name.startsWith(pattern.substring(0, pattern.length() - 1))) {&#010;+            return true;&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    /**&#010;+     * Returns the string after the given token&#010;+     *&#010;+     * @param text  the text&#010;+     * @param after the token&#010;+     * @return the text after the token, or &lt;tt&gt;null&lt;/tt&gt; if text does not contain the token&#010;+     */&#010;+    public static String after(String text, String after) {&#010;+        if (!text.contains(after)) {&#010;+            return null;&#010;+        }&#010;+        return text.substring(text.indexOf(after) + after.length());&#010;+    }&#010;+&#010;+    /**&#010;+     * Returns the string before the given token&#010;+     *&#010;+     * @param text  the text&#010;+     * @param before the token&#010;+     * @return the text before the token, or &lt;tt&gt;null&lt;/tt&gt; if text does not contain the token&#010;+     */&#010;+    public static String before(String text, String before) {&#010;+        if (!text.contains(before)) {&#010;+            return null;&#010;+        }&#010;+        return text.substring(0, text.indexOf(before));&#010;+    }&#010;+&#010;+    /**&#010;+     * Returns the string between the given tokens&#010;+     *&#010;+     * @param text  the text&#010;+     * @param after the before token&#010;+     * @param before the after token&#010;+     * @return the text between the tokens, or &lt;tt&gt;null&lt;/tt&gt; if text does not contain the tokens&#010;+     */&#010;+    public static String between(String text, String after, String before) {&#010;+        text = after(text, after);&#010;+        if (text == null) {&#010;+            return null;&#010;+        }&#010;+        return before(text, before);&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if empty&#010;+     */&#010;+    public static boolean isEmpty(Object value) {&#010;+        return !isNotEmpty(value);&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;b&gt;not&lt;/b&gt; &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if &lt;b&gt;not&lt;/b&gt; empty&#010;+     */&#010;+    public static boolean isNotEmpty(Object value) {&#010;+        if (value == null) {&#010;+            return false;&#010;+        } else if (value instanceof String) {&#010;+            String text = (String) value;&#010;+            return text.trim().length() &gt; 0;&#010;+        } else {&#010;+            return true;&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Removes all leading and ending quotes (single and double) from the string&#010;+     *&#010;+     * @param s  the string&#010;+     * @return the string without leading and ending quotes (single and double)&#010;+     */&#010;+    public static String removeLeadingAndEndingQuotes(String s) {&#010;+        if (isEmpty(s)) {&#010;+            return s;&#010;+        }&#010;+&#010;+        String copy = s.trim();&#010;+        if (copy.startsWith(""'"") &amp;&amp; copy.endsWith(""'"")) {&#010;+            return copy.substring(1, copy.length() - 1);&#010;+        }&#010;+        if (copy.startsWith(""\"""") &amp;&amp; copy.endsWith(""\"""")) {&#010;+            return copy.substring(1, copy.length() - 1);&#010;+        }&#010;+&#010;+        // no quotes, so return as-is&#010;+        return s;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java&#010;new file mode 100644&#010;index 0000000..f6484b8&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java&#010;@@ -0,0 +1,57 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+public class CollectionStringBuffer {&#010;+    private final StringBuilder buffer = new StringBuilder();&#010;+    private String separator;&#010;+    private boolean first = true;&#010;+&#010;+    public CollectionStringBuffer() {&#010;+        this("", "");&#010;+    }&#010;+&#010;+    public CollectionStringBuffer(String separator) {&#010;+        this.separator = separator;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String toString() {&#010;+        return buffer.toString();&#010;+    }&#010;+&#010;+    public void append(Object value) {&#010;+        if (first) {&#010;+            first = false;&#010;+        } else {&#010;+            buffer.append(separator);&#010;+        }&#010;+        buffer.append(value);&#010;+    }&#010;+&#010;+    public String getSeparator() {&#010;+        return separator;&#010;+    }&#010;+&#010;+    public void setSeparator(String separator) {&#010;+        this.separator = separator;&#010;+    }&#010;+&#010;+    public boolean isEmpty() {&#010;+        return first;&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java&#010;new file mode 100644&#010;index 0000000..7648e64&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java&#010;@@ -0,0 +1,136 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.HashMap;&#010;+import java.util.Map;&#010;+&#010;+import org.apache.camel.CamelContext;&#010;+&#010;+/**&#010;+ * Default {@link RuntimeCamelCatalog}.&#010;+ */&#010;+public class DefaultRuntimeCamelCatalog extends AbstractCamelCatalog implements RuntimeCamelCatalog {&#010;+&#010;+    // cache of operation -&gt; result&#010;+    private final Map&lt;String, Object&gt; cache = new HashMap&lt;String, Object&gt;();&#010;+    private boolean caching;&#010;+&#010;+    /**&#010;+     * Creates the {@link RuntimeCamelCatalog} without caching enabled.&#010;+     *&#010;+     * @param camelContext  the camel context&#010;+     */&#010;+    public DefaultRuntimeCamelCatalog(CamelContext camelContext) {&#010;+        this(camelContext, false);&#010;+    }&#010;+&#010;+    /**&#010;+     * Creates the {@link RuntimeCamelCatalog}&#010;+     *&#010;+     * @param camelContext  the camel context&#010;+     * @param caching  whether to use cache&#010;+     */&#010;+    public DefaultRuntimeCamelCatalog(CamelContext camelContext, boolean caching) {&#010;+        this.caching = caching;&#010;+        setJSonSchemaResolver(new CamelContextJSonSchemaResolver(camelContext));&#010;+    }&#010;+&#010;+    @Override&#010;+    public void start() throws Exception {&#010;+        // noop&#010;+    }&#010;+&#010;+    @Override&#010;+    public void stop() throws Exception {&#010;+        cache.clear();&#010;+    }&#010;+&#010;+    @Override&#010;+    public String modelJSonSchema(String name) {&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""model-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getModelJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""model-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String componentJSonSchema(String name) {&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""component-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getComponentJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""component-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String dataFormatJSonSchema(String name) {&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""dataformat-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getDataFormatJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""dataformat-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String languageJSonSchema(String name) {&#010;+        // if we try to look method then its in the bean.json file&#010;+        if (""method"".equals(name)) {&#010;+            name = ""bean"";&#010;+        }&#010;+&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""language-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getLanguageJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""language-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java&#010;new file mode 100644&#010;index 0000000..7d1c657&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java&#010;@@ -0,0 +1,451 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.Serializable;&#010;+import java.util.Arrays;&#010;+import java.util.Collections;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.LinkedHashSet;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+import java.util.Set;&#010;+&#010;+import static org.apache.camel.runtimecatalog.URISupport.isEmpty;&#010;+&#010;+/**&#010;+ * Details result of validating endpoint uri.&#010;+ */&#010;+public class EndpointValidationResult implements Serializable {&#010;+&#010;+    private final String uri;&#010;+    private int errors;&#010;+&#010;+    // general&#010;+    private String syntaxError;&#010;+    private String unknownComponent;&#010;+    private String incapable;&#010;+&#010;+    // options&#010;+    private Set&lt;String&gt; unknown;&#010;+    private Map&lt;String, String[]&gt; unknownSuggestions;&#010;+    private Set&lt;String&gt; lenient;&#010;+    private Set&lt;String&gt; notConsumerOnly;&#010;+    private Set&lt;String&gt; notProducerOnly;&#010;+    private Set&lt;String&gt; required;&#010;+    private Map&lt;String, String&gt; invalidEnum;&#010;+    private Map&lt;String, String[]&gt; invalidEnumChoices;&#010;+    private Map&lt;String, String[]&gt; invalidEnumSuggestions;&#010;+    private Map&lt;String, String&gt; invalidReference;&#010;+    private Map&lt;String, String&gt; invalidBoolean;&#010;+    private Map&lt;String, String&gt; invalidInteger;&#010;+    private Map&lt;String, String&gt; invalidNumber;&#010;+    private Map&lt;String, String&gt; defaultValues;&#010;+&#010;+    public EndpointValidationResult() {&#010;+        this(null);&#010;+    }&#010;+&#010;+    public EndpointValidationResult(String uri) {&#010;+        this.uri = uri;&#010;+    }&#010;+&#010;+    public String getUri() {&#010;+        return uri;&#010;+    }&#010;+&#010;+    public boolean hasErrors() {&#010;+        return errors &gt; 0;&#010;+    }&#010;+&#010;+    public int getNumberOfErrors() {&#010;+        return errors;&#010;+    }&#010;+&#010;+    public boolean isSuccess() {&#010;+        boolean ok = syntaxError == null &amp;&amp; unknownComponent == null &amp;&amp; incapable == null&#010;+                &amp;&amp; unknown == null &amp;&amp; required == null;&#010;+        if (ok) {&#010;+            ok = notConsumerOnly == null &amp;&amp; notProducerOnly == null;&#010;+        }&#010;+        if (ok) {&#010;+            ok = invalidEnum == null &amp;&amp; invalidEnumChoices == null &amp;&amp; invalidReference == null&#010;+                &amp;&amp; invalidBoolean == null &amp;&amp; invalidInteger == null &amp;&amp; invalidNumber == null;&#010;+        }&#010;+        return ok;&#010;+    }&#010;+&#010;+    public void addSyntaxError(String syntaxError) {&#010;+        this.syntaxError = syntaxError;&#010;+        errors++;&#010;+    }&#010;+&#010;+    public void addIncapable(String uri) {&#010;+        this.incapable = uri;&#010;+        errors++;&#010;+    }&#010;+&#010;+    public void addUnknownComponent(String name) {&#010;+        this.unknownComponent = name;&#010;+        errors++;&#010;+    }&#010;+&#010;+    public void addUnknown(String name) {&#010;+        if (unknown == null) {&#010;+            unknown = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!unknown.contains(name)) {&#010;+            unknown.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addUnknownSuggestions(String name, String[] suggestions) {&#010;+        if (unknownSuggestions == null) {&#010;+            unknownSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;+        }&#010;+        unknownSuggestions.put(name, suggestions);&#010;+    }&#010;+&#010;+    public void addLenient(String name) {&#010;+        if (lenient == null) {&#010;+            lenient = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!lenient.contains(name)) {&#010;+            lenient.add(name);&#010;+        }&#010;+    }&#010;+&#010;+    public void addRequired(String name) {&#010;+        if (required == null) {&#010;+            required = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!required.contains(name)) {&#010;+            required.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidEnum(String name, String value) {&#010;+        if (invalidEnum == null) {&#010;+            invalidEnum = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidEnum.containsKey(name)) {&#010;+            invalidEnum.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidEnumChoices(String name, String[] choices) {&#010;+        if (invalidEnumChoices == null) {&#010;+            invalidEnumChoices = new LinkedHashMap&lt;String, String[]&gt;();&#010;+        }&#010;+        invalidEnumChoices.put(name, choices);&#010;+    }&#010;+&#010;+    public void addInvalidEnumSuggestions(String name, String[] suggestions) {&#010;+        if (invalidEnumSuggestions == null) {&#010;+            invalidEnumSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;+        }&#010;+        invalidEnumSuggestions.put(name, suggestions);&#010;+    }&#010;+&#010;+    public void addInvalidReference(String name, String value) {&#010;+        if (invalidReference == null) {&#010;+            invalidReference = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidReference.containsKey(name)) {&#010;+            invalidReference.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidBoolean(String name, String value) {&#010;+        if (invalidBoolean == null) {&#010;+            invalidBoolean = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidBoolean.containsKey(name)) {&#010;+            invalidBoolean.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidInteger(String name, String value) {&#010;+        if (invalidInteger == null) {&#010;+            invalidInteger = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidInteger.containsKey(name)) {&#010;+            invalidInteger.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidNumber(String name, String value) {&#010;+        if (invalidNumber == null) {&#010;+            invalidNumber = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidNumber.containsKey(name)) {&#010;+            invalidNumber.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addDefaultValue(String name, String value)  {&#010;+        if (defaultValues == null) {&#010;+            defaultValues = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        defaultValues.put(name, value);&#010;+    }&#010;+&#010;+    public void addNotConsumerOnly(String name) {&#010;+        if (notConsumerOnly == null) {&#010;+            notConsumerOnly = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!notConsumerOnly.contains(name)) {&#010;+            notConsumerOnly.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addNotProducerOnly(String name) {&#010;+        if (notProducerOnly == null) {&#010;+            notProducerOnly = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!notProducerOnly.contains(name)) {&#010;+            notProducerOnly.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public String getSyntaxError() {&#010;+        return syntaxError;&#010;+    }&#010;+&#010;+    public String getIncapable() {&#010;+        return incapable;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getUnknown() {&#010;+        return unknown;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getLenient() {&#010;+        return lenient;&#010;+    }&#010;+&#010;+    public Map&lt;String, String[]&gt; getUnknownSuggestions() {&#010;+        return unknownSuggestions;&#010;+    }&#010;+&#010;+    public String getUnknownComponent() {&#010;+        return unknownComponent;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getRequired() {&#010;+        return required;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidEnum() {&#010;+        return invalidEnum;&#010;+    }&#010;+&#010;+    public Map&lt;String, String[]&gt; getInvalidEnumChoices() {&#010;+        return invalidEnumChoices;&#010;+    }&#010;+&#010;+    public List&lt;String&gt; getEnumChoices(String optionName) {&#010;+        if (invalidEnumChoices != null) {&#010;+            String[] enums = invalidEnumChoices.get(optionName);&#010;+            if (enums != null) {&#010;+                return Arrays.asList(enums);&#010;+            }&#010;+        }&#010;+&#010;+        return Collections.emptyList();&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidReference() {&#010;+        return invalidReference;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidBoolean() {&#010;+        return invalidBoolean;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidInteger() {&#010;+        return invalidInteger;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidNumber() {&#010;+        return invalidNumber;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getDefaultValues() {&#010;+        return defaultValues;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getNotConsumerOnly() {&#010;+        return notConsumerOnly;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getNotProducerOnly() {&#010;+        return notProducerOnly;&#010;+    }&#010;+&#010;+    /**&#010;+     * A human readable summary of the validation errors.&#010;+     *&#010;+     * @param includeHeader whether to include a header&#010;+     * @return the summary, or &lt;tt&gt;null&lt;/tt&gt; if no validation errors&#010;+     */&#010;+    public String summaryErrorMessage(boolean includeHeader) {&#010;+        if (isSuccess()) {&#010;+            return null;&#010;+        }&#010;+&#010;+        if (incapable != null) {&#010;+            return ""\tIncapable of parsing uri: "" + incapable;&#010;+        } else if (syntaxError != null) {&#010;+            return ""\tSyntax error: "" + syntaxError;&#010;+        } else if (unknownComponent != null) {&#010;+            return ""\tUnknown component: "" + unknownComponent;&#010;+        }&#010;+&#010;+        // for each invalid option build a reason message&#010;+        Map&lt;String, String&gt; options = new LinkedHashMap&lt;String, String&gt;();&#010;+        if (unknown != null) {&#010;+            for (String name : unknown) {&#010;+                if (unknownSuggestions != null &amp;&amp; unknownSuggestions.containsKey(name)) {&#010;+                    String[] suggestions = unknownSuggestions.get(name);&#010;+                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;+                        String str = Arrays.asList(suggestions).toString();&#010;+                        options.put(name, ""Unknown option. Did you mean: "" + str);&#010;+                    } else {&#010;+                        options.put(name, ""Unknown option"");&#010;+                    }&#010;+                } else {&#010;+                    options.put(name, ""Unknown option"");&#010;+                }&#010;+            }&#010;+        }&#010;+        if (notConsumerOnly != null) {&#010;+            for (String name : notConsumerOnly) {&#010;+                options.put(name, ""Option not applicable in consumer only mode"");&#010;+            }&#010;+        }&#010;+        if (notProducerOnly != null) {&#010;+            for (String name : notProducerOnly) {&#010;+                options.put(name, ""Option not applicable in producer only mode"");&#010;+            }&#010;+        }&#010;+        if (required != null) {&#010;+            for (String name : required) {&#010;+                options.put(name, ""Missing required option"");&#010;+            }&#010;+        }&#010;+        if (invalidEnum != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidEnum.entrySet()) {&#010;+                String name = entry.getKey();&#010;+                String[] choices = invalidEnumChoices.get(name);&#010;+                String defaultValue = defaultValues != null ? defaultValues.get(entry.getKey()) : null;&#010;+                String str = Arrays.asList(choices).toString();&#010;+                String msg = ""Invalid enum value: "" + entry.getValue() + "". Possible values: "" + str;&#010;+                if (invalidEnumSuggestions != null) {&#010;+                    String[] suggestions = invalidEnumSuggestions.get(name);&#010;+                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;+                        str = Arrays.asList(suggestions).toString();&#010;+                        msg += "". Did you mean: "" + str;&#010;+                    }&#010;+                }&#010;+                if (defaultValue != null) {&#010;+                    msg += "". Default value: "" + defaultValue;&#010;+                }&#010;+&#010;+                options.put(entry.getKey(), msg);&#010;+            }&#010;+        }&#010;+        if (invalidReference != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidReference.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty reference value"");&#010;+                } else if (!entry.getValue().startsWith(""#"")) {&#010;+                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue() + "" must start with #"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+        if (invalidBoolean != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidBoolean.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty boolean value"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid boolean value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+        if (invalidInteger != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidInteger.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty integer value"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid integer value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+        if (invalidNumber != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidNumber.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty number value"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid number value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // build a table with the error summary nicely formatted&#010;+        // lets use 24 as min length&#010;+        int maxLen = 24;&#010;+        for (String key : options.keySet()) {&#010;+            maxLen = Math.max(maxLen, key.length());&#010;+        }&#010;+        String format = ""%"" + maxLen + ""s    %s"";&#010;+&#010;+        // build the human error summary&#010;+        StringBuilder sb = new StringBuilder();&#010;+        if (includeHeader) {&#010;+            sb.append(""Endpoint validator error\n"");&#010;+            sb.append(""---------------------------------------------------------------------------------------------------------------------------------------\n"");&#010;+            sb.append(""\n"");&#010;+        }&#010;+        if (uri != null) {&#010;+            sb.append(""\t"").append(uri).append(""\n"");&#010;+        } else {&#010;+            sb.append(""\n"");&#010;+        }&#010;+        for (Map.Entry&lt;String, String&gt; option : options.entrySet()) {&#010;+            String out = String.format(format, option.getKey(), option.getValue());&#010;+            sb.append(""\n\t"").append(out);&#010;+        }&#010;+&#010;+        return sb.toString();&#010;+    }&#010;+}&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C0ffd278dae9f48d5849d5bd0dc60655f%40git.apache.org%3E,2017-04-14 10:52,commits,3.0,325.0,  [4/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
10,326.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java b/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&#010;deleted file mode 100644&#010;index 9bb98f0..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&#010;+++ /dev/null&#010;@@ -1,451 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.io.Serializable;&#010;-import java.util.Arrays;&#010;-import java.util.Collections;&#010;-import java.util.LinkedHashMap;&#010;-import java.util.LinkedHashSet;&#010;-import java.util.List;&#010;-import java.util.Map;&#010;-import java.util.Set;&#010;-&#010;-import static org.apache.camel.catalog.URISupport.isEmpty;&#010;-&#010;-/**&#010;- * Details result of validating endpoint uri.&#010;- */&#010;-public class EndpointValidationResult implements Serializable {&#010;-&#010;-    private final String uri;&#010;-    private int errors;&#010;-&#010;-    // general&#010;-    private String syntaxError;&#010;-    private String unknownComponent;&#010;-    private String incapable;&#010;-&#010;-    // options&#010;-    private Set&lt;String&gt; unknown;&#010;-    private Map&lt;String, String[]&gt; unknownSuggestions;&#010;-    private Set&lt;String&gt; lenient;&#010;-    private Set&lt;String&gt; notConsumerOnly;&#010;-    private Set&lt;String&gt; notProducerOnly;&#010;-    private Set&lt;String&gt; required;&#010;-    private Map&lt;String, String&gt; invalidEnum;&#010;-    private Map&lt;String, String[]&gt; invalidEnumChoices;&#010;-    private Map&lt;String, String[]&gt; invalidEnumSuggestions;&#010;-    private Map&lt;String, String&gt; invalidReference;&#010;-    private Map&lt;String, String&gt; invalidBoolean;&#010;-    private Map&lt;String, String&gt; invalidInteger;&#010;-    private Map&lt;String, String&gt; invalidNumber;&#010;-    private Map&lt;String, String&gt; defaultValues;&#010;-&#010;-    public EndpointValidationResult() {&#010;-        this(null);&#010;-    }&#010;-&#010;-    public EndpointValidationResult(String uri) {&#010;-        this.uri = uri;&#010;-    }&#010;-&#010;-    public String getUri() {&#010;-        return uri;&#010;-    }&#010;-&#010;-    public boolean hasErrors() {&#010;-        return errors &gt; 0;&#010;-    }&#010;-&#010;-    public int getNumberOfErrors() {&#010;-        return errors;&#010;-    }&#010;-&#010;-    public boolean isSuccess() {&#010;-        boolean ok = syntaxError == null &amp;&amp; unknownComponent == null &amp;&amp; incapable == null&#010;-                &amp;&amp; unknown == null &amp;&amp; required == null;&#010;-        if (ok) {&#010;-            ok = notConsumerOnly == null &amp;&amp; notProducerOnly == null;&#010;-        }&#010;-        if (ok) {&#010;-            ok = invalidEnum == null &amp;&amp; invalidEnumChoices == null &amp;&amp; invalidReference == null&#010;-                &amp;&amp; invalidBoolean == null &amp;&amp; invalidInteger == null &amp;&amp; invalidNumber == null;&#010;-        }&#010;-        return ok;&#010;-    }&#010;-&#010;-    public void addSyntaxError(String syntaxError) {&#010;-        this.syntaxError = syntaxError;&#010;-        errors++;&#010;-    }&#010;-&#010;-    public void addIncapable(String uri) {&#010;-        this.incapable = uri;&#010;-        errors++;&#010;-    }&#010;-&#010;-    public void addUnknownComponent(String name) {&#010;-        this.unknownComponent = name;&#010;-        errors++;&#010;-    }&#010;-&#010;-    public void addUnknown(String name) {&#010;-        if (unknown == null) {&#010;-            unknown = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!unknown.contains(name)) {&#010;-            unknown.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addUnknownSuggestions(String name, String[] suggestions) {&#010;-        if (unknownSuggestions == null) {&#010;-            unknownSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;-        }&#010;-        unknownSuggestions.put(name, suggestions);&#010;-    }&#010;-&#010;-    public void addLenient(String name) {&#010;-        if (lenient == null) {&#010;-            lenient = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!lenient.contains(name)) {&#010;-            lenient.add(name);&#010;-        }&#010;-    }&#010;-&#010;-    public void addRequired(String name) {&#010;-        if (required == null) {&#010;-            required = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!required.contains(name)) {&#010;-            required.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidEnum(String name, String value) {&#010;-        if (invalidEnum == null) {&#010;-            invalidEnum = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidEnum.containsKey(name)) {&#010;-            invalidEnum.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidEnumChoices(String name, String[] choices) {&#010;-        if (invalidEnumChoices == null) {&#010;-            invalidEnumChoices = new LinkedHashMap&lt;String, String[]&gt;();&#010;-        }&#010;-        invalidEnumChoices.put(name, choices);&#010;-    }&#010;-&#010;-    public void addInvalidEnumSuggestions(String name, String[] suggestions) {&#010;-        if (invalidEnumSuggestions == null) {&#010;-            invalidEnumSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;-        }&#010;-        invalidEnumSuggestions.put(name, suggestions);&#010;-    }&#010;-&#010;-    public void addInvalidReference(String name, String value) {&#010;-        if (invalidReference == null) {&#010;-            invalidReference = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidReference.containsKey(name)) {&#010;-            invalidReference.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidBoolean(String name, String value) {&#010;-        if (invalidBoolean == null) {&#010;-            invalidBoolean = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidBoolean.containsKey(name)) {&#010;-            invalidBoolean.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidInteger(String name, String value) {&#010;-        if (invalidInteger == null) {&#010;-            invalidInteger = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidInteger.containsKey(name)) {&#010;-            invalidInteger.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidNumber(String name, String value) {&#010;-        if (invalidNumber == null) {&#010;-            invalidNumber = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidNumber.containsKey(name)) {&#010;-            invalidNumber.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addDefaultValue(String name, String value)  {&#010;-        if (defaultValues == null) {&#010;-            defaultValues = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        defaultValues.put(name, value);&#010;-    }&#010;-&#010;-    public void addNotConsumerOnly(String name) {&#010;-        if (notConsumerOnly == null) {&#010;-            notConsumerOnly = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!notConsumerOnly.contains(name)) {&#010;-            notConsumerOnly.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addNotProducerOnly(String name) {&#010;-        if (notProducerOnly == null) {&#010;-            notProducerOnly = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!notProducerOnly.contains(name)) {&#010;-            notProducerOnly.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public String getSyntaxError() {&#010;-        return syntaxError;&#010;-    }&#010;-&#010;-    public String getIncapable() {&#010;-        return incapable;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getUnknown() {&#010;-        return unknown;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getLenient() {&#010;-        return lenient;&#010;-    }&#010;-&#010;-    public Map&lt;String, String[]&gt; getUnknownSuggestions() {&#010;-        return unknownSuggestions;&#010;-    }&#010;-&#010;-    public String getUnknownComponent() {&#010;-        return unknownComponent;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getRequired() {&#010;-        return required;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidEnum() {&#010;-        return invalidEnum;&#010;-    }&#010;-&#010;-    public Map&lt;String, String[]&gt; getInvalidEnumChoices() {&#010;-        return invalidEnumChoices;&#010;-    }&#010;-&#010;-    public List&lt;String&gt; getEnumChoices(String optionName) {&#010;-        if (invalidEnumChoices != null) {&#010;-            String[] enums = invalidEnumChoices.get(optionName);&#010;-            if (enums != null) {&#010;-                return Arrays.asList(enums);&#010;-            }&#010;-        }&#010;-&#010;-        return Collections.emptyList();&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidReference() {&#010;-        return invalidReference;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidBoolean() {&#010;-        return invalidBoolean;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidInteger() {&#010;-        return invalidInteger;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidNumber() {&#010;-        return invalidNumber;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getDefaultValues() {&#010;-        return defaultValues;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getNotConsumerOnly() {&#010;-        return notConsumerOnly;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getNotProducerOnly() {&#010;-        return notProducerOnly;&#010;-    }&#010;-&#010;-    /**&#010;-     * A human readable summary of the validation errors.&#010;-     *&#010;-     * @param includeHeader whether to include a header&#010;-     * @return the summary, or &lt;tt&gt;null&lt;/tt&gt; if no validation errors&#010;-     */&#010;-    public String summaryErrorMessage(boolean includeHeader) {&#010;-        if (isSuccess()) {&#010;-            return null;&#010;-        }&#010;-&#010;-        if (incapable != null) {&#010;-            return ""\tIncapable of parsing uri: "" + incapable;&#010;-        } else if (syntaxError != null) {&#010;-            return ""\tSyntax error: "" + syntaxError;&#010;-        } else if (unknownComponent != null) {&#010;-            return ""\tUnknown component: "" + unknownComponent;&#010;-        }&#010;-&#010;-        // for each invalid option build a reason message&#010;-        Map&lt;String, String&gt; options = new LinkedHashMap&lt;String, String&gt;();&#010;-        if (unknown != null) {&#010;-            for (String name : unknown) {&#010;-                if (unknownSuggestions != null &amp;&amp; unknownSuggestions.containsKey(name)) {&#010;-                    String[] suggestions = unknownSuggestions.get(name);&#010;-                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;-                        String str = Arrays.asList(suggestions).toString();&#010;-                        options.put(name, ""Unknown option. Did you mean: "" + str);&#010;-                    } else {&#010;-                        options.put(name, ""Unknown option"");&#010;-                    }&#010;-                } else {&#010;-                    options.put(name, ""Unknown option"");&#010;-                }&#010;-            }&#010;-        }&#010;-        if (notConsumerOnly != null) {&#010;-            for (String name : notConsumerOnly) {&#010;-                options.put(name, ""Option not applicable in consumer only mode"");&#010;-            }&#010;-        }&#010;-        if (notProducerOnly != null) {&#010;-            for (String name : notProducerOnly) {&#010;-                options.put(name, ""Option not applicable in producer only mode"");&#010;-            }&#010;-        }&#010;-        if (required != null) {&#010;-            for (String name : required) {&#010;-                options.put(name, ""Missing required option"");&#010;-            }&#010;-        }&#010;-        if (invalidEnum != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidEnum.entrySet()) {&#010;-                String name = entry.getKey();&#010;-                String[] choices = invalidEnumChoices.get(name);&#010;-                String defaultValue = defaultValues != null ? defaultValues.get(entry.getKey()) : null;&#010;-                String str = Arrays.asList(choices).toString();&#010;-                String msg = ""Invalid enum value: "" + entry.getValue() + "". Possible values: "" + str;&#010;-                if (invalidEnumSuggestions != null) {&#010;-                    String[] suggestions = invalidEnumSuggestions.get(name);&#010;-                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;-                        str = Arrays.asList(suggestions).toString();&#010;-                        msg += "". Did you mean: "" + str;&#010;-                    }&#010;-                }&#010;-                if (defaultValue != null) {&#010;-                    msg += "". Default value: "" + defaultValue;&#010;-                }&#010;-&#010;-                options.put(entry.getKey(), msg);&#010;-            }&#010;-        }&#010;-        if (invalidReference != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidReference.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty reference value"");&#010;-                } else if (!entry.getValue().startsWith(""#"")) {&#010;-                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue() + "" must start with #"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-        if (invalidBoolean != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidBoolean.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty boolean value"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid boolean value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-        if (invalidInteger != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidInteger.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty integer value"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid integer value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-        if (invalidNumber != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidNumber.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty number value"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid number value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-&#010;-        // build a table with the error summary nicely formatted&#010;-        // lets use 24 as min length&#010;-        int maxLen = 24;&#010;-        for (String key : options.keySet()) {&#010;-            maxLen = Math.max(maxLen, key.length());&#010;-        }&#010;-        String format = ""%"" + maxLen + ""s    %s"";&#010;-&#010;-        // build the human error summary&#010;-        StringBuilder sb = new StringBuilder();&#010;-        if (includeHeader) {&#010;-            sb.append(""Endpoint validator error\n"");&#010;-            sb.append(""---------------------------------------------------------------------------------------------------------------------------------------\n"");&#010;-            sb.append(""\n"");&#010;-        }&#010;-        if (uri != null) {&#010;-            sb.append(""\t"").append(uri).append(""\n"");&#010;-        } else {&#010;-            sb.append(""\n"");&#010;-        }&#010;-        for (Map.Entry&lt;String, String&gt; option : options.entrySet()) {&#010;-            String out = String.format(format, option.getKey(), option.getValue());&#010;-            sb.append(""\n\t"").append(out);&#010;-        }&#010;-&#010;-        return sb.toString();&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java b/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&#010;deleted file mode 100644&#010;index 774facd..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&#010;+++ /dev/null&#010;@@ -1,424 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.ArrayList;&#010;-import java.util.LinkedHashMap;&#010;-import java.util.LinkedHashSet;&#010;-import java.util.List;&#010;-import java.util.Map;&#010;-import java.util.Set;&#010;-import java.util.regex.Matcher;&#010;-import java.util.regex.Pattern;&#010;-&#010;-public final class JSonSchemaHelper {&#010;-&#010;-    // 0 = text, 1 = enum, 2 = boolean, 3 = integer or number&#010;-    private static final Pattern PATTERN = Pattern.compile(""\""(.+?)\""|\\[(.+)\\]|(true|false)|(-?\\d+\\.?\\d*)"");&#010;-    private static final String QUOT = ""&amp;quot;"";&#010;-&#010;-    private JSonSchemaHelper() {&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the json schema to split it into a list or rows, where each row contains key value pairs with the metadata&#010;-     *&#010;-     * @param group the group to parse from such as &lt;tt&gt;component&lt;/tt&gt;, &lt;tt&gt;componentProperties&lt;/tt&gt;, or &lt;tt&gt;properties&lt;/tt&gt;.&#010;-     * @param json the json&#010;-     * @return a list of all the rows, where each row is a set of key value pairs with metadata&#010;-     */&#010;-    public static List&lt;Map&lt;String, String&gt;&gt; parseJsonSchema(String group, String json, boolean parseProperties) {&#010;-        List&lt;Map&lt;String, String&gt;&gt; answer = new ArrayList&lt;Map&lt;String, String&gt;&gt;();&#010;-        if (json == null) {&#010;-            return answer;&#010;-        }&#010;-&#010;-        boolean found = false;&#010;-&#010;-        // parse line by line&#010;-        String[] lines = json.split(""\n"");&#010;-        for (String line : lines) {&#010;-            // we need to find the group first&#010;-            if (!found) {&#010;-                String s = line.trim();&#010;-                found = s.startsWith(""\"""" + group + ""\"":"") &amp;&amp; s.endsWith(""{"");&#010;-                continue;&#010;-            }&#010;-&#010;-            // we should stop when we end the group&#010;-            if (line.equals(""  },"") || line.equals(""  }"")) {&#010;-                break;&#010;-            }&#010;-&#010;-            // need to safe encode \"" so we can parse the line&#010;-            line = line.replaceAll(""\""\\\\\""\"""", '""' + QUOT + '""');&#010;-&#010;-            Map&lt;String, String&gt; row = new LinkedHashMap&lt;String, String&gt;();&#010;-            Matcher matcher = PATTERN.matcher(line);&#010;-&#010;-            String key;&#010;-            if (parseProperties) {&#010;-                // when parsing properties the first key is given as name, so the first parsed token is the value of the name&#010;-                key = ""name"";&#010;-            } else {&#010;-                key = null;&#010;-            }&#010;-            while (matcher.find()) {&#010;-                if (key == null) {&#010;-                    key = matcher.group(1);&#010;-                } else {&#010;-                    String value = matcher.group(1);&#010;-                    if (value != null) {&#010;-                        // its text based&#010;-                        value = value.trim();&#010;-                        // decode&#010;-                        value = value.replaceAll(QUOT, ""\"""");&#010;-                        value = decodeJson(value);&#010;-                    }&#010;-                    if (value == null) {&#010;-                        // not text then its maybe an enum?&#010;-                        value = matcher.group(2);&#010;-                        if (value != null) {&#010;-                            // its an enum so strip out "" and trim spaces after comma&#010;-                            value = value.replaceAll(""\"""", """");&#010;-                            value = value.replaceAll("", "", "","");&#010;-                            value = value.trim();&#010;-                        }&#010;-                    }&#010;-                    if (value == null) {&#010;-                        // not text then its maybe a boolean?&#010;-                        value = matcher.group(3);&#010;-                    }&#010;-                    if (value == null) {&#010;-                        // not text then its maybe a integer?&#010;-                        value = matcher.group(4);&#010;-                    }&#010;-                    if (value != null) {&#010;-                        row.put(key, value);&#010;-                    }&#010;-                    // reset&#010;-                    key = null;&#010;-                }&#010;-            }&#010;-            if (!row.isEmpty()) {&#010;-                answer.add(row);&#010;-            }&#010;-        }&#010;-&#010;-        return answer;&#010;-    }&#010;-&#010;-    private static String decodeJson(String value) {&#010;-        // json encodes a \ as \\ so we need to decode from \\ back to \&#010;-        if (""\\\\"".equals(value)) {&#010;-            value = ""\\"";&#010;-        }&#010;-        return value;&#010;-    }&#010;-&#010;-    public static boolean isComponentLenientProperties(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""lenientProperties"")) {&#010;-                return ""true"".equals(row.get(""lenientProperties""));&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isComponentConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""consumerOnly"")) {&#010;-                return ""true"".equals(row.get(""consumerOnly""));&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isComponentProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""producerOnly"")) {&#010;-                return ""true"".equals(row.get(""producerOnly""));&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String labels = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""label"")) {&#010;-                labels = row.get(""label"");&#010;-            }&#010;-            if (found) {&#010;-                return labels != null &amp;&amp; labels.contains(""consumer"");&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String labels = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""label"")) {&#010;-                labels = row.get(""label"");&#010;-            }&#010;-            if (found) {&#010;-                return labels != null &amp;&amp; labels.contains(""producer"");&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyRequired(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            boolean required = false;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""required"")) {&#010;-                required = ""true"".equals(row.get(""required""));&#010;-            }&#010;-            if (found) {&#010;-                return required;&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static String getPropertyKind(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String kind = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""kind"")) {&#010;-                kind = row.get(""kind"");&#010;-            }&#010;-            if (found) {&#010;-                return kind;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static boolean isPropertyBoolean(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""boolean"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyInteger(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""integer"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyNumber(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""number"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyObject(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""object"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static String getPropertyDefaultValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String defaultValue = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""defaultValue"")) {&#010;-                defaultValue = row.get(""defaultValue"");&#010;-            }&#010;-            if (found) {&#010;-                return defaultValue;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static String stripOptionalPrefixFromName(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String optionalPrefix = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""optionalPrefix"")) {&#010;-                optionalPrefix = row.get(""optionalPrefix"");&#010;-            }&#010;-            if (row.containsKey(""name"")) {&#010;-                if (optionalPrefix != null &amp;&amp; name.startsWith(optionalPrefix)) {&#010;-                    name = name.substring(optionalPrefix.length());&#010;-                    // try again&#010;-                    return stripOptionalPrefixFromName(rows, name);&#010;-                } else {&#010;-                    found = name.equals(row.get(""name""));&#010;-                }&#010;-            }&#010;-            if (found) {&#010;-                return name;&#010;-            }&#010;-        }&#010;-        return name;&#010;-    }&#010;-&#010;-    public static String getPropertyEnum(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String enums = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""enum"")) {&#010;-                enums = row.get(""enum"");&#010;-            }&#010;-            if (found) {&#010;-                return enums;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static String getPropertyPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String prefix = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""prefix"")) {&#010;-                prefix = row.get(""prefix"");&#010;-            }&#010;-            if (found) {&#010;-                return prefix;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static boolean isPropertyMultiValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            boolean multiValue = false;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""multiValue"")) {&#010;-                multiValue = ""true"".equals(row.get(""multiValue""));&#010;-            }&#010;-            if (found) {&#010;-                return multiValue;&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static String getPropertyNameFromNameWithPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String propertyName = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                propertyName = row.get(""name"");&#010;-            }&#010;-            if (row.containsKey(""prefix"")) {&#010;-                String preifx = row.get(""prefix"");&#010;-                found = name.startsWith(preifx);&#010;-            }&#010;-            if (found) {&#010;-                return propertyName;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static Map&lt;String, String&gt; getRow(List&lt;Map&lt;String, String&gt;&gt; rows, String key) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (key.equals(row.get(""name""))) {&#010;-                return row;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static Set&lt;String&gt; getNames(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        Set&lt;String&gt; answer = new LinkedHashSet&lt;String&gt;();&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""name"")) {&#010;-                answer.add(row.get(""name""));&#010;-            }&#010;-        }&#010;-        return answer;&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java b/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&#010;deleted file mode 100644&#010;index 9bf09cc..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&#010;+++ /dev/null&#010;@@ -1,64 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-/**&#010;- * Pluggable resolver to load JSon schema files for components, data formats, languages etc.&#010;- */&#010;-public interface JSonSchemaResolver {&#010;-&#010;-    /**&#010;-     * Returns the component information as JSon format.&#010;-     *&#010;-     * @param name the component name&#010;-     * @return component details in JSon&#010;-     */&#010;-    String getComponentJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the data format information as JSon format.&#010;-     *&#010;-     * @param name the data format name&#010;-     * @return data format details in JSon&#010;-     */&#010;-    String getDataFormatJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the language information as JSon format.&#010;-     *&#010;-     * @param name the language name&#010;-     * @return language details in JSon&#010;-     */&#010;-    String getLanguageJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the other (miscellaneous) information as JSon format.&#010;-     *&#010;-     * @param name the other (miscellaneous) name&#010;-     * @return other (miscellaneous) details in JSon&#010;-     */&#010;-    String getOtherJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the model information as JSon format.&#010;-     *&#010;-     * @param name the model name&#010;-     * @return model details in JSon&#010;-     */&#010;-    String getModelJSonSchema(String name);&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java b/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&#010;deleted file mode 100644&#010;index 4a977eb..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&#010;+++ /dev/null&#010;@@ -1,65 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.io.Serializable;&#010;-&#010;-/**&#010;- * Validation result of parsing a language expression or predicate&#010;- */&#010;-public class LanguageValidationResult implements Serializable {&#010;-    private final String text;&#010;-    private String error;&#010;-    private String shortError;&#010;-    private int index;&#010;-&#010;-    public LanguageValidationResult(String text) {&#010;-        this.text = text;&#010;-    }&#010;-&#010;-    public String getText() {&#010;-        return text;&#010;-    }&#010;-&#010;-    public boolean isSuccess() {&#010;-        return error == null;&#010;-    }&#010;-&#010;-    public void setError(String error) {&#010;-        this.error = error;&#010;-    }&#010;-&#010;-    public String getError() {&#010;-        return error;&#010;-    }&#010;-&#010;-    public String getShortError() {&#010;-        return shortError;&#010;-    }&#010;-&#010;-    public void setShortError(String shortError) {&#010;-        this.shortError = shortError;&#010;-    }&#010;-&#010;-    public int getIndex() {&#010;-        return index;&#010;-    }&#010;-&#010;-    public void setIndex(int index) {&#010;-        this.index = index;&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java&#010;deleted file mode 100644&#010;index b46edab..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java&#010;+++ /dev/null&#010;@@ -1,234 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.net.URISyntaxException;&#010;-import java.util.Map;&#010;-&#010;-import org.apache.camel.StaticService;&#010;-&#010;-/**&#010;- * Runtime based CamelCatalog which are included in camel-core that can provided limit CamelCatalog capabilities&#010;- */&#010;-public interface RuntimeCamelCatalog extends StaticService {&#010;-&#010;-    /**&#010;-     * Returns the component information as JSon format.&#010;-     *&#010;-     * @param name the component name&#010;-     * @return component details in JSon&#010;-     */&#010;-    String componentJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the data format information as JSon format.&#010;-     *&#010;-     * @param name the data format name&#010;-     * @return data format details in JSon&#010;-     */&#010;-    String dataFormatJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the language information as JSon format.&#010;-     *&#010;-     * @param name the language name&#010;-     * @return language details in JSon&#010;-     */&#010;-    String languageJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the model information as JSon format.&#010;-     *&#010;-     * @param name the model name&#010;-     * @return model details in JSon&#010;-     */&#010;-    String modelJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Parses the endpoint uri and constructs a key/value properties of each option&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return properties as key value pairs of each endpoint option&#010;-     */&#010;-    Map&lt;String, String&gt; endpointProperties(String uri) throws URISyntaxException;&#010;-&#010;-    /**&#010;-     * Parses the endpoint uri and constructs a key/value properties of only the lenient properties (eg custom options)&#010;-     * &lt;p/&gt;&#010;-     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return properties as key value pairs of each lenient properties&#010;-     */&#010;-    Map&lt;String, String&gt; endpointLenientProperties(String uri) throws URISyntaxException;&#010;-&#010;-    /**&#010;-     * Validates the pattern whether its a valid time pattern.&#010;-     *&#010;-     * @param pattern  the pattern such as 5000, 5s, 5sec, 4min, 4m30s, 1h, etc.&#010;-     * @return &lt;tt&gt;true&lt;/tt&gt; if valid, &lt;tt&gt;false&lt;/tt&gt; if invalid&#010;-     */&#010;-    boolean validateTimePattern(String pattern);&#010;-&#010;-    /**&#010;-     * Validates the properties for the given scheme against component and endpoint&#010;-     *&#010;-     * @param scheme  the endpoint scheme&#010;-     * @param properties  the endpoint properties&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateProperties(String scheme, Map&lt;String, String&gt; properties);&#010;-&#010;-    /**&#010;-     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateEndpointProperties(String uri);&#010;-&#010;-    /**&#010;-     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;-     * &lt;p/&gt;&#010;-     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;-     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;-     * but in the uri because of using lenient properties.&#010;-     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties);&#010;-&#010;-    /**&#010;-     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;-     * &lt;p/&gt;&#010;-     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;-     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;-     * but in the uri because of using lenient properties.&#010;-     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;-     * @param consumerOnly whether the endpoint is only used as a consumer&#010;-     * @param producerOnly whether the endpoint is only used as a producer&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties, boolean consumerOnly, boolean producerOnly);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple expression.&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param simple  the simple expression&#010;-     * @return validation result&#010;-     * @deprecated use {@link #validateSimpleExpression(ClassLoader, String)}&#010;-     */&#010;-    @Deprecated&#010;-    SimpleValidationResult validateSimpleExpression(String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple expression.&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param simple  the simple expression&#010;-     * @return validation result&#010;-     */&#010;-    SimpleValidationResult validateSimpleExpression(ClassLoader classLoader, String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple predicate&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param simple  the simple predicate&#010;-     * @return validation result&#010;-     * @deprecated use {@link #validateSimplePredicate(ClassLoader, String)}&#010;-     */&#010;-    @Deprecated&#010;-    SimpleValidationResult validateSimplePredicate(String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple predicate&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param simple  the simple predicate&#010;-     * @return validation result&#010;-     */&#010;-    SimpleValidationResult validateSimplePredicate(ClassLoader classLoader, String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the language as a predicate&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param language the name of the language&#010;-     * @param text  the predicate text&#010;-     * @return validation result&#010;-     */&#010;-    LanguageValidationResult validateLanguagePredicate(ClassLoader classLoader, String language, String text);&#010;-&#010;-    /**&#010;-     * Parses and validates the language as an expression&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param language the name of the language&#010;-     * @param text  the expression text&#010;-     * @return validation result&#010;-     */&#010;-    LanguageValidationResult validateLanguageExpression(ClassLoader classLoader, String language, String text);&#010;-&#010;-    /**&#010;-     * Returns the component name from the given endpoint uri&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return the component name (aka scheme), or &lt;tt&gt;null&lt;/tt&gt; if not possible to determine&#010;-     */&#010;-    String endpointComponentName(String uri);&#010;-&#010;-    /**&#010;-     * Creates an endpoint uri in Java style from the information from the properties&#010;-     *&#010;-     * @param scheme the endpoint schema&#010;-     * @param properties the properties as key value pairs&#010;-     * @param encode whether to URL encode the returned uri or not&#010;-     * @return the constructed endpoint uri&#010;-     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;-     */&#010;-    String asEndpointUri(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;-&#010;-    /**&#010;-     * Creates an endpoint uri in XML style (eg escape &amp; as &amp;ampl;) from the information from the properties&#010;-     *&#010;-     * @param scheme the endpoint schema&#010;-     * @param properties the properties as key value pairs&#010;-     * @param encode whether to URL encode the returned uri or not&#010;-     * @return the constructed endpoint uri&#010;-     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;-     */&#010;-    String asEndpointUriXml(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java b/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&#010;deleted file mode 100644&#010;index 5c86f23..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&#010;+++ /dev/null&#010;@@ -1,32 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-/**&#010;- * To be backwards compatible, but favor using {@link LanguageValidationResult} instead.&#010;- */&#010;-public class SimpleValidationResult extends LanguageValidationResult {&#010;-&#010;-    public SimpleValidationResult(String text) {&#010;-        super(text);&#010;-    }&#010;-&#010;-    public String getSimple() {&#010;-        return getText();&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java b/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&#010;deleted file mode 100644&#010;index 057d372..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&#010;+++ /dev/null&#010;@@ -1,34 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.Set;&#010;-&#010;-/**&#010;- * Strategy to provide suggestions for unknown endpoint options&#010;- */&#010;-public interface SuggestionStrategy {&#010;-&#010;-    /**&#010;-     * Provides a list of valid option names for a did you mean function.&#010;-     *&#010;-     * @param names         valid names&#010;-     * @param unknownOption unknown option name&#010;-     * @return a list of suggested names (did you mean)&#010;-     */&#010;-    String[] suggestEndpointOptions(Set&lt;String&gt; names, String unknownOption);&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java b/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&#010;deleted file mode 100644&#010;index 4ed843a..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&#010;+++ /dev/null&#010;@@ -1,120 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.regex.Matcher;&#010;-import java.util.regex.Pattern;&#010;-&#010;-/**&#010;- * This class is a copy from camel-core so we can use it independent to validate uris with time patterns&#010;- */&#010;-public final class TimePatternConverter {&#010;-    private static final Pattern NUMBERS_ONLY_STRING_PATTERN = Pattern.compile(""^[-]?(\\d)+$"", Pattern.CASE_INSENSITIVE);&#010;-    private static final Pattern HOUR_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))h(our(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;-    private static final Pattern MINUTES_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))m(in(ute(s)?)?)?"", Pattern.CASE_INSENSITIVE);&#010;-    private static final Pattern SECONDS_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))s(ec(ond)?(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;-&#010;-    /**&#010;-     * Utility classes should not have a public constructor.&#010;-     */&#010;-    private TimePatternConverter() {&#010;-    }&#010;-&#010;-    public static long toMilliSeconds(String source) throws IllegalArgumentException {&#010;-        long milliseconds = 0;&#010;-        boolean foundFlag = false;&#010;-&#010;-        checkCorrectnessOfPattern(source);&#010;-        Matcher matcher;&#010;-&#010;-        matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;-        if (matcher.find()) {&#010;-            // Note: This will also be used for regular numeric strings.&#010;-            //       This String -&gt; long converter will be used for all strings.&#010;-            milliseconds = Long.valueOf(source);&#010;-        } else {&#010;-            matcher = createMatcher(HOUR_REGEX_PATTERN, source);&#010;-            if (matcher.find()) {&#010;-                milliseconds = milliseconds + (3600000 * Long.valueOf(matcher.group(1)));&#010;-                foundFlag = true;&#010;-            }&#010;-&#010;-            matcher = createMatcher(MINUTES_REGEX_PATTERN, source);&#010;-            if (matcher.find()) {&#010;-                long minutes = Long.valueOf(matcher.group(1));&#010;-                if ((minutes &gt; 59) &amp;&amp; foundFlag) {&#010;-                    throw new IllegalArgumentException(""Minutes should contain a valid value between 0 and 59: "" + source);&#010;-                }&#010;-                foundFlag = true;&#010;-                milliseconds = milliseconds + (60000 * minutes);&#010;-            }&#010;-&#010;-            matcher = createMatcher(SECONDS_REGEX_PATTERN, source);&#010;-            if (matcher.find()) {&#010;-                long seconds = Long.valueOf(matcher.group(1));&#010;-                if ((seconds &gt; 59) &amp;&amp; foundFlag) {&#010;-                    throw new IllegalArgumentException(""Seconds should contain a valid value between 0 and 59: "" + source);&#010;-                }&#010;-                foundFlag = true;&#010;-                milliseconds = milliseconds + (1000 * seconds);&#010;-            }&#010;-&#010;-            // No pattern matched... initiating fallback check and conversion (if required).&#010;-            // The source at this point may contain illegal values or special characters&#010;-            if (!foundFlag) {&#010;-                milliseconds = Long.valueOf(source);&#010;-            }&#010;-        }&#010;-&#010;-        return milliseconds;&#010;-    }&#010;-&#010;-    private static void checkCorrectnessOfPattern(String source) {&#010;-        //replace only numbers once&#010;-        Matcher matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;-        String replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        //replace hour string once&#010;-        matcher = createMatcher(HOUR_REGEX_PATTERN, replaceSource);&#010;-        if (matcher.find() &amp;&amp; matcher.find()) {&#010;-            throw new IllegalArgumentException(""Hours should not be specified more then once: "" + source);&#010;-        }&#010;-        replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        //replace minutes once&#010;-        matcher = createMatcher(MINUTES_REGEX_PATTERN, replaceSource);&#010;-        if (matcher.find() &amp;&amp; matcher.find()) {&#010;-            throw new IllegalArgumentException(""Minutes should not be specified more then once: "" + source);&#010;-        }&#010;-        replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        //replace seconds once&#010;-        matcher = createMatcher(SECONDS_REGEX_PATTERN, replaceSource);&#010;-        if (matcher.find() &amp;&amp; matcher.find()) {&#010;-            throw new IllegalArgumentException(""Seconds should not be specified more then once: "" + source);&#010;-        }&#010;-        replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        if (replaceSource.length() &gt; 0) {&#010;-            throw new IllegalArgumentException(""Illegal characters: "" + source);&#010;-        }&#010;-    }&#010;-&#010;-    private static Matcher createMatcher(Pattern pattern, String source) {&#010;-        return pattern.matcher(source);&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java b/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java&#010;deleted file mode 100644&#010;index ea1ecd5..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java&#010;+++ /dev/null&#010;@@ -1,392 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.io.UnsupportedEncodingException;&#010;-import java.net.URI;&#010;-import java.net.URISyntaxException;&#010;-import java.net.URLDecoder;&#010;-import java.net.URLEncoder;&#010;-import java.util.ArrayList;&#010;-import java.util.Iterator;&#010;-import java.util.LinkedHashMap;&#010;-import java.util.List;&#010;-import java.util.Map;&#010;-&#010;-/**&#010;- * Copied from org.apache.camel.util.URISupport&#010;- */&#010;-public final class URISupport {&#010;-&#010;-    public static final String RAW_TOKEN_START = ""RAW("";&#010;-    public static final String RAW_TOKEN_END = "")"";&#010;-&#010;-    private static final String CHARSET = ""UTF-8"";&#010;-&#010;-    private URISupport() {&#010;-        // Helper class&#010;-    }&#010;-&#010;-    /**&#010;-     * Normalizes the URI so unsafe characters is encoded&#010;-     *&#010;-     * @param uri the input uri&#010;-     * @return as URI instance&#010;-     * @throws URISyntaxException is thrown if syntax error in the input uri&#010;-     */&#010;-    public static URI normalizeUri(String uri) throws URISyntaxException {&#010;-        return new URI(UnsafeUriCharactersEncoder.encode(uri, true));&#010;-    }&#010;-&#010;-    public static Map&lt;String, Object&gt; extractProperties(Map&lt;String, Object&gt; properties, String optionPrefix) {&#010;-        Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;(properties.size());&#010;-&#010;-        for (Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; it = properties.entrySet().iterator(); it.hasNext();) {&#010;-            Map.Entry&lt;String, Object&gt; entry = it.next();&#010;-            String name = entry.getKey();&#010;-            if (name.startsWith(optionPrefix)) {&#010;-                Object value = properties.get(name);&#010;-                name = name.substring(optionPrefix.length());&#010;-                rc.put(name, value);&#010;-                it.remove();&#010;-            }&#010;-        }&#010;-&#010;-        return rc;&#010;-    }&#010;-&#010;-    /**&#010;-     * Strips the query parameters from the uri&#010;-     *&#010;-     * @param uri  the uri&#010;-     * @return the uri without the query parameter&#010;-     */&#010;-    public static String stripQuery(String uri) {&#010;-        int idx = uri.indexOf('?');&#010;-        if (idx &gt; -1) {&#010;-            uri = uri.substring(0, idx);&#010;-        }&#010;-        return uri;&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the query parameters of the uri (eg the query part).&#010;-     *&#010;-     * @param uri the uri&#010;-     * @return the parameters, or an empty map if no parameters (eg never null)&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     */&#010;-    public static Map&lt;String, Object&gt; parseParameters(URI uri) throws URISyntaxException {&#010;-        String query = uri.getQuery();&#010;-        if (query == null) {&#010;-            String schemeSpecificPart = uri.getSchemeSpecificPart();&#010;-            int idx = schemeSpecificPart.indexOf('?');&#010;-            if (idx &lt; 0) {&#010;-                // return an empty map&#010;-                return new LinkedHashMap&lt;String, Object&gt;(0);&#010;-            } else {&#010;-                query = schemeSpecificPart.substring(idx + 1);&#010;-            }&#010;-        } else {&#010;-            query = stripPrefix(query, ""?"");&#010;-        }&#010;-        return parseQuery(query);&#010;-    }&#010;-&#010;-    /**&#010;-     * Strips the prefix from the value.&#010;-     * &lt;p/&gt;&#010;-     * Returns the value as-is if not starting with the prefix.&#010;-     *&#010;-     * @param value  the value&#010;-     * @param prefix the prefix to remove from value&#010;-     * @return the value without the prefix&#010;-     */&#010;-    public static String stripPrefix(String value, String prefix) {&#010;-        if (value != null &amp;&amp; value.startsWith(prefix)) {&#010;-            return value.substring(prefix.length());&#010;-        }&#010;-        return value;&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the query part of the uri (eg the parameters).&#010;-     * &lt;p/&gt;&#010;-     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;-     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;-     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;-     *&#010;-     * @param uri the uri&#010;-     * @return the parameters, or an empty map if no parameters (eg never null)&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     * @see #RAW_TOKEN_START&#010;-     * @see #RAW_TOKEN_END&#010;-     */&#010;-    public static Map&lt;String, Object&gt; parseQuery(String uri) throws URISyntaxException {&#010;-        return parseQuery(uri, false);&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the query part of the uri (eg the parameters).&#010;-     * &lt;p/&gt;&#010;-     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;-     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;-     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;-     *&#010;-     * @param uri the uri&#010;-     * @param useRaw whether to force using raw values&#010;-     * @return the parameters, or an empty map if no parameters (eg never null)&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     * @see #RAW_TOKEN_START&#010;-     * @see #RAW_TOKEN_END&#010;-     */&#010;-    public static Map&lt;String, Object&gt; parseQuery(String uri, boolean useRaw) throws URISyntaxException {&#010;-        // must check for trailing &amp; as the uri.split(""&amp;"") will ignore those&#010;-        if (uri != null &amp;&amp; uri.endsWith(""&amp;"")) {&#010;-            throw new URISyntaxException(uri, ""Invalid uri syntax: Trailing &amp; marker found. ""&#010;-                    + ""Check the uri and remove the trailing &amp; marker."");&#010;-        }&#010;-&#010;-        if (isEmpty(uri)) {&#010;-            // return an empty map&#010;-            return new LinkedHashMap&lt;String, Object&gt;(0);&#010;-        }&#010;-&#010;-        // need to parse the uri query parameters manually as we cannot rely on splitting by &amp;,&#010;-        // as &amp; can be used in a parameter value as well.&#010;-&#010;-        try {&#010;-            // use a linked map so the parameters is in the same order&#010;-            Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;();&#010;-&#010;-            boolean isKey = true;&#010;-            boolean isValue = false;&#010;-            boolean isRaw = false;&#010;-            StringBuilder key = new StringBuilder();&#010;-            StringBuilder value = new StringBuilder();&#010;-&#010;-            // parse the uri parameters char by char&#010;-            for (int i = 0; i &lt; uri.length(); i++) {&#010;-                // current char&#010;-                char ch = uri.charAt(i);&#010;-                // look ahead of the next char&#010;-                char next;&#010;-                if (i &lt;= uri.length() - 2) {&#010;-                    next = uri.charAt(i + 1);&#010;-                } else {&#010;-                    next = '\u0000';&#010;-                }&#010;-&#010;-                // are we a raw value&#010;-                isRaw = value.toString().startsWith(RAW_TOKEN_START);&#010;-&#010;-                // if we are in raw mode, then we keep adding until we hit the end marker&#010;-                if (isRaw) {&#010;-                    if (isKey) {&#010;-                        key.append(ch);&#010;-                    } else if (isValue) {&#010;-                        value.append(ch);&#010;-                    }&#010;-&#010;-                    // we only end the raw marker if its )&amp; or at the end of the value&#010;-&#010;-                    boolean end = ch == RAW_TOKEN_END.charAt(0) &amp;&amp; (next == '&amp;' || next == '\u0000');&#010;-                    if (end) {&#010;-                        // raw value end, so add that as a parameter, and reset flags&#010;-                        addParameter(key.toString(), value.toString(), rc, useRaw || isRaw);&#010;-                        key.setLength(0);&#010;-                        value.setLength(0);&#010;-                        isKey = true;&#010;-                        isValue = false;&#010;-                        isRaw = false;&#010;-                        // skip to next as we are in raw mode and have already added the value&#010;-                        i++;&#010;-                    }&#010;-                    continue;&#010;-                }&#010;-&#010;-                // if its a key and there is a = sign then the key ends and we are in value mode&#010;-                if (isKey &amp;&amp; ch == '=') {&#010;-                    isKey = false;&#010;-                    isValue = true;&#010;-                    isRaw = false;&#010;-                    continue;&#010;-                }&#010;-&#010;-                // the &amp; denote parameter is ended&#010;-                if (ch == '&amp;') {&#010;-                    // parameter is ended, as we hit &amp; separator&#010;-                    String aKey = key.toString();&#010;-                    // the key may be a placeholder of options which we then do not know what is&#010;-                    boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;-                    if (validKey) {&#010;-                        addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;-                    }&#010;-                    key.setLength(0);&#010;-                    value.setLength(0);&#010;-                    isKey = true;&#010;-                    isValue = false;&#010;-                    isRaw = false;&#010;-                    continue;&#010;-                }&#010;-&#010;-                // regular char so add it to the key or value&#010;-                if (isKey) {&#010;-                    key.append(ch);&#010;-                } else if (isValue) {&#010;-                    value.append(ch);&#010;-                }&#010;-            }&#010;-&#010;-            // any left over parameters, then add that&#010;-            if (key.length() &gt; 0) {&#010;-                String aKey = key.toString();&#010;-                // the key may be a placeholder of options which we then do not know what is&#010;-                boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;-                if (validKey) {&#010;-                    addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;-                }&#010;-            }&#010;-&#010;-            return rc;&#010;-&#010;-        } catch (UnsupportedEncodingException e) {&#010;-            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;-            se.initCause(e);&#010;-            throw se;&#010;-        }&#010;-    }&#010;-&#010;-    @SuppressWarnings(""unchecked"")&#010;-    private static void addParameter(String name, String value, Map&lt;String, Object&gt; map, boolean isRaw) throws UnsupportedEncodingException {&#010;-        name = URLDecoder.decode(name, CHARSET);&#010;-        if (!isRaw) {&#010;-            // need to replace % with %25&#010;-            value = URLDecoder.decode(value.replaceAll(""%"", ""%25""), CHARSET);&#010;-        }&#010;-&#010;-        // does the key already exist?&#010;-        if (map.containsKey(name)) {&#010;-            // yes it does, so make sure we can support multiple values, but using a list&#010;-            // to hold the multiple values&#010;-            Object existing = map.get(name);&#010;-            List&lt;String&gt; list;&#010;-            if (existing instanceof List) {&#010;-                list = (List&lt;String&gt;) existing;&#010;-            } else {&#010;-                // create a new list to hold the multiple values&#010;-                list = new ArrayList&lt;String&gt;();&#010;-                String s = existing != null ? existing.toString() : null;&#010;-                if (s != null) {&#010;-                    list.add(s);&#010;-                }&#010;-            }&#010;-            list.add(value);&#010;-            map.put(name, list);&#010;-        } else {&#010;-            map.put(name, value);&#010;-        }&#010;-    }&#010;-&#010;-    /**&#010;-     * Assembles a query from the given map.&#010;-     *&#010;-     * @param options  the map with the options (eg key/value pairs)&#010;-     * @param ampersand to use &amp; for Java code, and &amp;amp; for XML&#010;-     * @return a query string with &lt;tt&gt;key1=value&amp;key2=value2&amp;...&lt;/tt&gt;, or an empty string if there is no options.&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     */&#010;-    public static String createQueryString(Map&lt;String, String&gt; options, String ampersand, boolean encode) throws URISyntaxException {&#010;-        try {&#010;-            if (options.size() &gt; 0) {&#010;-                StringBuilder rc = new StringBuilder();&#010;-                boolean first = true;&#010;-                for (Object o : options.keySet()) {&#010;-                    if (first) {&#010;-                        first = false;&#010;-                    } else {&#010;-                        rc.append(ampersand);&#010;-                    }&#010;-&#010;-                    String key = (String) o;&#010;-                    Object value = options.get(key);&#010;-&#010;-                    // use the value as a String&#010;-                    String s = value != null ? value.toString() : null;&#010;-                    appendQueryStringParameter(key, s, rc, encode);&#010;-                }&#010;-                return rc.toString();&#010;-            } else {&#010;-                return """";&#010;-            }&#010;-        } catch (UnsupportedEncodingException e) {&#010;-            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;-            se.initCause(e);&#010;-            throw se;&#010;-        }&#010;-    }&#010;-&#010;-    private static void appendQueryStringParameter(String key, String value, StringBuilder rc, boolean encode) throws UnsupportedEncodingException {&#010;-        if (encode) {&#010;-            rc.append(URLEncoder.encode(key, CHARSET));&#010;-        } else {&#010;-            rc.append(key);&#010;-        }&#010;-        // only append if value is not null&#010;-        if (value != null) {&#010;-            rc.append(""="");&#010;-            if (value.startsWith(RAW_TOKEN_START) &amp;&amp; value.endsWith(RAW_TOKEN_END)) {&#010;-                // do not encode RAW parameters&#010;-                rc.append(value);&#010;-            } else {&#010;-                if (encode) {&#010;-                    rc.append(URLEncoder.encode(value, CHARSET));&#010;-                } else {&#010;-                    rc.append(value);&#010;-                }&#010;-            }&#010;-        }&#010;-    }&#010;-&#010;-    /**&#010;-     * Tests whether the value is &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;-     *&#010;-     * @param value  the value, if its a String it will be tested for text length as well&#010;-     * @return true if empty&#010;-     */&#010;-    public static boolean isEmpty(Object value) {&#010;-        return !isNotEmpty(value);&#010;-    }&#010;-&#010;-    /**&#010;-     * Tests whether the value is &lt;b&gt;not&lt;/b&gt; &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;-     *&#010;-     * @param value  the value, if its a String it will be tested for text length as well&#010;-     * @return true if &lt;b&gt;not&lt;/b&gt; empty&#010;-     */&#010;-    public static boolean isNotEmpty(Object value) {&#010;-        if (value == null) {&#010;-            return false;&#010;-        } else if (value instanceof String) {&#010;-            String text = (String) value;&#010;-            return text.trim().length() &gt; 0;&#010;-        } else {&#010;-            return true;&#010;-        }&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java b/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&#010;deleted file mode 100644&#010;index 563bac2..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&#010;+++ /dev/null&#010;@@ -1,206 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.ArrayList;&#010;-import java.util.BitSet;&#010;-import java.util.List;&#010;-import java.util.regex.Matcher;&#010;-import java.util.regex.Pattern;&#010;-&#010;-/**&#010;- * Encoder for unsafe URI characters.&#010;- * &lt;p/&gt;&#010;- * A good source for details is &lt;a href=""http://en.wikipedia.org/wiki/Url_encode""&gt;wikipedia url encode&lt;/a&gt; article.&#010;- */&#010;-public final class UnsafeUriCharactersEncoder {&#010;-    private static BitSet unsafeCharactersRfc1738;&#010;-    private static BitSet unsafeCharactersHttp;&#010;-    private static final char[] HEX_DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C',&#010;-        'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'};&#010;-    private static final Pattern RAW_PATTERN = Pattern.compile(""RAW\\([^\\)]+\\)"");&#010;-&#010;-    static {&#010;-        unsafeCharactersRfc1738 = new BitSet(256);&#010;-        unsafeCharactersRfc1738.set(' ');&#010;-        unsafeCharactersRfc1738.set('""');&#010;-        unsafeCharactersRfc1738.set('&lt;');&#010;-        unsafeCharactersRfc1738.set('&gt;');&#010;-        unsafeCharactersRfc1738.set('#');&#010;-        unsafeCharactersRfc1738.set('%');&#010;-        unsafeCharactersRfc1738.set('{');&#010;-        unsafeCharactersRfc1738.set('}');&#010;-        unsafeCharactersRfc1738.set('|');&#010;-        unsafeCharactersRfc1738.set('\\');&#010;-        unsafeCharactersRfc1738.set('^');&#010;-        unsafeCharactersRfc1738.set('~');&#010;-        unsafeCharactersRfc1738.set('[');&#010;-        unsafeCharactersRfc1738.set(']');&#010;-        unsafeCharactersRfc1738.set('`');&#010;-    }&#010;-&#010;-    static {&#010;-        unsafeCharactersHttp = new BitSet(256);&#010;-        unsafeCharactersHttp.set(' ');&#010;-        unsafeCharactersHttp.set('""');&#010;-        unsafeCharactersHttp.set('&lt;');&#010;-        unsafeCharactersHttp.set('&gt;');&#010;-        unsafeCharactersHttp.set('#');&#010;-        unsafeCharactersHttp.set('%');&#010;-        unsafeCharactersHttp.set('{');&#010;-        unsafeCharactersHttp.set('}');&#010;-        unsafeCharactersHttp.set('|');&#010;-        unsafeCharactersHttp.set('\\');&#010;-        unsafeCharactersHttp.set('^');&#010;-        unsafeCharactersHttp.set('~');&#010;-        unsafeCharactersHttp.set('`');&#010;-    }&#010;-&#010;-    private UnsafeUriCharactersEncoder() {&#010;-        // util class&#010;-    }&#010;-&#010;-    public static String encode(String s) {&#010;-        return encode(s, unsafeCharactersRfc1738);&#010;-    }&#010;-&#010;-    public static String encodeHttpURI(String s) {&#010;-        return encode(s, unsafeCharactersHttp);&#010;-    }&#010;-&#010;-    public static String encode(String s, BitSet unsafeCharacters) {&#010;-        return encode(s, unsafeCharacters, false);&#010;-    }&#010;-&#010;-    public static String encode(String s, boolean checkRaw) {&#010;-        return encode(s, unsafeCharactersRfc1738, checkRaw);&#010;-    }&#010;-&#010;-    public static String encodeHttpURI(String s, boolean checkRaw) {&#010;-        return encode(s, unsafeCharactersHttp, checkRaw);&#010;-    }&#010;-&#010;-    private static List&lt;Pair&gt; checkRAW(String s) {&#010;-        Matcher matcher = RAW_PATTERN.matcher(s);&#010;-        List&lt;Pair&gt; answer = new ArrayList&lt;Pair&gt;();&#010;-        // Check all occurrences&#010;-        while (matcher.find()) {&#010;-            answer.add(new Pair(matcher.start(), matcher.end()));&#010;-        }&#010;-        return answer;&#010;-    }&#010;-&#010;-    private static boolean isRaw(int index, List&lt;Pair&gt; pairs) {&#010;-        for (Pair pair : pairs) {&#010;-            if (index &lt; pair.left) {&#010;-                return false;&#010;-            } else {&#010;-                if (index &gt;= pair.left) {&#010;-                    if (index &lt;= pair.right) {&#010;-                        return true;&#010;-                    } else {&#010;-                        continue;&#010;-                    }&#010;-                }&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    private static class Pair {&#010;-        int left;&#010;-        int right;&#010;-&#010;-        Pair(int left, int right) {&#010;-            this.left = left;&#010;-            this.right = right;&#010;-        }&#010;-    }&#010;-&#010;-    // Just skip the encode for isRAW part&#010;-    public static String encode(String s, BitSet unsafeCharacters, boolean checkRaw) {&#010;-        List&lt;Pair&gt; rawPairs;&#010;-        if (checkRaw) {&#010;-            rawPairs = checkRAW(s);&#010;-        } else {&#010;-            rawPairs = new ArrayList&lt;Pair&gt;();&#010;-        }&#010;-&#010;-        int n = s == null ? 0 : s.length();&#010;-        if (n == 0) {&#010;-            return s;&#010;-        }&#010;-&#010;-        // First check whether we actually need to encode&#010;-        char chars[] = s.toCharArray();&#010;-        for (int i = 0;;) {&#010;-            // just deal with the ascii character&#010;-            if (chars[i] &gt; 0 &amp;&amp; chars[i] &lt; 128) {&#010;-                if (unsafeCharacters.get(chars[i])) {&#010;-                    break;&#010;-                }&#010;-            }&#010;-            if (++i &gt;= chars.length) {&#010;-                return s;&#010;-            }&#010;-        }&#010;-&#010;-        // okay there are some unsafe characters so we do need to encode&#010;-        // see details at: http://en.wikipedia.org/wiki/Url_encode&#010;-        StringBuilder sb = new StringBuilder();&#010;-        for (int i = 0; i &lt; chars.length; i++) {&#010;-            char ch = chars[i];&#010;-            if (ch &gt; 0 &amp;&amp; ch &lt; 128 &amp;&amp; unsafeCharacters.get(ch)) {&#010;-                // special for % sign as it may be a decimal encoded value&#010;-                if (ch == '%') {&#010;-                    char next = i + 1 &lt; chars.length ? chars[i + 1] : ' ';&#010;-                    char next2 = i + 2 &lt; chars.length ? chars[i + 2] : ' ';&#010;-&#010;-                    if (isHexDigit(next) &amp;&amp; isHexDigit(next2) &amp;&amp; !isRaw(i, rawPairs)) {&#010;-                        // its already encoded (decimal encoded) so just append as is&#010;-                        sb.append(ch);&#010;-                    } else {&#010;-                        // must escape then, as its an unsafe character&#010;-                        appendEscape(sb, (byte) ch);&#010;-                    }&#010;-                } else {&#010;-                    // must escape then, as its an unsafe character&#010;-                    appendEscape(sb, (byte) ch);&#010;-                }&#010;-            } else {&#010;-                sb.append(ch);&#010;-            }&#010;-        }&#010;-        return sb.toString();&#010;-    }&#010;-&#010;-    private static void appendEscape(StringBuilder sb, byte b) {&#010;-        sb.append('%');&#010;-        sb.append(HEX_DIGITS[(b &gt;&gt; 4) &amp; 0x0f]);&#010;-        sb.append(HEX_DIGITS[(b &gt;&gt; 0) &amp; 0x0f]);&#010;-    }&#010;-&#010;-    private static boolean isHexDigit(char ch) {&#010;-        for (char hex : HEX_DIGITS) {&#010;-            if (hex == ch) {&#010;-                return true;&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/package.html&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/package.html b/camel-core/src/main/java/org/apache/camel/catalog/package.html&#010;deleted file mode 100644&#010;index 98786d1..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/package.html&#010;+++ /dev/null&#010;@@ -1,25 +0,0 @@&#010;-&lt;!--&#010;-    Licensed to the Apache Software Foundation (ASF) under one or more&#010;-    contributor license agreements.  See the NOTICE file distributed with&#010;-    this work for additional information regarding copyright ownership.&#010;-    The ASF licenses this file to You under the Apache License, Version 2.0&#010;-    (the ""License""); you may not use this file except in compliance with&#010;-    the License.  You may obtain a copy of the License at&#010;-&#010;-    http://www.apache.org/licenses/LICENSE-2.0&#010;-&#010;-    Unless required by applicable law or agreed to in writing, software&#010;-    distributed under the License is distributed on an ""AS IS"" BASIS,&#010;-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;-    See the License for the specific language governing permissions and&#010;-    limitations under the License.&#010;---&gt;&#010;-&lt;html&gt;&#010;-&lt;head&gt;&#010;-&lt;/head&gt;&#010;-&lt;body&gt;&#010;-&#010;-Camel Catalog&#010;-&#010;-&lt;/body&gt;&#010;-&lt;/html&gt;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java b/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;index 5d19e0d..4013e5f 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;@@ -22,12 +22,12 @@ import java.util.Map;&#010; import org.apache.camel.Component;&#010; import org.apache.camel.ComponentVerifier;&#010; import org.apache.camel.VerifiableComponent;&#010;-import org.apache.camel.catalog.JSonSchemaHelper;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010; import org.apache.camel.impl.verifier.CatalogVerifierCustomizer;&#010; import org.apache.camel.impl.verifier.DefaultComponentVerifier;&#010; import org.apache.camel.impl.verifier.ResultBuilder;&#010; import org.apache.camel.impl.verifier.ResultErrorBuilder;&#010;+import org.apache.camel.runtimecatalog.JSonSchemaHelper;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.RestConsumerFactory;&#010; import org.apache.camel.spi.RestProducerFactory;&#010; import org.apache.camel.util.ObjectHelper;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;index c85ce8c..b53efc8 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;@@ -26,7 +26,6 @@ import java.util.Collections;&#010; import java.util.Comparator;&#010; import java.util.Date;&#010; import java.util.HashMap;&#010;-import java.util.HashSet;&#010; import java.util.Iterator;&#010; import java.util.LinkedHashMap;&#010; import java.util.LinkedHashSet;&#010;@@ -87,8 +86,6 @@ import org.apache.camel.api.management.mbean.ManagedRouteMBean;&#010; import org.apache.camel.builder.DefaultFluentProducerTemplate;&#010; import org.apache.camel.builder.ErrorHandlerBuilder;&#010; import org.apache.camel.builder.ErrorHandlerBuilderSupport;&#010;-import org.apache.camel.catalog.DefaultRuntimeCamelCatalog;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010; import org.apache.camel.component.properties.PropertiesComponent;&#010; import org.apache.camel.impl.converter.BaseTypeConverterRegistry;&#010; import org.apache.camel.impl.converter.DefaultTypeConverter;&#010;@@ -121,6 +118,8 @@ import org.apache.camel.processor.interceptor.Delayer;&#010; import org.apache.camel.processor.interceptor.HandleFault;&#010; import org.apache.camel.processor.interceptor.StreamCaching;&#010; import org.apache.camel.processor.interceptor.Tracer;&#010;+import org.apache.camel.runtimecatalog.DefaultRuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.AsyncProcessorAwaitManager;&#010; import org.apache.camel.spi.CamelContextNameStrategy;&#010; import org.apache.camel.spi.ClassResolver;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java b/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;index b9d9998..f05cdb1 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;@@ -25,8 +25,8 @@ import org.apache.camel.CamelContext;&#010; import org.apache.camel.ComponentVerifier;&#010; import org.apache.camel.NoSuchOptionException;&#010; import org.apache.camel.TypeConverter;&#010;-import org.apache.camel.catalog.EndpointValidationResult;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.EndpointValidationResult;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.util.CamelContextHelper;&#010; import org.apache.camel.util.EndpointHelper;&#010; import org.apache.camel.util.IntrospectionSupport;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;index a09ff7d..9a70390 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;@@ -46,12 +46,9 @@ import org.apache.camel.StartupListener;&#010; import org.apache.camel.TimerListener;&#010; import org.apache.camel.VetoCamelContextStartException;&#010; import org.apache.camel.api.management.PerformanceCounter;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010; import org.apache.camel.impl.ConsumerCache;&#010; import org.apache.camel.impl.DefaultCamelContext;&#010; import org.apache.camel.impl.DefaultEndpointRegistry;&#010;-import org.apache.camel.impl.DefaultTransformerRegistry;&#010;-import org.apache.camel.impl.DefaultValidatorRegistry;&#010; import org.apache.camel.impl.EventDrivenConsumerRoute;&#010; import org.apache.camel.impl.ProducerCache;&#010; import org.apache.camel.impl.ThrottlingExceptionRoutePolicy;&#010;@@ -89,6 +86,7 @@ import org.apache.camel.processor.CamelInternalProcessor;&#010; import org.apache.camel.processor.interceptor.BacklogDebugger;&#010; import org.apache.camel.processor.interceptor.BacklogTracer;&#010; import org.apache.camel.processor.interceptor.Tracer;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.AsyncProcessorAwaitManager;&#010; import org.apache.camel.spi.DataFormat;&#010; import org.apache.camel.spi.EventNotifier;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;index 20d3f28..6a99656 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;@@ -19,7 +19,7 @@ package org.apache.camel.management.mbean;&#010; import org.apache.camel.CamelContext;&#010; import org.apache.camel.api.management.ManagedResource;&#010; import org.apache.camel.api.management.mbean.ManagedRuntimeCamelCatalogMBean;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.ManagementStrategy;&#010; &#010; /**&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C6a3e7fae5cba4f918aede10c3ae6ef26%40git.apache.org%3E,2017-04-14 10:52,commits,3.0,326.0,  [5/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
11,322.0,davscl...@apache.org,"Repository: camel&#010;Updated Branches:&#010;  refs/heads/master d72696455 -&gt; 6b42a3534&#010;&#010;&#010;Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/6b42a353&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/6b42a353&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/6b42a353&#010;&#010;Branch: refs/heads/master&#010;Commit: 6b42a3534120f58180e6194e6bf4f1a284707abc&#010;Parents: c66be7a&#010;Author: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Authored: Fri Apr 14 12:17:14 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:52:40 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; platforms/camel-catalog/pom.xml | 40 ++++++++++++++++++++++++++++++++++--&#010; 1 file changed, 38 insertions(+), 2 deletions(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/6b42a353/platforms/camel-catalog/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/platforms/camel-catalog/pom.xml b/platforms/camel-catalog/pom.xml&#010;index 2be82e0..6c71fcb 100644&#010;--- a/platforms/camel-catalog/pom.xml&#010;+++ b/platforms/camel-catalog/pom.xml&#010;@@ -92,7 +92,7 @@&#010;         &lt;executions&gt;&#010;           &lt;execution&gt;&#010;             &lt;id&gt;copy-resources&lt;/id&gt;&#010;-            &lt;phase&gt;process-sources&lt;/phase&gt;&#010;+            &lt;phase&gt;generate-sources&lt;/phase&gt;&#010;             &lt;goals&gt;&#010;               &lt;goal&gt;copy-resources&lt;/goal&gt;&#010;             &lt;/goals&gt;&#010;@@ -101,7 +101,7 @@&#010;               &lt;overwrite&gt;true&lt;/overwrite&gt;&#010;               &lt;resources&gt;&#010;                 &lt;resource&gt;&#010;-                  &lt;directory&gt;../../camel-core/src/main/java/org/apache/camel/catalog&lt;/directory&gt;&#010;+                  &lt;directory&gt;../../camel-core/src/main/java/org/apache/camel/runtimecatalog&lt;/directory&gt;&#010;                   &lt;!-- the following files are maintained in camel-core and not here,&#010;so they are copied over --&gt;&#010;                   &lt;includes&gt;&#010;                     &lt;include&gt;AbstractCamelCatalog.java&lt;/include&gt;&#010;@@ -123,6 +123,42 @@&#010;           &lt;/execution&gt;&#010;         &lt;/executions&gt;&#010;       &lt;/plugin&gt;&#010;+      &lt;!-- rename runtimecatalog to catalog which is the package name we use here --&gt;&#010;+      &lt;plugin&gt;&#010;+        &lt;groupId&gt;com.google.code.maven-replacer-plugin&lt;/groupId&gt;&#010;+        &lt;artifactId&gt;replacer&lt;/artifactId&gt;&#010;+        &lt;version&gt;1.5.3&lt;/version&gt;&#010;+        &lt;executions&gt;&#010;+          &lt;execution&gt;&#010;+            &lt;phase&gt;process-sources&lt;/phase&gt;&#010;+            &lt;goals&gt;&#010;+              &lt;goal&gt;replace&lt;/goal&gt;&#010;+            &lt;/goals&gt;&#010;+          &lt;/execution&gt;&#010;+        &lt;/executions&gt;&#010;+        &lt;configuration&gt;&#010;+          &lt;includes&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/AbstractCamelCatalog.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/CatalogHelper.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/CollectionStringBuffer.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/URISupport.java&lt;/include&gt;&#010;+          &lt;/includes&gt;&#010;+          &lt;replacements&gt;&#010;+            &lt;replacement&gt;&#010;+              &lt;token&gt;org.apache.camel.runtimecatalog&lt;/token&gt;&#010;+              &lt;value&gt;org.apache.camel.catalog&lt;/value&gt;&#010;+            &lt;/replacement&gt;&#010;+          &lt;/replacements&gt;&#010;+        &lt;/configuration&gt;&#010;+      &lt;/plugin&gt;&#010; &#010;       &lt;!-- generate and include all components in the catalog --&gt;&#010;       &lt;plugin&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cde5de0a2e2ca40e6bcaa03835723a40e%40git.apache.org%3E,2017-04-14 10:52,commits,4.0,322.0,[1/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
12,323.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;b/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;new file mode 100644&#010;index 0000000..309fb8e&#010;--- /dev/null&#010;+++ b/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;@@ -0,0 +1,104 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.net.URISyntaxException;&#010;+import java.util.HashMap;&#010;+import java.util.Map;&#010;+&#010;+import org.junit.Before;&#010;+import org.junit.Test;&#010;+&#010;+import static org.easymock.EasyMock.expect;&#010;+import static org.easymock.EasyMock.mock;&#010;+import static org.easymock.EasyMock.replay;&#010;+import static org.junit.Assert.assertEquals;&#010;+&#010;+public class AbstractCamelCatalogTest {&#010;+&#010;+    AbstractCamelCatalog catalog = new AbstractCamelCatalog() {&#010;+    };&#010;+&#010;+    JSonSchemaResolver resolver;&#010;+&#010;+    @Before&#010;+    public void setupMockCatalog() {&#010;+        resolver = mock(JSonSchemaResolver.class);&#010;+&#010;+        catalog.setJSonSchemaResolver(resolver);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void shouldConstructEndpointUris() throws URISyntaxException {&#010;+        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;+            + ""  \""component\"": {\n""//&#010;+            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;+            + ""  }\n""//&#010;+            + ""}"");&#010;+&#010;+        replay(resolver);&#010;+&#010;+        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;+        properties.put(""param1"", ""value1"");&#010;+        properties.put(""param2"", ""value2"");&#010;+        properties.put(""param3"", ""value3"");&#010;+&#010;+        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;+&#010;+        assertEquals(""comp:value1:value2?param3=value3"", endpointUri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void shouldConstructEndpointUrisWithPropertyPlaceholders() throws URISyntaxException&#010;{&#010;+        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;+            + ""  \""component\"": {\n""//&#010;+            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;+            + ""  }\n""//&#010;+            + ""}"");&#010;+&#010;+        replay(resolver);&#010;+&#010;+        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;+        properties.put(""param1"", ""{{prop1}}"");&#010;+        properties.put(""param2"", ""{{prop2}}"");&#010;+        properties.put(""param3"", ""{{prop3}}"");&#010;+&#010;+        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;+&#010;+        assertEquals(""comp:{{prop1}}:{{prop2}}?param3={{prop3}}"", endpointUri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void shouldConstructEndpointUrisWhenValuesContainTokens() throws URISyntaxException&#010;{&#010;+        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;+            + ""  \""component\"": {\n""//&#010;+            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;+            + ""  }\n""//&#010;+            + ""}"");&#010;+&#010;+        replay(resolver);&#010;+&#010;+        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;+        properties.put(""param1"", ""{value1}"");&#010;+        properties.put(""param2"", ""/value2/"");&#010;+        properties.put(""param3"", ""/value3/{param}"");&#010;+&#010;+        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;+&#010;+        assertEquals(""comp:{value1}:/value2/?param3=/value3/{param}"", endpointUri);&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;b/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;new file mode 100644&#010;index 0000000..dfdd5c5&#010;--- /dev/null&#010;+++ b/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;@@ -0,0 +1,393 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.HashMap;&#010;+import java.util.Map;&#010;+&#010;+import org.apache.camel.impl.DefaultCamelContext;&#010;+import org.junit.BeforeClass;&#010;+import org.junit.Test;&#010;+import org.slf4j.Logger;&#010;+import org.slf4j.LoggerFactory;&#010;+&#010;+import static org.junit.Assert.assertEquals;&#010;+import static org.junit.Assert.assertFalse;&#010;+import static org.junit.Assert.assertNotNull;&#010;+import static org.junit.Assert.assertTrue;&#010;+&#010;+public class RuntimeCamelCatalogTest {&#010;+&#010;+    static RuntimeCamelCatalog catalog;&#010;+&#010;+    private static final Logger LOG = LoggerFactory.getLogger(RuntimeCamelCatalogTest.class);&#010;+&#010;+    @BeforeClass&#010;+    public static void createCamelCatalog() {&#010;+        catalog = new DefaultRuntimeCamelCatalog(new DefaultCamelContext());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testFromCamelContext() throws Exception {&#010;+        String schema = new DefaultCamelContext().getRuntimeCamelCatalog().modelJSonSchema(""choice"");&#010;+        assertNotNull(schema);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testJsonSchema() throws Exception {&#010;+        String schema = catalog.modelJSonSchema(""aggregate"");&#010;+        assertNotNull(schema);&#010;+&#010;+        // lets make it possible to find bean/method using both names&#010;+        schema = catalog.modelJSonSchema(""method"");&#010;+        assertNotNull(schema);&#010;+        schema = catalog.modelJSonSchema(""bean"");&#010;+        assertNotNull(schema);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriMapFile() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""directoryName"", ""src/data/inbox"");&#010;+        map.put(""noop"", ""true"");&#010;+        map.put(""delay"", ""5000"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""file"", map, true);&#010;+        assertEquals(""file:src/data/inbox?delay=5000&amp;noop=true"", uri);&#010;+&#010;+        String uri2 = catalog.asEndpointUriXml(""file"", map, true);&#010;+        assertEquals(""file:src/data/inbox?delay=5000&amp;amp;noop=true"", uri2);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriTimer() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""timerName"", ""foo"");&#010;+        map.put(""period"", ""5000"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;+        assertEquals(""timer:foo?period=5000"", uri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriPropertiesPlaceholders() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""timerName"", ""foo"");&#010;+        map.put(""period"", ""{{howoften}}"");&#010;+        map.put(""repeatCount"", ""5"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;+        assertEquals(""timer:foo?period=%7B%7Bhowoften%7D%7D&amp;repeatCount=5"", uri);&#010;+&#010;+        uri = catalog.asEndpointUri(""timer"", map, false);&#010;+        assertEquals(""timer:foo?period={{howoften}}&amp;repeatCount=5"", uri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriBeanLookup() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""resourceUri"", ""foo.xslt"");&#010;+        map.put(""converter"", ""#myConverter"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""xslt"", map, true);&#010;+        assertEquals(""xslt:foo.xslt?converter=%23myConverter"", uri);&#010;+&#010;+        uri = catalog.asEndpointUri(""xslt"", map, false);&#010;+        assertEquals(""xslt:foo.xslt?converter=#myConverter"", uri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testEndpointPropertiesPlaceholders() throws Exception {&#010;+        Map&lt;String, String&gt; map = catalog.endpointProperties(""timer:foo?period={{howoften}}&amp;repeatCount=5"");&#010;+        assertNotNull(map);&#010;+        assertEquals(3, map.size());&#010;+&#010;+        assertEquals(""foo"", map.get(""timerName""));&#010;+        assertEquals(""{{howoften}}"", map.get(""period""));&#010;+        assertEquals(""5"", map.get(""repeatCount""));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriLog() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""loggerName"", ""foo"");&#010;+        map.put(""loggerLevel"", ""WARN"");&#010;+        map.put(""multiline"", ""true"");&#010;+        map.put(""showAll"", ""true"");&#010;+        map.put(""showBody"", ""false"");&#010;+        map.put(""showBodyType"", ""false"");&#010;+        map.put(""showExchangePattern"", ""false"");&#010;+        map.put(""style"", ""Tab"");&#010;+&#010;+        assertEquals(""log:foo?loggerLevel=WARN&amp;multiline=true&amp;showAll=true&amp;style=Tab"",&#010;catalog.asEndpointUri(""log"", map, false));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriLogShort() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""loggerName"", ""foo"");&#010;+        map.put(""loggerLevel"", ""DEBUG"");&#010;+&#010;+        assertEquals(""log:foo?loggerLevel=DEBUG"", catalog.asEndpointUri(""log"", map, false));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriWithplaceholder() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""name"", ""foo"");&#010;+        map.put(""blockWhenFull"", ""{{block}}"");&#010;+        assertEquals(""seda:foo?blockWhenFull={{block}}"", catalog.asEndpointUri(""seda"", map,&#010;false));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testEndpointPropertiesSedaRequired() throws Exception {&#010;+        Map&lt;String, String&gt; map = catalog.endpointProperties(""seda:foo"");&#010;+        assertNotNull(map);&#010;+        assertEquals(1, map.size());&#010;+&#010;+        assertEquals(""foo"", map.get(""name""));&#010;+&#010;+        map = catalog.endpointProperties(""seda:foo?blockWhenFull=true"");&#010;+        assertNotNull(map);&#010;+        assertEquals(2, map.size());&#010;+&#010;+        assertEquals(""foo"", map.get(""name""));&#010;+        assertEquals(""true"", map.get(""blockWhenFull""));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void validateProperties() throws Exception {&#010;+        // valid&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(""log:mylog"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // unknown&#010;+        result = catalog.validateEndpointProperties(""log:mylog?level=WARN&amp;foo=bar"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getUnknown().contains(""foo""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // enum&#010;+        result = catalog.validateEndpointProperties(""seda:foo?waitForTaskToComplete=blah"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""blah"", result.getInvalidEnum().get(""waitForTaskToComplete""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // reference okay&#010;+        result = catalog.validateEndpointProperties(""seda:foo?queue=#queue"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(0, result.getNumberOfErrors());&#010;+&#010;+        // unknown component&#010;+        result = catalog.validateEndpointProperties(""foo:bar?me=you"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getUnknownComponent().equals(""foo""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // invalid boolean but default value&#010;+        result = catalog.validateEndpointProperties(""log:output?showAll=ggg"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""ggg"", result.getInvalidBoolean().get(""showAll""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // dataset&#010;+        result = catalog.validateEndpointProperties(""dataset:foo?minRate=50"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // time pattern&#010;+        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=true&amp;delay=0&amp;period=2s"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // reference lookup&#010;+        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=#fixed&amp;delay=#myDelay"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // optional consumer. prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?consumer.delay=5000&amp;consumer.greedy=true"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // optional without consumer. prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;greedy=true"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // mixed optional without consumer. prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;consumer.greedy=true"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;scheduler.foo=123&amp;scheduler.bar=456"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // stub&#010;+        result = catalog.validateEndpointProperties(""stub:foo?me=123&amp;you=456"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // lenient on&#010;+        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // lenient off&#010;+        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"",&#010;true);&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getUnknown().contains(""foo""));&#010;+&#010;+        // data format&#010;+        result = catalog.validateEndpointProperties(""dataformat:string:marshal?charset=utf-8"",&#010;true);&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // incapable to parse&#010;+        result = catalog.validateEndpointProperties(""{{getFtpUrl}}?recursive=true"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getIncapable() != null);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void validatePropertiesSummary() throws Exception {&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(""yammer:MESSAGES?blah=yada&amp;accessToken=aaa&amp;consumerKey=&amp;useJson=no&amp;initialDelay=five&amp;pollStrategy=myStrategy"");&#010;+        assertFalse(result.isSuccess());&#010;+        String reason = result.summaryErrorMessage(true);&#010;+        LOG.info(reason);&#010;+&#010;+        result = catalog.validateEndpointProperties(""jms:unknown:myqueue"");&#010;+        assertFalse(result.isSuccess());&#010;+        reason = result.summaryErrorMessage(false);&#010;+        LOG.info(reason);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void validateTimePattern() throws Exception {&#010;+        assertTrue(catalog.validateTimePattern(""0""));&#010;+        assertTrue(catalog.validateTimePattern(""500""));&#010;+        assertTrue(catalog.validateTimePattern(""10000""));&#010;+        assertTrue(catalog.validateTimePattern(""5s""));&#010;+        assertTrue(catalog.validateTimePattern(""5sec""));&#010;+        assertTrue(catalog.validateTimePattern(""5secs""));&#010;+        assertTrue(catalog.validateTimePattern(""3m""));&#010;+        assertTrue(catalog.validateTimePattern(""3min""));&#010;+        assertTrue(catalog.validateTimePattern(""3minutes""));&#010;+        assertTrue(catalog.validateTimePattern(""5m15s""));&#010;+        assertTrue(catalog.validateTimePattern(""1h""));&#010;+        assertTrue(catalog.validateTimePattern(""1hour""));&#010;+        assertTrue(catalog.validateTimePattern(""2hours""));&#010;+&#010;+        assertFalse(catalog.validateTimePattern(""bla""));&#010;+        assertFalse(catalog.validateTimePattern(""2year""));&#010;+        assertFalse(catalog.validateTimePattern(""60darn""));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testEndpointComponentName() throws Exception {&#010;+        String name = catalog.endpointComponentName(""jms:queue:foo"");&#010;+        assertEquals(""jms"", name);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testSimpleExpression() throws Exception {&#010;+        SimpleValidationResult result = catalog.validateSimpleExpression(null, ""${body}"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body}"", result.getSimple());&#010;+&#010;+        result = catalog.validateSimpleExpression(null, ""${body"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""${body"", result.getSimple());&#010;+        LOG.info(result.getError());&#010;+        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol&#010;at location 5""));&#010;+        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;+        assertEquals(5, result.getIndex());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testSimplePredicate() throws Exception {&#010;+        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} ==&#010;'abc'"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body} == 'abc'"", result.getSimple());&#010;+&#010;+        result = catalog.validateSimplePredicate(null, ""${body} &gt; ${header.size"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""${body} &gt; ${header.size"", result.getSimple());&#010;+        LOG.info(result.getError());&#010;+        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol&#010;at location 22""));&#010;+        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;+        assertEquals(22, result.getIndex());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testSimplePredicatePlaceholder() throws Exception {&#010;+        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} contains&#010;'{{danger}}'"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body} contains '{{danger}}'"", result.getSimple());&#010;+&#010;+        result = catalog.validateSimplePredicate(null, ""${bdy} contains '{{danger}}'"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""${bdy} contains '{{danger}}'"", result.getSimple());&#010;+        LOG.info(result.getError());&#010;+        assertTrue(result.getError().startsWith(""Unknown function: bdy at location 0""));&#010;+        assertTrue(result.getError().contains(""'{{danger}}'""));&#010;+        assertEquals(""Unknown function: bdy"", result.getShortError());&#010;+        assertEquals(0, result.getIndex());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testValidateLanguage() throws Exception {&#010;+        LanguageValidationResult result = catalog.validateLanguageExpression(null, ""simple"",&#010;""${body}"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body}"", result.getText());&#010;+&#010;+        result = catalog.validateLanguageExpression(null, ""header"", ""foo"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""foo"", result.getText());&#010;+&#010;+        result = catalog.validateLanguagePredicate(null, ""simple"", ""${body} &gt; 10"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body} &gt; 10"", result.getText());&#010;+&#010;+        result = catalog.validateLanguagePredicate(null, ""header"", ""bar"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""bar"", result.getText());&#010;+&#010;+        result = catalog.validateLanguagePredicate(null, ""foobar"", ""bar"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""Unknown language foobar"", result.getError());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testValidateEndpointConsumerOnly() throws Exception {&#010;+        String uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true"";&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false,&#010;true, false);&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true&amp;fileExist=Append"";&#010;+        result = catalog.validateEndpointProperties(uri, false, true, false);&#010;+        assertFalse(result.isSuccess());&#010;+&#010;+        assertEquals(""fileExist"", result.getNotConsumerOnly().iterator().next());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testValidateEndpointProducerOnly() throws Exception {&#010;+        String uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append"";&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false,&#010;false, true);&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append&amp;delete=true"";&#010;+        result = catalog.validateEndpointProperties(uri, false, false, true);&#010;+        assertFalse(result.isSuccess());&#010;+&#010;+        assertEquals(""delete"", result.getNotProducerOnly().iterator().next());&#010;+    }&#010;+&#010;+}&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C9e3f964e77d045cf840b002cc3565efe%40git.apache.org%3E,2017-04-14 10:52,commits,4.0,323.0,  [2/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
13,324.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java&#010;new file mode 100644&#010;index 0000000..1e69269&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java&#010;@@ -0,0 +1,424 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.ArrayList;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.LinkedHashSet;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+import java.util.Set;&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+public final class JSonSchemaHelper {&#010;+&#010;+    // 0 = text, 1 = enum, 2 = boolean, 3 = integer or number&#010;+    private static final Pattern PATTERN = Pattern.compile(""\""(.+?)\""|\\[(.+)\\]|(true|false)|(-?\\d+\\.?\\d*)"");&#010;+    private static final String QUOT = ""&amp;quot;"";&#010;+&#010;+    private JSonSchemaHelper() {&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the json schema to split it into a list or rows, where each row contains key value pairs with the metadata&#010;+     *&#010;+     * @param group the group to parse from such as &lt;tt&gt;component&lt;/tt&gt;, &lt;tt&gt;componentProperties&lt;/tt&gt;, or &lt;tt&gt;properties&lt;/tt&gt;.&#010;+     * @param json the json&#010;+     * @return a list of all the rows, where each row is a set of key value pairs with metadata&#010;+     */&#010;+    public static List&lt;Map&lt;String, String&gt;&gt; parseJsonSchema(String group, String json, boolean parseProperties) {&#010;+        List&lt;Map&lt;String, String&gt;&gt; answer = new ArrayList&lt;Map&lt;String, String&gt;&gt;();&#010;+        if (json == null) {&#010;+            return answer;&#010;+        }&#010;+&#010;+        boolean found = false;&#010;+&#010;+        // parse line by line&#010;+        String[] lines = json.split(""\n"");&#010;+        for (String line : lines) {&#010;+            // we need to find the group first&#010;+            if (!found) {&#010;+                String s = line.trim();&#010;+                found = s.startsWith(""\"""" + group + ""\"":"") &amp;&amp; s.endsWith(""{"");&#010;+                continue;&#010;+            }&#010;+&#010;+            // we should stop when we end the group&#010;+            if (line.equals(""  },"") || line.equals(""  }"")) {&#010;+                break;&#010;+            }&#010;+&#010;+            // need to safe encode \"" so we can parse the line&#010;+            line = line.replaceAll(""\""\\\\\""\"""", '""' + QUOT + '""');&#010;+&#010;+            Map&lt;String, String&gt; row = new LinkedHashMap&lt;String, String&gt;();&#010;+            Matcher matcher = PATTERN.matcher(line);&#010;+&#010;+            String key;&#010;+            if (parseProperties) {&#010;+                // when parsing properties the first key is given as name, so the first parsed token is the value of the name&#010;+                key = ""name"";&#010;+            } else {&#010;+                key = null;&#010;+            }&#010;+            while (matcher.find()) {&#010;+                if (key == null) {&#010;+                    key = matcher.group(1);&#010;+                } else {&#010;+                    String value = matcher.group(1);&#010;+                    if (value != null) {&#010;+                        // its text based&#010;+                        value = value.trim();&#010;+                        // decode&#010;+                        value = value.replaceAll(QUOT, ""\"""");&#010;+                        value = decodeJson(value);&#010;+                    }&#010;+                    if (value == null) {&#010;+                        // not text then its maybe an enum?&#010;+                        value = matcher.group(2);&#010;+                        if (value != null) {&#010;+                            // its an enum so strip out "" and trim spaces after comma&#010;+                            value = value.replaceAll(""\"""", """");&#010;+                            value = value.replaceAll("", "", "","");&#010;+                            value = value.trim();&#010;+                        }&#010;+                    }&#010;+                    if (value == null) {&#010;+                        // not text then its maybe a boolean?&#010;+                        value = matcher.group(3);&#010;+                    }&#010;+                    if (value == null) {&#010;+                        // not text then its maybe a integer?&#010;+                        value = matcher.group(4);&#010;+                    }&#010;+                    if (value != null) {&#010;+                        row.put(key, value);&#010;+                    }&#010;+                    // reset&#010;+                    key = null;&#010;+                }&#010;+            }&#010;+            if (!row.isEmpty()) {&#010;+                answer.add(row);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    private static String decodeJson(String value) {&#010;+        // json encodes a \ as \\ so we need to decode from \\ back to \&#010;+        if (""\\\\"".equals(value)) {&#010;+            value = ""\\"";&#010;+        }&#010;+        return value;&#010;+    }&#010;+&#010;+    public static boolean isComponentLenientProperties(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""lenientProperties"")) {&#010;+                return ""true"".equals(row.get(""lenientProperties""));&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isComponentConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""consumerOnly"")) {&#010;+                return ""true"".equals(row.get(""consumerOnly""));&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isComponentProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""producerOnly"")) {&#010;+                return ""true"".equals(row.get(""producerOnly""));&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String labels = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""label"")) {&#010;+                labels = row.get(""label"");&#010;+            }&#010;+            if (found) {&#010;+                return labels != null &amp;&amp; labels.contains(""consumer"");&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String labels = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""label"")) {&#010;+                labels = row.get(""label"");&#010;+            }&#010;+            if (found) {&#010;+                return labels != null &amp;&amp; labels.contains(""producer"");&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyRequired(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            boolean required = false;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""required"")) {&#010;+                required = ""true"".equals(row.get(""required""));&#010;+            }&#010;+            if (found) {&#010;+                return required;&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static String getPropertyKind(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String kind = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""kind"")) {&#010;+                kind = row.get(""kind"");&#010;+            }&#010;+            if (found) {&#010;+                return kind;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static boolean isPropertyBoolean(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""boolean"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyInteger(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""integer"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyNumber(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""number"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyObject(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""object"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static String getPropertyDefaultValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String defaultValue = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""defaultValue"")) {&#010;+                defaultValue = row.get(""defaultValue"");&#010;+            }&#010;+            if (found) {&#010;+                return defaultValue;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static String stripOptionalPrefixFromName(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String optionalPrefix = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""optionalPrefix"")) {&#010;+                optionalPrefix = row.get(""optionalPrefix"");&#010;+            }&#010;+            if (row.containsKey(""name"")) {&#010;+                if (optionalPrefix != null &amp;&amp; name.startsWith(optionalPrefix)) {&#010;+                    name = name.substring(optionalPrefix.length());&#010;+                    // try again&#010;+                    return stripOptionalPrefixFromName(rows, name);&#010;+                } else {&#010;+                    found = name.equals(row.get(""name""));&#010;+                }&#010;+            }&#010;+            if (found) {&#010;+                return name;&#010;+            }&#010;+        }&#010;+        return name;&#010;+    }&#010;+&#010;+    public static String getPropertyEnum(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String enums = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""enum"")) {&#010;+                enums = row.get(""enum"");&#010;+            }&#010;+            if (found) {&#010;+                return enums;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static String getPropertyPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String prefix = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""prefix"")) {&#010;+                prefix = row.get(""prefix"");&#010;+            }&#010;+            if (found) {&#010;+                return prefix;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static boolean isPropertyMultiValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            boolean multiValue = false;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""multiValue"")) {&#010;+                multiValue = ""true"".equals(row.get(""multiValue""));&#010;+            }&#010;+            if (found) {&#010;+                return multiValue;&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static String getPropertyNameFromNameWithPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String propertyName = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                propertyName = row.get(""name"");&#010;+            }&#010;+            if (row.containsKey(""prefix"")) {&#010;+                String preifx = row.get(""prefix"");&#010;+                found = name.startsWith(preifx);&#010;+            }&#010;+            if (found) {&#010;+                return propertyName;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static Map&lt;String, String&gt; getRow(List&lt;Map&lt;String, String&gt;&gt; rows, String key) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (key.equals(row.get(""name""))) {&#010;+                return row;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static Set&lt;String&gt; getNames(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        Set&lt;String&gt; answer = new LinkedHashSet&lt;String&gt;();&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""name"")) {&#010;+                answer.add(row.get(""name""));&#010;+            }&#010;+        }&#010;+        return answer;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java&#010;new file mode 100644&#010;index 0000000..dbd6f45&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java&#010;@@ -0,0 +1,64 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+/**&#010;+ * Pluggable resolver to load JSon schema files for components, data formats, languages etc.&#010;+ */&#010;+public interface JSonSchemaResolver {&#010;+&#010;+    /**&#010;+     * Returns the component information as JSon format.&#010;+     *&#010;+     * @param name the component name&#010;+     * @return component details in JSon&#010;+     */&#010;+    String getComponentJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the data format information as JSon format.&#010;+     *&#010;+     * @param name the data format name&#010;+     * @return data format details in JSon&#010;+     */&#010;+    String getDataFormatJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the language information as JSon format.&#010;+     *&#010;+     * @param name the language name&#010;+     * @return language details in JSon&#010;+     */&#010;+    String getLanguageJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the other (miscellaneous) information as JSon format.&#010;+     *&#010;+     * @param name the other (miscellaneous) name&#010;+     * @return other (miscellaneous) details in JSon&#010;+     */&#010;+    String getOtherJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the model information as JSon format.&#010;+     *&#010;+     * @param name the model name&#010;+     * @return model details in JSon&#010;+     */&#010;+    String getModelJSonSchema(String name);&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java&#010;new file mode 100644&#010;index 0000000..dbb5525&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java&#010;@@ -0,0 +1,65 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.Serializable;&#010;+&#010;+/**&#010;+ * Validation result of parsing a language expression or predicate&#010;+ */&#010;+public class LanguageValidationResult implements Serializable {&#010;+    private final String text;&#010;+    private String error;&#010;+    private String shortError;&#010;+    private int index;&#010;+&#010;+    public LanguageValidationResult(String text) {&#010;+        this.text = text;&#010;+    }&#010;+&#010;+    public String getText() {&#010;+        return text;&#010;+    }&#010;+&#010;+    public boolean isSuccess() {&#010;+        return error == null;&#010;+    }&#010;+&#010;+    public void setError(String error) {&#010;+        this.error = error;&#010;+    }&#010;+&#010;+    public String getError() {&#010;+        return error;&#010;+    }&#010;+&#010;+    public String getShortError() {&#010;+        return shortError;&#010;+    }&#010;+&#010;+    public void setShortError(String shortError) {&#010;+        this.shortError = shortError;&#010;+    }&#010;+&#010;+    public int getIndex() {&#010;+        return index;&#010;+    }&#010;+&#010;+    public void setIndex(int index) {&#010;+        this.index = index;&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java&#010;new file mode 100644&#010;index 0000000..86c4b53&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java&#010;@@ -0,0 +1,234 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.net.URISyntaxException;&#010;+import java.util.Map;&#010;+&#010;+import org.apache.camel.StaticService;&#010;+&#010;+/**&#010;+ * Runtime based CamelCatalog which are included in camel-core that can provided limit CamelCatalog capabilities&#010;+ */&#010;+public interface RuntimeCamelCatalog extends StaticService {&#010;+&#010;+    /**&#010;+     * Returns the component information as JSon format.&#010;+     *&#010;+     * @param name the component name&#010;+     * @return component details in JSon&#010;+     */&#010;+    String componentJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the data format information as JSon format.&#010;+     *&#010;+     * @param name the data format name&#010;+     * @return data format details in JSon&#010;+     */&#010;+    String dataFormatJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the language information as JSon format.&#010;+     *&#010;+     * @param name the language name&#010;+     * @return language details in JSon&#010;+     */&#010;+    String languageJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the model information as JSon format.&#010;+     *&#010;+     * @param name the model name&#010;+     * @return model details in JSon&#010;+     */&#010;+    String modelJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Parses the endpoint uri and constructs a key/value properties of each option&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return properties as key value pairs of each endpoint option&#010;+     */&#010;+    Map&lt;String, String&gt; endpointProperties(String uri) throws URISyntaxException;&#010;+&#010;+    /**&#010;+     * Parses the endpoint uri and constructs a key/value properties of only the lenient properties (eg custom options)&#010;+     * &lt;p/&gt;&#010;+     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return properties as key value pairs of each lenient properties&#010;+     */&#010;+    Map&lt;String, String&gt; endpointLenientProperties(String uri) throws URISyntaxException;&#010;+&#010;+    /**&#010;+     * Validates the pattern whether its a valid time pattern.&#010;+     *&#010;+     * @param pattern  the pattern such as 5000, 5s, 5sec, 4min, 4m30s, 1h, etc.&#010;+     * @return &lt;tt&gt;true&lt;/tt&gt; if valid, &lt;tt&gt;false&lt;/tt&gt; if invalid&#010;+     */&#010;+    boolean validateTimePattern(String pattern);&#010;+&#010;+    /**&#010;+     * Validates the properties for the given scheme against component and endpoint&#010;+     *&#010;+     * @param scheme  the endpoint scheme&#010;+     * @param properties  the endpoint properties&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateProperties(String scheme, Map&lt;String, String&gt; properties);&#010;+&#010;+    /**&#010;+     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateEndpointProperties(String uri);&#010;+&#010;+    /**&#010;+     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;+     * &lt;p/&gt;&#010;+     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;+     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;+     * but in the uri because of using lenient properties.&#010;+     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties);&#010;+&#010;+    /**&#010;+     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;+     * &lt;p/&gt;&#010;+     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;+     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;+     * but in the uri because of using lenient properties.&#010;+     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;+     * @param consumerOnly whether the endpoint is only used as a consumer&#010;+     * @param producerOnly whether the endpoint is only used as a producer&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties, boolean consumerOnly, boolean producerOnly);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple expression.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param simple  the simple expression&#010;+     * @return validation result&#010;+     * @deprecated use {@link #validateSimpleExpression(ClassLoader, String)}&#010;+     */&#010;+    @Deprecated&#010;+    SimpleValidationResult validateSimpleExpression(String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple expression.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param simple  the simple expression&#010;+     * @return validation result&#010;+     */&#010;+    SimpleValidationResult validateSimpleExpression(ClassLoader classLoader, String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple predicate&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param simple  the simple predicate&#010;+     * @return validation result&#010;+     * @deprecated use {@link #validateSimplePredicate(ClassLoader, String)}&#010;+     */&#010;+    @Deprecated&#010;+    SimpleValidationResult validateSimplePredicate(String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple predicate&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param simple  the simple predicate&#010;+     * @return validation result&#010;+     */&#010;+    SimpleValidationResult validateSimplePredicate(ClassLoader classLoader, String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the language as a predicate&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param language the name of the language&#010;+     * @param text  the predicate text&#010;+     * @return validation result&#010;+     */&#010;+    LanguageValidationResult validateLanguagePredicate(ClassLoader classLoader, String language, String text);&#010;+&#010;+    /**&#010;+     * Parses and validates the language as an expression&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param language the name of the language&#010;+     * @param text  the expression text&#010;+     * @return validation result&#010;+     */&#010;+    LanguageValidationResult validateLanguageExpression(ClassLoader classLoader, String language, String text);&#010;+&#010;+    /**&#010;+     * Returns the component name from the given endpoint uri&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return the component name (aka scheme), or &lt;tt&gt;null&lt;/tt&gt; if not possible to determine&#010;+     */&#010;+    String endpointComponentName(String uri);&#010;+&#010;+    /**&#010;+     * Creates an endpoint uri in Java style from the information from the properties&#010;+     *&#010;+     * @param scheme the endpoint schema&#010;+     * @param properties the properties as key value pairs&#010;+     * @param encode whether to URL encode the returned uri or not&#010;+     * @return the constructed endpoint uri&#010;+     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;+     */&#010;+    String asEndpointUri(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;+&#010;+    /**&#010;+     * Creates an endpoint uri in XML style (eg escape &amp; as &amp;ampl;) from the information from the properties&#010;+     *&#010;+     * @param scheme the endpoint schema&#010;+     * @param properties the properties as key value pairs&#010;+     * @param encode whether to URL encode the returned uri or not&#010;+     * @return the constructed endpoint uri&#010;+     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;+     */&#010;+    String asEndpointUriXml(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java&#010;new file mode 100644&#010;index 0000000..1b8dd0e&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java&#010;@@ -0,0 +1,32 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+/**&#010;+ * To be backwards compatible, but favor using {@link LanguageValidationResult} instead.&#010;+ */&#010;+public class SimpleValidationResult extends LanguageValidationResult {&#010;+&#010;+    public SimpleValidationResult(String text) {&#010;+        super(text);&#010;+    }&#010;+&#010;+    public String getSimple() {&#010;+        return getText();&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java&#010;new file mode 100644&#010;index 0000000..e29afc6&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java&#010;@@ -0,0 +1,34 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.Set;&#010;+&#010;+/**&#010;+ * Strategy to provide suggestions for unknown endpoint options&#010;+ */&#010;+public interface SuggestionStrategy {&#010;+&#010;+    /**&#010;+     * Provides a list of valid option names for a did you mean function.&#010;+     *&#010;+     * @param names         valid names&#010;+     * @param unknownOption unknown option name&#010;+     * @return a list of suggested names (did you mean)&#010;+     */&#010;+    String[] suggestEndpointOptions(Set&lt;String&gt; names, String unknownOption);&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java&#010;new file mode 100644&#010;index 0000000..ed5585c&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java&#010;@@ -0,0 +1,120 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+/**&#010;+ * This class is a copy from camel-core so we can use it independent to validate uris with time patterns&#010;+ */&#010;+public final class TimePatternConverter {&#010;+    private static final Pattern NUMBERS_ONLY_STRING_PATTERN = Pattern.compile(""^[-]?(\\d)+$"", Pattern.CASE_INSENSITIVE);&#010;+    private static final Pattern HOUR_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))h(our(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;+    private static final Pattern MINUTES_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))m(in(ute(s)?)?)?"", Pattern.CASE_INSENSITIVE);&#010;+    private static final Pattern SECONDS_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))s(ec(ond)?(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;+&#010;+    /**&#010;+     * Utility classes should not have a public constructor.&#010;+     */&#010;+    private TimePatternConverter() {&#010;+    }&#010;+&#010;+    public static long toMilliSeconds(String source) throws IllegalArgumentException {&#010;+        long milliseconds = 0;&#010;+        boolean foundFlag = false;&#010;+&#010;+        checkCorrectnessOfPattern(source);&#010;+        Matcher matcher;&#010;+&#010;+        matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;+        if (matcher.find()) {&#010;+            // Note: This will also be used for regular numeric strings.&#010;+            //       This String -&gt; long converter will be used for all strings.&#010;+            milliseconds = Long.valueOf(source);&#010;+        } else {&#010;+            matcher = createMatcher(HOUR_REGEX_PATTERN, source);&#010;+            if (matcher.find()) {&#010;+                milliseconds = milliseconds + (3600000 * Long.valueOf(matcher.group(1)));&#010;+                foundFlag = true;&#010;+            }&#010;+&#010;+            matcher = createMatcher(MINUTES_REGEX_PATTERN, source);&#010;+            if (matcher.find()) {&#010;+                long minutes = Long.valueOf(matcher.group(1));&#010;+                if ((minutes &gt; 59) &amp;&amp; foundFlag) {&#010;+                    throw new IllegalArgumentException(""Minutes should contain a valid value between 0 and 59: "" + source);&#010;+                }&#010;+                foundFlag = true;&#010;+                milliseconds = milliseconds + (60000 * minutes);&#010;+            }&#010;+&#010;+            matcher = createMatcher(SECONDS_REGEX_PATTERN, source);&#010;+            if (matcher.find()) {&#010;+                long seconds = Long.valueOf(matcher.group(1));&#010;+                if ((seconds &gt; 59) &amp;&amp; foundFlag) {&#010;+                    throw new IllegalArgumentException(""Seconds should contain a valid value between 0 and 59: "" + source);&#010;+                }&#010;+                foundFlag = true;&#010;+                milliseconds = milliseconds + (1000 * seconds);&#010;+            }&#010;+&#010;+            // No pattern matched... initiating fallback check and conversion (if required).&#010;+            // The source at this point may contain illegal values or special characters&#010;+            if (!foundFlag) {&#010;+                milliseconds = Long.valueOf(source);&#010;+            }&#010;+        }&#010;+&#010;+        return milliseconds;&#010;+    }&#010;+&#010;+    private static void checkCorrectnessOfPattern(String source) {&#010;+        //replace only numbers once&#010;+        Matcher matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;+        String replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        //replace hour string once&#010;+        matcher = createMatcher(HOUR_REGEX_PATTERN, replaceSource);&#010;+        if (matcher.find() &amp;&amp; matcher.find()) {&#010;+            throw new IllegalArgumentException(""Hours should not be specified more then once: "" + source);&#010;+        }&#010;+        replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        //replace minutes once&#010;+        matcher = createMatcher(MINUTES_REGEX_PATTERN, replaceSource);&#010;+        if (matcher.find() &amp;&amp; matcher.find()) {&#010;+            throw new IllegalArgumentException(""Minutes should not be specified more then once: "" + source);&#010;+        }&#010;+        replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        //replace seconds once&#010;+        matcher = createMatcher(SECONDS_REGEX_PATTERN, replaceSource);&#010;+        if (matcher.find() &amp;&amp; matcher.find()) {&#010;+            throw new IllegalArgumentException(""Seconds should not be specified more then once: "" + source);&#010;+        }&#010;+        replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        if (replaceSource.length() &gt; 0) {&#010;+            throw new IllegalArgumentException(""Illegal characters: "" + source);&#010;+        }&#010;+    }&#010;+&#010;+    private static Matcher createMatcher(Pattern pattern, String source) {&#010;+        return pattern.matcher(source);&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java&#010;new file mode 100644&#010;index 0000000..8389590&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java&#010;@@ -0,0 +1,392 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.UnsupportedEncodingException;&#010;+import java.net.URI;&#010;+import java.net.URISyntaxException;&#010;+import java.net.URLDecoder;&#010;+import java.net.URLEncoder;&#010;+import java.util.ArrayList;&#010;+import java.util.Iterator;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+&#010;+/**&#010;+ * Copied from org.apache.camel.util.URISupport&#010;+ */&#010;+public final class URISupport {&#010;+&#010;+    public static final String RAW_TOKEN_START = ""RAW("";&#010;+    public static final String RAW_TOKEN_END = "")"";&#010;+&#010;+    private static final String CHARSET = ""UTF-8"";&#010;+&#010;+    private URISupport() {&#010;+        // Helper class&#010;+    }&#010;+&#010;+    /**&#010;+     * Normalizes the URI so unsafe characters is encoded&#010;+     *&#010;+     * @param uri the input uri&#010;+     * @return as URI instance&#010;+     * @throws URISyntaxException is thrown if syntax error in the input uri&#010;+     */&#010;+    public static URI normalizeUri(String uri) throws URISyntaxException {&#010;+        return new URI(UnsafeUriCharactersEncoder.encode(uri, true));&#010;+    }&#010;+&#010;+    public static Map&lt;String, Object&gt; extractProperties(Map&lt;String, Object&gt; properties, String optionPrefix) {&#010;+        Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;(properties.size());&#010;+&#010;+        for (Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; it = properties.entrySet().iterator(); it.hasNext();) {&#010;+            Map.Entry&lt;String, Object&gt; entry = it.next();&#010;+            String name = entry.getKey();&#010;+            if (name.startsWith(optionPrefix)) {&#010;+                Object value = properties.get(name);&#010;+                name = name.substring(optionPrefix.length());&#010;+                rc.put(name, value);&#010;+                it.remove();&#010;+            }&#010;+        }&#010;+&#010;+        return rc;&#010;+    }&#010;+&#010;+    /**&#010;+     * Strips the query parameters from the uri&#010;+     *&#010;+     * @param uri  the uri&#010;+     * @return the uri without the query parameter&#010;+     */&#010;+    public static String stripQuery(String uri) {&#010;+        int idx = uri.indexOf('?');&#010;+        if (idx &gt; -1) {&#010;+            uri = uri.substring(0, idx);&#010;+        }&#010;+        return uri;&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the query parameters of the uri (eg the query part).&#010;+     *&#010;+     * @param uri the uri&#010;+     * @return the parameters, or an empty map if no parameters (eg never null)&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     */&#010;+    public static Map&lt;String, Object&gt; parseParameters(URI uri) throws URISyntaxException {&#010;+        String query = uri.getQuery();&#010;+        if (query == null) {&#010;+            String schemeSpecificPart = uri.getSchemeSpecificPart();&#010;+            int idx = schemeSpecificPart.indexOf('?');&#010;+            if (idx &lt; 0) {&#010;+                // return an empty map&#010;+                return new LinkedHashMap&lt;String, Object&gt;(0);&#010;+            } else {&#010;+                query = schemeSpecificPart.substring(idx + 1);&#010;+            }&#010;+        } else {&#010;+            query = stripPrefix(query, ""?"");&#010;+        }&#010;+        return parseQuery(query);&#010;+    }&#010;+&#010;+    /**&#010;+     * Strips the prefix from the value.&#010;+     * &lt;p/&gt;&#010;+     * Returns the value as-is if not starting with the prefix.&#010;+     *&#010;+     * @param value  the value&#010;+     * @param prefix the prefix to remove from value&#010;+     * @return the value without the prefix&#010;+     */&#010;+    public static String stripPrefix(String value, String prefix) {&#010;+        if (value != null &amp;&amp; value.startsWith(prefix)) {&#010;+            return value.substring(prefix.length());&#010;+        }&#010;+        return value;&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the query part of the uri (eg the parameters).&#010;+     * &lt;p/&gt;&#010;+     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;+     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;+     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;+     *&#010;+     * @param uri the uri&#010;+     * @return the parameters, or an empty map if no parameters (eg never null)&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     * @see #RAW_TOKEN_START&#010;+     * @see #RAW_TOKEN_END&#010;+     */&#010;+    public static Map&lt;String, Object&gt; parseQuery(String uri) throws URISyntaxException {&#010;+        return parseQuery(uri, false);&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the query part of the uri (eg the parameters).&#010;+     * &lt;p/&gt;&#010;+     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;+     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;+     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;+     *&#010;+     * @param uri the uri&#010;+     * @param useRaw whether to force using raw values&#010;+     * @return the parameters, or an empty map if no parameters (eg never null)&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     * @see #RAW_TOKEN_START&#010;+     * @see #RAW_TOKEN_END&#010;+     */&#010;+    public static Map&lt;String, Object&gt; parseQuery(String uri, boolean useRaw) throws URISyntaxException {&#010;+        // must check for trailing &amp; as the uri.split(""&amp;"") will ignore those&#010;+        if (uri != null &amp;&amp; uri.endsWith(""&amp;"")) {&#010;+            throw new URISyntaxException(uri, ""Invalid uri syntax: Trailing &amp; marker found. ""&#010;+                    + ""Check the uri and remove the trailing &amp; marker."");&#010;+        }&#010;+&#010;+        if (isEmpty(uri)) {&#010;+            // return an empty map&#010;+            return new LinkedHashMap&lt;String, Object&gt;(0);&#010;+        }&#010;+&#010;+        // need to parse the uri query parameters manually as we cannot rely on splitting by &amp;,&#010;+        // as &amp; can be used in a parameter value as well.&#010;+&#010;+        try {&#010;+            // use a linked map so the parameters is in the same order&#010;+            Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;();&#010;+&#010;+            boolean isKey = true;&#010;+            boolean isValue = false;&#010;+            boolean isRaw = false;&#010;+            StringBuilder key = new StringBuilder();&#010;+            StringBuilder value = new StringBuilder();&#010;+&#010;+            // parse the uri parameters char by char&#010;+            for (int i = 0; i &lt; uri.length(); i++) {&#010;+                // current char&#010;+                char ch = uri.charAt(i);&#010;+                // look ahead of the next char&#010;+                char next;&#010;+                if (i &lt;= uri.length() - 2) {&#010;+                    next = uri.charAt(i + 1);&#010;+                } else {&#010;+                    next = '\u0000';&#010;+                }&#010;+&#010;+                // are we a raw value&#010;+                isRaw = value.toString().startsWith(RAW_TOKEN_START);&#010;+&#010;+                // if we are in raw mode, then we keep adding until we hit the end marker&#010;+                if (isRaw) {&#010;+                    if (isKey) {&#010;+                        key.append(ch);&#010;+                    } else if (isValue) {&#010;+                        value.append(ch);&#010;+                    }&#010;+&#010;+                    // we only end the raw marker if its )&amp; or at the end of the value&#010;+&#010;+                    boolean end = ch == RAW_TOKEN_END.charAt(0) &amp;&amp; (next == '&amp;' || next == '\u0000');&#010;+                    if (end) {&#010;+                        // raw value end, so add that as a parameter, and reset flags&#010;+                        addParameter(key.toString(), value.toString(), rc, useRaw || isRaw);&#010;+                        key.setLength(0);&#010;+                        value.setLength(0);&#010;+                        isKey = true;&#010;+                        isValue = false;&#010;+                        isRaw = false;&#010;+                        // skip to next as we are in raw mode and have already added the value&#010;+                        i++;&#010;+                    }&#010;+                    continue;&#010;+                }&#010;+&#010;+                // if its a key and there is a = sign then the key ends and we are in value mode&#010;+                if (isKey &amp;&amp; ch == '=') {&#010;+                    isKey = false;&#010;+                    isValue = true;&#010;+                    isRaw = false;&#010;+                    continue;&#010;+                }&#010;+&#010;+                // the &amp; denote parameter is ended&#010;+                if (ch == '&amp;') {&#010;+                    // parameter is ended, as we hit &amp; separator&#010;+                    String aKey = key.toString();&#010;+                    // the key may be a placeholder of options which we then do not know what is&#010;+                    boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;+                    if (validKey) {&#010;+                        addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;+                    }&#010;+                    key.setLength(0);&#010;+                    value.setLength(0);&#010;+                    isKey = true;&#010;+                    isValue = false;&#010;+                    isRaw = false;&#010;+                    continue;&#010;+                }&#010;+&#010;+                // regular char so add it to the key or value&#010;+                if (isKey) {&#010;+                    key.append(ch);&#010;+                } else if (isValue) {&#010;+                    value.append(ch);&#010;+                }&#010;+            }&#010;+&#010;+            // any left over parameters, then add that&#010;+            if (key.length() &gt; 0) {&#010;+                String aKey = key.toString();&#010;+                // the key may be a placeholder of options which we then do not know what is&#010;+                boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;+                if (validKey) {&#010;+                    addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;+                }&#010;+            }&#010;+&#010;+            return rc;&#010;+&#010;+        } catch (UnsupportedEncodingException e) {&#010;+            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;+            se.initCause(e);&#010;+            throw se;&#010;+        }&#010;+    }&#010;+&#010;+    @SuppressWarnings(""unchecked"")&#010;+    private static void addParameter(String name, String value, Map&lt;String, Object&gt; map, boolean isRaw) throws UnsupportedEncodingException {&#010;+        name = URLDecoder.decode(name, CHARSET);&#010;+        if (!isRaw) {&#010;+            // need to replace % with %25&#010;+            value = URLDecoder.decode(value.replaceAll(""%"", ""%25""), CHARSET);&#010;+        }&#010;+&#010;+        // does the key already exist?&#010;+        if (map.containsKey(name)) {&#010;+            // yes it does, so make sure we can support multiple values, but using a list&#010;+            // to hold the multiple values&#010;+            Object existing = map.get(name);&#010;+            List&lt;String&gt; list;&#010;+            if (existing instanceof List) {&#010;+                list = (List&lt;String&gt;) existing;&#010;+            } else {&#010;+                // create a new list to hold the multiple values&#010;+                list = new ArrayList&lt;String&gt;();&#010;+                String s = existing != null ? existing.toString() : null;&#010;+                if (s != null) {&#010;+                    list.add(s);&#010;+                }&#010;+            }&#010;+            list.add(value);&#010;+            map.put(name, list);&#010;+        } else {&#010;+            map.put(name, value);&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Assembles a query from the given map.&#010;+     *&#010;+     * @param options  the map with the options (eg key/value pairs)&#010;+     * @param ampersand to use &amp; for Java code, and &amp;amp; for XML&#010;+     * @return a query string with &lt;tt&gt;key1=value&amp;key2=value2&amp;...&lt;/tt&gt;, or an empty string if there is no options.&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     */&#010;+    public static String createQueryString(Map&lt;String, String&gt; options, String ampersand, boolean encode) throws URISyntaxException {&#010;+        try {&#010;+            if (options.size() &gt; 0) {&#010;+                StringBuilder rc = new StringBuilder();&#010;+                boolean first = true;&#010;+                for (Object o : options.keySet()) {&#010;+                    if (first) {&#010;+                        first = false;&#010;+                    } else {&#010;+                        rc.append(ampersand);&#010;+                    }&#010;+&#010;+                    String key = (String) o;&#010;+                    Object value = options.get(key);&#010;+&#010;+                    // use the value as a String&#010;+                    String s = value != null ? value.toString() : null;&#010;+                    appendQueryStringParameter(key, s, rc, encode);&#010;+                }&#010;+                return rc.toString();&#010;+            } else {&#010;+                return """";&#010;+            }&#010;+        } catch (UnsupportedEncodingException e) {&#010;+            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;+            se.initCause(e);&#010;+            throw se;&#010;+        }&#010;+    }&#010;+&#010;+    private static void appendQueryStringParameter(String key, String value, StringBuilder rc, boolean encode) throws UnsupportedEncodingException {&#010;+        if (encode) {&#010;+            rc.append(URLEncoder.encode(key, CHARSET));&#010;+        } else {&#010;+            rc.append(key);&#010;+        }&#010;+        // only append if value is not null&#010;+        if (value != null) {&#010;+            rc.append(""="");&#010;+            if (value.startsWith(RAW_TOKEN_START) &amp;&amp; value.endsWith(RAW_TOKEN_END)) {&#010;+                // do not encode RAW parameters&#010;+                rc.append(value);&#010;+            } else {&#010;+                if (encode) {&#010;+                    rc.append(URLEncoder.encode(value, CHARSET));&#010;+                } else {&#010;+                    rc.append(value);&#010;+                }&#010;+            }&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if empty&#010;+     */&#010;+    public static boolean isEmpty(Object value) {&#010;+        return !isNotEmpty(value);&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;b&gt;not&lt;/b&gt; &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if &lt;b&gt;not&lt;/b&gt; empty&#010;+     */&#010;+    public static boolean isNotEmpty(Object value) {&#010;+        if (value == null) {&#010;+            return false;&#010;+        } else if (value instanceof String) {&#010;+            String text = (String) value;&#010;+            return text.trim().length() &gt; 0;&#010;+        } else {&#010;+            return true;&#010;+        }&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java&#010;new file mode 100644&#010;index 0000000..a11c810&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java&#010;@@ -0,0 +1,206 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.ArrayList;&#010;+import java.util.BitSet;&#010;+import java.util.List;&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+/**&#010;+ * Encoder for unsafe URI characters.&#010;+ * &lt;p/&gt;&#010;+ * A good source for details is &lt;a href=""http://en.wikipedia.org/wiki/Url_encode""&gt;wikipedia url encode&lt;/a&gt; article.&#010;+ */&#010;+public final class UnsafeUriCharactersEncoder {&#010;+    private static BitSet unsafeCharactersRfc1738;&#010;+    private static BitSet unsafeCharactersHttp;&#010;+    private static final char[] HEX_DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C',&#010;+        'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'};&#010;+    private static final Pattern RAW_PATTERN = Pattern.compile(""RAW\\([^\\)]+\\)"");&#010;+&#010;+    static {&#010;+        unsafeCharactersRfc1738 = new BitSet(256);&#010;+        unsafeCharactersRfc1738.set(' ');&#010;+        unsafeCharactersRfc1738.set('""');&#010;+        unsafeCharactersRfc1738.set('&lt;');&#010;+        unsafeCharactersRfc1738.set('&gt;');&#010;+        unsafeCharactersRfc1738.set('#');&#010;+        unsafeCharactersRfc1738.set('%');&#010;+        unsafeCharactersRfc1738.set('{');&#010;+        unsafeCharactersRfc1738.set('}');&#010;+        unsafeCharactersRfc1738.set('|');&#010;+        unsafeCharactersRfc1738.set('\\');&#010;+        unsafeCharactersRfc1738.set('^');&#010;+        unsafeCharactersRfc1738.set('~');&#010;+        unsafeCharactersRfc1738.set('[');&#010;+        unsafeCharactersRfc1738.set(']');&#010;+        unsafeCharactersRfc1738.set('`');&#010;+    }&#010;+&#010;+    static {&#010;+        unsafeCharactersHttp = new BitSet(256);&#010;+        unsafeCharactersHttp.set(' ');&#010;+        unsafeCharactersHttp.set('""');&#010;+        unsafeCharactersHttp.set('&lt;');&#010;+        unsafeCharactersHttp.set('&gt;');&#010;+        unsafeCharactersHttp.set('#');&#010;+        unsafeCharactersHttp.set('%');&#010;+        unsafeCharactersHttp.set('{');&#010;+        unsafeCharactersHttp.set('}');&#010;+        unsafeCharactersHttp.set('|');&#010;+        unsafeCharactersHttp.set('\\');&#010;+        unsafeCharactersHttp.set('^');&#010;+        unsafeCharactersHttp.set('~');&#010;+        unsafeCharactersHttp.set('`');&#010;+    }&#010;+&#010;+    private UnsafeUriCharactersEncoder() {&#010;+        // util class&#010;+    }&#010;+&#010;+    public static String encode(String s) {&#010;+        return encode(s, unsafeCharactersRfc1738);&#010;+    }&#010;+&#010;+    public static String encodeHttpURI(String s) {&#010;+        return encode(s, unsafeCharactersHttp);&#010;+    }&#010;+&#010;+    public static String encode(String s, BitSet unsafeCharacters) {&#010;+        return encode(s, unsafeCharacters, false);&#010;+    }&#010;+&#010;+    public static String encode(String s, boolean checkRaw) {&#010;+        return encode(s, unsafeCharactersRfc1738, checkRaw);&#010;+    }&#010;+&#010;+    public static String encodeHttpURI(String s, boolean checkRaw) {&#010;+        return encode(s, unsafeCharactersHttp, checkRaw);&#010;+    }&#010;+&#010;+    private static List&lt;Pair&gt; checkRAW(String s) {&#010;+        Matcher matcher = RAW_PATTERN.matcher(s);&#010;+        List&lt;Pair&gt; answer = new ArrayList&lt;Pair&gt;();&#010;+        // Check all occurrences&#010;+        while (matcher.find()) {&#010;+            answer.add(new Pair(matcher.start(), matcher.end()));&#010;+        }&#010;+        return answer;&#010;+    }&#010;+&#010;+    private static boolean isRaw(int index, List&lt;Pair&gt; pairs) {&#010;+        for (Pair pair : pairs) {&#010;+            if (index &lt; pair.left) {&#010;+                return false;&#010;+            } else {&#010;+                if (index &gt;= pair.left) {&#010;+                    if (index &lt;= pair.right) {&#010;+                        return true;&#010;+                    } else {&#010;+                        continue;&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    private static class Pair {&#010;+        int left;&#010;+        int right;&#010;+&#010;+        Pair(int left, int right) {&#010;+            this.left = left;&#010;+            this.right = right;&#010;+        }&#010;+    }&#010;+&#010;+    // Just skip the encode for isRAW part&#010;+    public static String encode(String s, BitSet unsafeCharacters, boolean checkRaw) {&#010;+        List&lt;Pair&gt; rawPairs;&#010;+        if (checkRaw) {&#010;+            rawPairs = checkRAW(s);&#010;+        } else {&#010;+            rawPairs = new ArrayList&lt;Pair&gt;();&#010;+        }&#010;+&#010;+        int n = s == null ? 0 : s.length();&#010;+        if (n == 0) {&#010;+            return s;&#010;+        }&#010;+&#010;+        // First check whether we actually need to encode&#010;+        char chars[] = s.toCharArray();&#010;+        for (int i = 0;;) {&#010;+            // just deal with the ascii character&#010;+            if (chars[i] &gt; 0 &amp;&amp; chars[i] &lt; 128) {&#010;+                if (unsafeCharacters.get(chars[i])) {&#010;+                    break;&#010;+                }&#010;+            }&#010;+            if (++i &gt;= chars.length) {&#010;+                return s;&#010;+            }&#010;+        }&#010;+&#010;+        // okay there are some unsafe characters so we do need to encode&#010;+        // see details at: http://en.wikipedia.org/wiki/Url_encode&#010;+        StringBuilder sb = new StringBuilder();&#010;+        for (int i = 0; i &lt; chars.length; i++) {&#010;+            char ch = chars[i];&#010;+            if (ch &gt; 0 &amp;&amp; ch &lt; 128 &amp;&amp; unsafeCharacters.get(ch)) {&#010;+                // special for % sign as it may be a decimal encoded value&#010;+                if (ch == '%') {&#010;+                    char next = i + 1 &lt; chars.length ? chars[i + 1] : ' ';&#010;+                    char next2 = i + 2 &lt; chars.length ? chars[i + 2] : ' ';&#010;+&#010;+                    if (isHexDigit(next) &amp;&amp; isHexDigit(next2) &amp;&amp; !isRaw(i, rawPairs)) {&#010;+                        // its already encoded (decimal encoded) so just append as is&#010;+                        sb.append(ch);&#010;+                    } else {&#010;+                        // must escape then, as its an unsafe character&#010;+                        appendEscape(sb, (byte) ch);&#010;+                    }&#010;+                } else {&#010;+                    // must escape then, as its an unsafe character&#010;+                    appendEscape(sb, (byte) ch);&#010;+                }&#010;+            } else {&#010;+                sb.append(ch);&#010;+            }&#010;+        }&#010;+        return sb.toString();&#010;+    }&#010;+&#010;+    private static void appendEscape(StringBuilder sb, byte b) {&#010;+        sb.append('%');&#010;+        sb.append(HEX_DIGITS[(b &gt;&gt; 4) &amp; 0x0f]);&#010;+        sb.append(HEX_DIGITS[(b &gt;&gt; 0) &amp; 0x0f]);&#010;+    }&#010;+&#010;+    private static boolean isHexDigit(char ch) {&#010;+        for (char hex : HEX_DIGITS) {&#010;+            if (hex == ch) {&#010;+                return true;&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html b/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html&#010;new file mode 100644&#010;index 0000000..2f15a04&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html&#010;@@ -0,0 +1,25 @@&#010;+&lt;!--&#010;+    Licensed to the Apache Software Foundation (ASF) under one or more&#010;+    contributor license agreements.  See the NOTICE file distributed with&#010;+    this work for additional information regarding copyright ownership.&#010;+    The ASF licenses this file to You under the Apache License, Version 2.0&#010;+    (the ""License""); you may not use this file except in compliance with&#010;+    the License.  You may obtain a copy of the License at&#010;+&#010;+    http://www.apache.org/licenses/LICENSE-2.0&#010;+&#010;+    Unless required by applicable law or agreed to in writing, software&#010;+    distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+    See the License for the specific language governing permissions and&#010;+    limitations under the License.&#010;+--&gt;&#010;+&lt;html&gt;&#010;+&lt;head&gt;&#010;+&lt;/head&gt;&#010;+&lt;body&gt;&#010;+&#010;+Runtime Camel Catalog&#010;+&#010;+&lt;/body&gt;&#010;+&lt;/html&gt;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java b/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;index fd22f55..a32c109 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;@@ -37,8 +37,8 @@ import org.apache.camel.PollingConsumer;&#010; import org.apache.camel.Processor;&#010; import org.apache.camel.ResolveEndpointFailedException;&#010; import org.apache.camel.Route;&#010;-import org.apache.camel.catalog.DefaultRuntimeCamelCatalog;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.DefaultRuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.BrowsableEndpoint;&#010; import org.slf4j.Logger;&#010; import org.slf4j.LoggerFactory;&#010;@@ -523,7 +523,7 @@ public final class EndpointHelper {&#010;      * @param uri          the endpoint uri&#010;      * @return a map for each option in the uri with the corresponding information from the json&#010;      * @throws Exception is thrown in case of error&#010;-     * @deprecated use {@link org.apache.camel.catalog.RuntimeCamelCatalog#endpointProperties(String)}&#010;+     * @deprecated use {@link org.apache.camel.runtimecatalog.RuntimeCamelCatalog#endpointProperties(String)}&#010;      */&#010;     @Deprecated&#010;     public static Map&lt;String, Object&gt; endpointProperties(CamelContext camelContext, String uri) throws Exception {&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java b/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java&#010;deleted file mode 100644&#010;index ed7e997..0000000&#010;--- a/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java&#010;+++ /dev/null&#010;@@ -1,104 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.net.URISyntaxException;&#010;-import java.util.HashMap;&#010;-import java.util.Map;&#010;-&#010;-import org.junit.Before;&#010;-import org.junit.Test;&#010;-&#010;-import static org.easymock.EasyMock.expect;&#010;-import static org.easymock.EasyMock.mock;&#010;-import static org.easymock.EasyMock.replay;&#010;-import static org.junit.Assert.assertEquals;&#010;-&#010;-public class AbstractCamelCatalogTest {&#010;-&#010;-    AbstractCamelCatalog catalog = new AbstractCamelCatalog() {&#010;-    };&#010;-&#010;-    JSonSchemaResolver resolver;&#010;-&#010;-    @Before&#010;-    public void setupMockCatalog() {&#010;-        resolver = mock(JSonSchemaResolver.class);&#010;-&#010;-        catalog.setJSonSchemaResolver(resolver);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void shouldConstructEndpointUris() throws URISyntaxException {&#010;-        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;-            + ""  \""component\"": {\n""//&#010;-            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;-            + ""  }\n""//&#010;-            + ""}"");&#010;-&#010;-        replay(resolver);&#010;-&#010;-        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;-        properties.put(""param1"", ""value1"");&#010;-        properties.put(""param2"", ""value2"");&#010;-        properties.put(""param3"", ""value3"");&#010;-&#010;-        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;-&#010;-        assertEquals(""comp:value1:value2?param3=value3"", endpointUri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void shouldConstructEndpointUrisWithPropertyPlaceholders() throws URISyntaxException {&#010;-        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;-            + ""  \""component\"": {\n""//&#010;-            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;-            + ""  }\n""//&#010;-            + ""}"");&#010;-&#010;-        replay(resolver);&#010;-&#010;-        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;-        properties.put(""param1"", ""{{prop1}}"");&#010;-        properties.put(""param2"", ""{{prop2}}"");&#010;-        properties.put(""param3"", ""{{prop3}}"");&#010;-&#010;-        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;-&#010;-        assertEquals(""comp:{{prop1}}:{{prop2}}?param3={{prop3}}"", endpointUri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void shouldConstructEndpointUrisWhenValuesContainTokens() throws URISyntaxException {&#010;-        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;-            + ""  \""component\"": {\n""//&#010;-            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;-            + ""  }\n""//&#010;-            + ""}"");&#010;-&#010;-        replay(resolver);&#010;-&#010;-        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;-        properties.put(""param1"", ""{value1}"");&#010;-        properties.put(""param2"", ""/value2/"");&#010;-        properties.put(""param3"", ""/value3/{param}"");&#010;-&#010;-        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;-&#010;-        assertEquals(""comp:{value1}:/value2/?param3=/value3/{param}"", endpointUri);&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java b/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java&#010;deleted file mode 100644&#010;index 78e51a2..0000000&#010;--- a/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java&#010;+++ /dev/null&#010;@@ -1,393 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.HashMap;&#010;-import java.util.Map;&#010;-&#010;-import org.apache.camel.impl.DefaultCamelContext;&#010;-import org.junit.BeforeClass;&#010;-import org.junit.Test;&#010;-import org.slf4j.Logger;&#010;-import org.slf4j.LoggerFactory;&#010;-&#010;-import static org.junit.Assert.assertEquals;&#010;-import static org.junit.Assert.assertFalse;&#010;-import static org.junit.Assert.assertNotNull;&#010;-import static org.junit.Assert.assertTrue;&#010;-&#010;-public class RuntimeCamelCatalogTest {&#010;-&#010;-    static RuntimeCamelCatalog catalog;&#010;-&#010;-    private static final Logger LOG = LoggerFactory.getLogger(RuntimeCamelCatalogTest.class);&#010;-&#010;-    @BeforeClass&#010;-    public static void createCamelCatalog() {&#010;-        catalog = new DefaultRuntimeCamelCatalog(new DefaultCamelContext());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testFromCamelContext() throws Exception {&#010;-        String schema = new DefaultCamelContext().getRuntimeCamelCatalog().modelJSonSchema(""choice"");&#010;-        assertNotNull(schema);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testJsonSchema() throws Exception {&#010;-        String schema = catalog.modelJSonSchema(""aggregate"");&#010;-        assertNotNull(schema);&#010;-&#010;-        // lets make it possible to find bean/method using both names&#010;-        schema = catalog.modelJSonSchema(""method"");&#010;-        assertNotNull(schema);&#010;-        schema = catalog.modelJSonSchema(""bean"");&#010;-        assertNotNull(schema);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriMapFile() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""directoryName"", ""src/data/inbox"");&#010;-        map.put(""noop"", ""true"");&#010;-        map.put(""delay"", ""5000"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""file"", map, true);&#010;-        assertEquals(""file:src/data/inbox?delay=5000&amp;noop=true"", uri);&#010;-&#010;-        String uri2 = catalog.asEndpointUriXml(""file"", map, true);&#010;-        assertEquals(""file:src/data/inbox?delay=5000&amp;amp;noop=true"", uri2);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriTimer() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""timerName"", ""foo"");&#010;-        map.put(""period"", ""5000"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;-        assertEquals(""timer:foo?period=5000"", uri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriPropertiesPlaceholders() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""timerName"", ""foo"");&#010;-        map.put(""period"", ""{{howoften}}"");&#010;-        map.put(""repeatCount"", ""5"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;-        assertEquals(""timer:foo?period=%7B%7Bhowoften%7D%7D&amp;repeatCount=5"", uri);&#010;-&#010;-        uri = catalog.asEndpointUri(""timer"", map, false);&#010;-        assertEquals(""timer:foo?period={{howoften}}&amp;repeatCount=5"", uri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriBeanLookup() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""resourceUri"", ""foo.xslt"");&#010;-        map.put(""converter"", ""#myConverter"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""xslt"", map, true);&#010;-        assertEquals(""xslt:foo.xslt?converter=%23myConverter"", uri);&#010;-&#010;-        uri = catalog.asEndpointUri(""xslt"", map, false);&#010;-        assertEquals(""xslt:foo.xslt?converter=#myConverter"", uri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testEndpointPropertiesPlaceholders() throws Exception {&#010;-        Map&lt;String, String&gt; map = catalog.endpointProperties(""timer:foo?period={{howoften}}&amp;repeatCount=5"");&#010;-        assertNotNull(map);&#010;-        assertEquals(3, map.size());&#010;-&#010;-        assertEquals(""foo"", map.get(""timerName""));&#010;-        assertEquals(""{{howoften}}"", map.get(""period""));&#010;-        assertEquals(""5"", map.get(""repeatCount""));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriLog() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""loggerName"", ""foo"");&#010;-        map.put(""loggerLevel"", ""WARN"");&#010;-        map.put(""multiline"", ""true"");&#010;-        map.put(""showAll"", ""true"");&#010;-        map.put(""showBody"", ""false"");&#010;-        map.put(""showBodyType"", ""false"");&#010;-        map.put(""showExchangePattern"", ""false"");&#010;-        map.put(""style"", ""Tab"");&#010;-&#010;-        assertEquals(""log:foo?loggerLevel=WARN&amp;multiline=true&amp;showAll=true&amp;style=Tab"", catalog.asEndpointUri(""log"", map, false));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriLogShort() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""loggerName"", ""foo"");&#010;-        map.put(""loggerLevel"", ""DEBUG"");&#010;-&#010;-        assertEquals(""log:foo?loggerLevel=DEBUG"", catalog.asEndpointUri(""log"", map, false));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriWithplaceholder() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""name"", ""foo"");&#010;-        map.put(""blockWhenFull"", ""{{block}}"");&#010;-        assertEquals(""seda:foo?blockWhenFull={{block}}"", catalog.asEndpointUri(""seda"", map, false));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testEndpointPropertiesSedaRequired() throws Exception {&#010;-        Map&lt;String, String&gt; map = catalog.endpointProperties(""seda:foo"");&#010;-        assertNotNull(map);&#010;-        assertEquals(1, map.size());&#010;-&#010;-        assertEquals(""foo"", map.get(""name""));&#010;-&#010;-        map = catalog.endpointProperties(""seda:foo?blockWhenFull=true"");&#010;-        assertNotNull(map);&#010;-        assertEquals(2, map.size());&#010;-&#010;-        assertEquals(""foo"", map.get(""name""));&#010;-        assertEquals(""true"", map.get(""blockWhenFull""));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void validateProperties() throws Exception {&#010;-        // valid&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(""log:mylog"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // unknown&#010;-        result = catalog.validateEndpointProperties(""log:mylog?level=WARN&amp;foo=bar"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getUnknown().contains(""foo""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // enum&#010;-        result = catalog.validateEndpointProperties(""seda:foo?waitForTaskToComplete=blah"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""blah"", result.getInvalidEnum().get(""waitForTaskToComplete""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // reference okay&#010;-        result = catalog.validateEndpointProperties(""seda:foo?queue=#queue"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(0, result.getNumberOfErrors());&#010;-&#010;-        // unknown component&#010;-        result = catalog.validateEndpointProperties(""foo:bar?me=you"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getUnknownComponent().equals(""foo""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // invalid boolean but default value&#010;-        result = catalog.validateEndpointProperties(""log:output?showAll=ggg"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""ggg"", result.getInvalidBoolean().get(""showAll""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // dataset&#010;-        result = catalog.validateEndpointProperties(""dataset:foo?minRate=50"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // time pattern&#010;-        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=true&amp;delay=0&amp;period=2s"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // reference lookup&#010;-        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=#fixed&amp;delay=#myDelay"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // optional consumer. prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?consumer.delay=5000&amp;consumer.greedy=true"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // optional without consumer. prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;greedy=true"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // mixed optional without consumer. prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;consumer.greedy=true"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;scheduler.foo=123&amp;scheduler.bar=456"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // stub&#010;-        result = catalog.validateEndpointProperties(""stub:foo?me=123&amp;you=456"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // lenient on&#010;-        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // lenient off&#010;-        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"", true);&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getUnknown().contains(""foo""));&#010;-&#010;-        // data format&#010;-        result = catalog.validateEndpointProperties(""dataformat:string:marshal?charset=utf-8"", true);&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // incapable to parse&#010;-        result = catalog.validateEndpointProperties(""{{getFtpUrl}}?recursive=true"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getIncapable() != null);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void validatePropertiesSummary() throws Exception {&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(""yammer:MESSAGES?blah=yada&amp;accessToken=aaa&amp;consumerKey=&amp;useJson=no&amp;initialDelay=five&amp;pollStrategy=myStrategy"");&#010;-        assertFalse(result.isSuccess());&#010;-        String reason = result.summaryErrorMessage(true);&#010;-        LOG.info(reason);&#010;-&#010;-        result = catalog.validateEndpointProperties(""jms:unknown:myqueue"");&#010;-        assertFalse(result.isSuccess());&#010;-        reason = result.summaryErrorMessage(false);&#010;-        LOG.info(reason);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void validateTimePattern() throws Exception {&#010;-        assertTrue(catalog.validateTimePattern(""0""));&#010;-        assertTrue(catalog.validateTimePattern(""500""));&#010;-        assertTrue(catalog.validateTimePattern(""10000""));&#010;-        assertTrue(catalog.validateTimePattern(""5s""));&#010;-        assertTrue(catalog.validateTimePattern(""5sec""));&#010;-        assertTrue(catalog.validateTimePattern(""5secs""));&#010;-        assertTrue(catalog.validateTimePattern(""3m""));&#010;-        assertTrue(catalog.validateTimePattern(""3min""));&#010;-        assertTrue(catalog.validateTimePattern(""3minutes""));&#010;-        assertTrue(catalog.validateTimePattern(""5m15s""));&#010;-        assertTrue(catalog.validateTimePattern(""1h""));&#010;-        assertTrue(catalog.validateTimePattern(""1hour""));&#010;-        assertTrue(catalog.validateTimePattern(""2hours""));&#010;-&#010;-        assertFalse(catalog.validateTimePattern(""bla""));&#010;-        assertFalse(catalog.validateTimePattern(""2year""));&#010;-        assertFalse(catalog.validateTimePattern(""60darn""));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testEndpointComponentName() throws Exception {&#010;-        String name = catalog.endpointComponentName(""jms:queue:foo"");&#010;-        assertEquals(""jms"", name);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testSimpleExpression() throws Exception {&#010;-        SimpleValidationResult result = catalog.validateSimpleExpression(null, ""${body}"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body}"", result.getSimple());&#010;-&#010;-        result = catalog.validateSimpleExpression(null, ""${body"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""${body"", result.getSimple());&#010;-        LOG.info(result.getError());&#010;-        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol at location 5""));&#010;-        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;-        assertEquals(5, result.getIndex());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testSimplePredicate() throws Exception {&#010;-        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} == 'abc'"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body} == 'abc'"", result.getSimple());&#010;-&#010;-        result = catalog.validateSimplePredicate(null, ""${body} &gt; ${header.size"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""${body} &gt; ${header.size"", result.getSimple());&#010;-        LOG.info(result.getError());&#010;-        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol at location 22""));&#010;-        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;-        assertEquals(22, result.getIndex());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testSimplePredicatePlaceholder() throws Exception {&#010;-        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} contains '{{danger}}'"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body} contains '{{danger}}'"", result.getSimple());&#010;-&#010;-        result = catalog.validateSimplePredicate(null, ""${bdy} contains '{{danger}}'"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""${bdy} contains '{{danger}}'"", result.getSimple());&#010;-        LOG.info(result.getError());&#010;-        assertTrue(result.getError().startsWith(""Unknown function: bdy at location 0""));&#010;-        assertTrue(result.getError().contains(""'{{danger}}'""));&#010;-        assertEquals(""Unknown function: bdy"", result.getShortError());&#010;-        assertEquals(0, result.getIndex());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testValidateLanguage() throws Exception {&#010;-        LanguageValidationResult result = catalog.validateLanguageExpression(null, ""simple"", ""${body}"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body}"", result.getText());&#010;-&#010;-        result = catalog.validateLanguageExpression(null, ""header"", ""foo"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""foo"", result.getText());&#010;-&#010;-        result = catalog.validateLanguagePredicate(null, ""simple"", ""${body} &gt; 10"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body} &gt; 10"", result.getText());&#010;-&#010;-        result = catalog.validateLanguagePredicate(null, ""header"", ""bar"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""bar"", result.getText());&#010;-&#010;-        result = catalog.validateLanguagePredicate(null, ""foobar"", ""bar"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""Unknown language foobar"", result.getError());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testValidateEndpointConsumerOnly() throws Exception {&#010;-        String uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true"";&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false, true, false);&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true&amp;fileExist=Append"";&#010;-        result = catalog.validateEndpointProperties(uri, false, true, false);&#010;-        assertFalse(result.isSuccess());&#010;-&#010;-        assertEquals(""fileExist"", result.getNotConsumerOnly().iterator().next());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testValidateEndpointProducerOnly() throws Exception {&#010;-        String uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append"";&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false, false, true);&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append&amp;delete=true"";&#010;-        result = catalog.validateEndpointProperties(uri, false, false, true);&#010;-        assertFalse(result.isSuccess());&#010;-&#010;-        assertEquals(""delete"", result.getNotProducerOnly().iterator().next());&#010;-    }&#010;-&#010;-}&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C392ff0b6a5e9466c9cdb499eabbaf550%40git.apache.org%3E,2017-04-14 10:52,commits,4.0,324.0,  [3/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
14,325.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java&#010;new file mode 100644&#010;index 0000000..0420708&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java&#010;@@ -0,0 +1,1294 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.lang.reflect.InvocationTargetException;&#010;+import java.lang.reflect.Method;&#010;+import java.net.URI;&#010;+import java.net.URISyntaxException;&#010;+import java.util.ArrayList;&#010;+import java.util.Arrays;&#010;+import java.util.HashMap;&#010;+import java.util.Iterator;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.LinkedHashSet;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+import java.util.Objects;&#010;+import java.util.Set;&#010;+import java.util.TreeMap;&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+import static org.apache.camel.runtimecatalog.CatalogHelper.after;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getNames;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyDefaultValue;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyEnum;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyKind;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyNameFromNameWithPrefix;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyPrefix;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getRow;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isComponentConsumerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isComponentLenientProperties;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isComponentProducerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyBoolean;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyConsumerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyInteger;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyMultiValue;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyNumber;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyObject;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyProducerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyRequired;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.stripOptionalPrefixFromName;&#010;+import static org.apache.camel.runtimecatalog.URISupport.createQueryString;&#010;+import static org.apache.camel.runtimecatalog.URISupport.isEmpty;&#010;+import static org.apache.camel.runtimecatalog.URISupport.normalizeUri;&#010;+import static org.apache.camel.runtimecatalog.URISupport.stripQuery;&#010;+&#010;+/**&#010;+ * Base class for both the runtime RuntimeCamelCatalog from camel-core and the complete CamelCatalog from camel-catalog.&#010;+ */&#010;+public abstract class AbstractCamelCatalog {&#010;+&#010;+    // CHECKSTYLE:OFF&#010;+&#010;+    private static final Pattern SYNTAX_PATTERN = Pattern.compile(""(\\w+)"");&#010;+&#010;+    private SuggestionStrategy suggestionStrategy;&#010;+    private JSonSchemaResolver jsonSchemaResolver;&#010;+&#010;+    public SuggestionStrategy getSuggestionStrategy() {&#010;+        return suggestionStrategy;&#010;+    }&#010;+&#010;+    public void setSuggestionStrategy(SuggestionStrategy suggestionStrategy) {&#010;+        this.suggestionStrategy = suggestionStrategy;&#010;+    }&#010;+&#010;+    public JSonSchemaResolver getJSonSchemaResolver() {&#010;+        return jsonSchemaResolver;&#010;+    }&#010;+&#010;+    public void setJSonSchemaResolver(JSonSchemaResolver resolver) {&#010;+        this.jsonSchemaResolver = resolver;&#010;+    }&#010;+&#010;+    public boolean validateTimePattern(String pattern) {&#010;+        return validateInteger(pattern);&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateEndpointProperties(String uri) {&#010;+        return validateEndpointProperties(uri, false, false, false);&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties) {&#010;+        return validateEndpointProperties(uri, ignoreLenientProperties, false, false);&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateProperties(String scheme, Map&lt;String, String&gt; properties) {&#010;+        EndpointValidationResult result = new EndpointValidationResult(scheme);&#010;+&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+        List&lt;Map&lt;String, String&gt;&gt; componentProps = JSonSchemaHelper.parseJsonSchema(""componentProperties"", json, true);&#010;+&#010;+        // endpoint options have higher priority so remove those from component&#010;+        // that may clash&#010;+        componentProps.stream()&#010;+            .filter(c -&gt; rows.stream().noneMatch(e -&gt; Objects.equals(e.get(""name""), c.get(""name""))))&#010;+            .forEach(rows::add);&#010;+&#010;+        boolean lenient = Boolean.getBoolean(properties.getOrDefault(""lenient"", ""false""));&#010;+&#010;+        // the dataformat component refers to a data format so lets add the properties for the selected&#010;+        // data format to the list of rows&#010;+        if (""dataformat"".equals(scheme)) {&#010;+            String dfName = properties.get(""name"");&#010;+            if (dfName != null) {&#010;+                String dfJson = jsonSchemaResolver.getDataFormatJSonSchema(dfName);&#010;+                List&lt;Map&lt;String, String&gt;&gt; dfRows = JSonSchemaHelper.parseJsonSchema(""properties"", dfJson, true);&#010;+                if (dfRows != null &amp;&amp; !dfRows.isEmpty()) {&#010;+                    rows.addAll(dfRows);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        for (Map.Entry&lt;String, String&gt; property : properties.entrySet()) {&#010;+            String value = property.getValue();&#010;+            String originalName = property.getKey();&#010;+            String name = property.getKey();&#010;+            // the name may be using an optional prefix, so lets strip that because the options&#010;+            // in the schema are listed without the prefix&#010;+            name = stripOptionalPrefixFromName(rows, name);&#010;+            // the name may be using a prefix, so lets see if we can find the real property name&#010;+            String propertyName = getPropertyNameFromNameWithPrefix(rows, name);&#010;+            if (propertyName != null) {&#010;+                name = propertyName;&#010;+            }&#010;+&#010;+            String prefix = getPropertyPrefix(rows, name);&#010;+            String kind = getPropertyKind(rows, name);&#010;+            boolean namePlaceholder = name.startsWith(""{{"") &amp;&amp; name.endsWith(""}}"");&#010;+            boolean valuePlaceholder = value.startsWith(""{{"") || value.startsWith(""${"") || value.startsWith(""$simple{"");&#010;+            boolean lookup = value.startsWith(""#"") &amp;&amp; value.length() &gt; 1;&#010;+            // we cannot evaluate multi values as strict as the others, as we don't know their expected types&#010;+            boolean multiValue = prefix != null &amp;&amp; originalName.startsWith(prefix) &amp;&amp; isPropertyMultiValue(rows, name);&#010;+&#010;+            Map&lt;String, String&gt; row = getRow(rows, name);&#010;+            if (row == null) {&#010;+                // unknown option&#010;+&#010;+                // only add as error if the component is not lenient properties, or not stub component&#010;+                // and the name is not a property placeholder for one or more values&#010;+                if (!namePlaceholder &amp;&amp; !""stub"".equals(scheme)) {&#010;+                    if (lenient) {&#010;+                        // as if we are lenient then the option is a dynamic extra option which we cannot validate&#010;+                        result.addLenient(name);&#010;+                    } else {&#010;+                        // its unknown&#010;+                        result.addUnknown(name);&#010;+                        if (suggestionStrategy != null) {&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(getNames(rows), name);&#010;+                            if (suggestions != null) {&#010;+                                result.addUnknownSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+                    }&#010;+                }&#010;+            } else {&#010;+                /* TODO: we may need to add something in the properties to know if they are related to a producer or consumer&#010;+                if (""parameter"".equals(kind)) {&#010;+                    // consumer only or producer only mode for parameters&#010;+                    if (consumerOnly) {&#010;+                        boolean producer = isPropertyProducerOnly(rows, name);&#010;+                        if (producer) {&#010;+                            // the option is only for producer so you cannot use it in consumer mode&#010;+                            result.addNotConsumerOnly(name);&#010;+                        }&#010;+                    } else if (producerOnly) {&#010;+                        boolean consumer = isPropertyConsumerOnly(rows, name);&#010;+                        if (consumer) {&#010;+                            // the option is only for consumer so you cannot use it in producer mode&#010;+                            result.addNotProducerOnly(name);&#010;+                        }&#010;+                    }&#010;+                }&#010;+                */&#010;+&#010;+                // default value&#010;+                String defaultValue = getPropertyDefaultValue(rows, name);&#010;+                if (defaultValue != null) {&#010;+                    result.addDefaultValue(name, defaultValue);&#010;+                }&#010;+&#010;+                // is required but the value is empty&#010;+                boolean required = isPropertyRequired(rows, name);&#010;+                if (required &amp;&amp; isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+&#010;+                // is enum but the value is not within the enum range&#010;+                // but we can only check if the value is not a placeholder&#010;+                String enums = getPropertyEnum(rows, name);&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; enums != null) {&#010;+                    String[] choices = enums.split("","");&#010;+                    boolean found = false;&#010;+                    for (String s : choices) {&#010;+                        if (value.equalsIgnoreCase(s)) {&#010;+                            found = true;&#010;+                            break;&#010;+                        }&#010;+                    }&#010;+                    if (!found) {&#010;+                        result.addInvalidEnum(name, value);&#010;+                        result.addInvalidEnumChoices(name, choices);&#010;+                        if (suggestionStrategy != null) {&#010;+                            Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;();&#010;+                            names.addAll(Arrays.asList(choices));&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(names, value);&#010;+                            if (suggestions != null) {&#010;+                                result.addInvalidEnumSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+&#010;+                    }&#010;+                }&#010;+&#010;+                // is reference lookup of bean (not applicable for @UriPath, enums, or multi-valued)&#010;+                if (!multiValue &amp;&amp; enums == null &amp;&amp; !""path"".equals(kind) &amp;&amp; isPropertyObject(rows, name)) {&#010;+                    // must start with # and be at least 2 characters&#010;+                    if (!value.startsWith(""#"") || value.length() &lt;= 1) {&#010;+                        result.addInvalidReference(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is boolean&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyBoolean(rows, name)) {&#010;+                    // value must be a boolean&#010;+                    boolean bool = ""true"".equalsIgnoreCase(value) || ""false"".equalsIgnoreCase(value);&#010;+                    if (!bool) {&#010;+                        result.addInvalidBoolean(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is integer&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyInteger(rows, name)) {&#010;+                    // value must be an integer&#010;+                    boolean valid = validateInteger(value);&#010;+                    if (!valid) {&#010;+                        result.addInvalidInteger(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is number&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyNumber(rows, name)) {&#010;+                    // value must be an number&#010;+                    boolean valid = false;&#010;+                    try {&#010;+                        valid = !Double.valueOf(value).isNaN() || !Float.valueOf(value).isNaN();&#010;+                    } catch (Exception e) {&#010;+                        // ignore&#010;+                    }&#010;+                    if (!valid) {&#010;+                        result.addInvalidNumber(name, value);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // now check if all required values are there, and that a default value does not exists&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String name = row.get(""name"");&#010;+            boolean required = isPropertyRequired(rows, name);&#010;+            if (required) {&#010;+                String value = properties.get(name);&#010;+                if (isEmpty(value)) {&#010;+                    value = getPropertyDefaultValue(rows, name);&#010;+                }&#010;+                if (isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        return result;&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties, boolean consumerOnly, boolean producerOnly) {&#010;+        EndpointValidationResult result = new EndpointValidationResult(uri);&#010;+&#010;+        Map&lt;String, String&gt; properties;&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows;&#010;+        boolean lenientProperties;&#010;+        String scheme;&#010;+&#010;+        try {&#010;+            String json = null;&#010;+&#010;+            // parse the uri&#010;+            URI u = normalizeUri(uri);&#010;+            scheme = u.getScheme();&#010;+&#010;+            if (scheme != null) {&#010;+                json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+            }&#010;+            if (json == null) {&#010;+                // if the uri starts with a placeholder then we are also incapable of parsing it as we wasn't able to resolve the component name&#010;+                if (uri.startsWith(""{{"")) {&#010;+                    result.addIncapable(uri);&#010;+                } else if (scheme != null) {&#010;+                    result.addUnknownComponent(scheme);&#010;+                } else {&#010;+                    result.addUnknownComponent(uri);&#010;+                }&#010;+                return result;&#010;+            }&#010;+&#010;+            rows = JSonSchemaHelper.parseJsonSchema(""component"", json, false);&#010;+&#010;+            // is the component capable of both consumer and producer?&#010;+            boolean canConsumeAndProduce = false;&#010;+            if (!isComponentConsumerOnly(rows) &amp;&amp; !isComponentProducerOnly(rows)) {&#010;+                canConsumeAndProduce = true;&#010;+            }&#010;+&#010;+            if (canConsumeAndProduce &amp;&amp; consumerOnly) {&#010;+                // lenient properties is not support in consumer only mode if the component can do both of them&#010;+                lenientProperties = false;&#010;+            } else {&#010;+                // only enable lenient properties if we should not ignore&#010;+                lenientProperties = !ignoreLenientProperties &amp;&amp; isComponentLenientProperties(rows);&#010;+            }&#010;+            rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+            properties = endpointProperties(uri);&#010;+        } catch (URISyntaxException e) {&#010;+            if (uri.startsWith(""{{"")) {&#010;+                // if the uri starts with a placeholder then we are also incapable of parsing it as we wasn't able to resolve the component name&#010;+                result.addIncapable(uri);&#010;+            } else {&#010;+                result.addSyntaxError(e.getMessage());&#010;+            }&#010;+&#010;+            return result;&#010;+        }&#010;+&#010;+        // the dataformat component refers to a data format so lets add the properties for the selected&#010;+        // data format to the list of rows&#010;+        if (""dataformat"".equals(scheme)) {&#010;+            String dfName = properties.get(""name"");&#010;+            if (dfName != null) {&#010;+                String dfJson = jsonSchemaResolver.getDataFormatJSonSchema(dfName);&#010;+                List&lt;Map&lt;String, String&gt;&gt; dfRows = JSonSchemaHelper.parseJsonSchema(""properties"", dfJson, true);&#010;+                if (dfRows != null &amp;&amp; !dfRows.isEmpty()) {&#010;+                    rows.addAll(dfRows);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        for (Map.Entry&lt;String, String&gt; property : properties.entrySet()) {&#010;+            String value = property.getValue();&#010;+            String originalName = property.getKey();&#010;+            String name = property.getKey();&#010;+            // the name may be using an optional prefix, so lets strip that because the options&#010;+            // in the schema are listed without the prefix&#010;+            name = stripOptionalPrefixFromName(rows, name);&#010;+            // the name may be using a prefix, so lets see if we can find the real property name&#010;+            String propertyName = getPropertyNameFromNameWithPrefix(rows, name);&#010;+            if (propertyName != null) {&#010;+                name = propertyName;&#010;+            }&#010;+&#010;+            String prefix = getPropertyPrefix(rows, name);&#010;+            String kind = getPropertyKind(rows, name);&#010;+            boolean namePlaceholder = name.startsWith(""{{"") &amp;&amp; name.endsWith(""}}"");&#010;+            boolean valuePlaceholder = value.startsWith(""{{"") || value.startsWith(""${"") || value.startsWith(""$simple{"");&#010;+            boolean lookup = value.startsWith(""#"") &amp;&amp; value.length() &gt; 1;&#010;+            // we cannot evaluate multi values as strict as the others, as we don't know their expected types&#010;+            boolean mulitValue = prefix != null &amp;&amp; originalName.startsWith(prefix) &amp;&amp; isPropertyMultiValue(rows, name);&#010;+&#010;+            Map&lt;String, String&gt; row = getRow(rows, name);&#010;+            if (row == null) {&#010;+                // unknown option&#010;+&#010;+                // only add as error if the component is not lenient properties, or not stub component&#010;+                // and the name is not a property placeholder for one or more values&#010;+                if (!namePlaceholder &amp;&amp; !""stub"".equals(scheme)) {&#010;+                    if (lenientProperties) {&#010;+                        // as if we are lenient then the option is a dynamic extra option which we cannot validate&#010;+                        result.addLenient(name);&#010;+                    } else {&#010;+                        // its unknown&#010;+                        result.addUnknown(name);&#010;+                        if (suggestionStrategy != null) {&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(getNames(rows), name);&#010;+                            if (suggestions != null) {&#010;+                                result.addUnknownSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+                    }&#010;+                }&#010;+            } else {&#010;+                if (""parameter"".equals(kind)) {&#010;+                    // consumer only or producer only mode for parameters&#010;+                    if (consumerOnly) {&#010;+                        boolean producer = isPropertyProducerOnly(rows, name);&#010;+                        if (producer) {&#010;+                            // the option is only for producer so you cannot use it in consumer mode&#010;+                            result.addNotConsumerOnly(name);&#010;+                        }&#010;+                    } else if (producerOnly) {&#010;+                        boolean consumer = isPropertyConsumerOnly(rows, name);&#010;+                        if (consumer) {&#010;+                            // the option is only for consumer so you cannot use it in producer mode&#010;+                            result.addNotProducerOnly(name);&#010;+                        }&#010;+                    }&#010;+                }&#010;+&#010;+                // default value&#010;+                String defaultValue = getPropertyDefaultValue(rows, name);&#010;+                if (defaultValue != null) {&#010;+                    result.addDefaultValue(name, defaultValue);&#010;+                }&#010;+&#010;+                // is required but the value is empty&#010;+                boolean required = isPropertyRequired(rows, name);&#010;+                if (required &amp;&amp; isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+&#010;+                // is enum but the value is not within the enum range&#010;+                // but we can only check if the value is not a placeholder&#010;+                String enums = getPropertyEnum(rows, name);&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; enums != null) {&#010;+                    String[] choices = enums.split("","");&#010;+                    boolean found = false;&#010;+                    for (String s : choices) {&#010;+                        if (value.equalsIgnoreCase(s)) {&#010;+                            found = true;&#010;+                            break;&#010;+                        }&#010;+                    }&#010;+                    if (!found) {&#010;+                        result.addInvalidEnum(name, value);&#010;+                        result.addInvalidEnumChoices(name, choices);&#010;+                        if (suggestionStrategy != null) {&#010;+                            Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;();&#010;+                            names.addAll(Arrays.asList(choices));&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(names, value);&#010;+                            if (suggestions != null) {&#010;+                                result.addInvalidEnumSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+&#010;+                    }&#010;+                }&#010;+&#010;+                // is reference lookup of bean (not applicable for @UriPath, enums, or multi-valued)&#010;+                if (!mulitValue &amp;&amp; enums == null &amp;&amp; !""path"".equals(kind) &amp;&amp; isPropertyObject(rows, name)) {&#010;+                    // must start with # and be at least 2 characters&#010;+                    if (!value.startsWith(""#"") || value.length() &lt;= 1) {&#010;+                        result.addInvalidReference(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is boolean&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyBoolean(rows, name)) {&#010;+                    // value must be a boolean&#010;+                    boolean bool = ""true"".equalsIgnoreCase(value) || ""false"".equalsIgnoreCase(value);&#010;+                    if (!bool) {&#010;+                        result.addInvalidBoolean(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is integer&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyInteger(rows, name)) {&#010;+                    // value must be an integer&#010;+                    boolean valid = validateInteger(value);&#010;+                    if (!valid) {&#010;+                        result.addInvalidInteger(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is number&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyNumber(rows, name)) {&#010;+                    // value must be an number&#010;+                    boolean valid = false;&#010;+                    try {&#010;+                        valid = !Double.valueOf(value).isNaN() || !Float.valueOf(value).isNaN();&#010;+                    } catch (Exception e) {&#010;+                        // ignore&#010;+                    }&#010;+                    if (!valid) {&#010;+                        result.addInvalidNumber(name, value);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // now check if all required values are there, and that a default value does not exists&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String name = row.get(""name"");&#010;+            boolean required = isPropertyRequired(rows, name);&#010;+            if (required) {&#010;+                String value = properties.get(name);&#010;+                if (isEmpty(value)) {&#010;+                    value = getPropertyDefaultValue(rows, name);&#010;+                }&#010;+                if (isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        return result;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; endpointProperties(String uri) throws URISyntaxException {&#010;+        // need to normalize uri first&#010;+        URI u = normalizeUri(uri);&#010;+        String scheme = u.getScheme();&#010;+&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        if (json == null) {&#010;+            throw new IllegalArgumentException(""Cannot find endpoint with scheme "" + scheme);&#010;+        }&#010;+&#010;+        // grab the syntax&#010;+        String syntax = null;&#010;+        String alternativeSyntax = null;&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""component"", json, false);&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""syntax"")) {&#010;+                syntax = row.get(""syntax"");&#010;+            }&#010;+            if (row.containsKey(""alternativeSyntax"")) {&#010;+                alternativeSyntax = row.get(""alternativeSyntax"");&#010;+            }&#010;+        }&#010;+        if (syntax == null) {&#010;+            throw new IllegalArgumentException(""Endpoint with scheme "" + scheme + "" has no syntax defined in the json schema"");&#010;+        }&#010;+&#010;+        // only if we support alternative syntax, and the uri contains the username and password in the authority&#010;+        // part of the uri, then we would need some special logic to capture that information and strip those&#010;+        // details from the uri, so we can continue parsing the uri using the normal syntax&#010;+        Map&lt;String, String&gt; userInfoOptions = new LinkedHashMap&lt;String, String&gt;();&#010;+        if (alternativeSyntax != null &amp;&amp; alternativeSyntax.contains(""@"")) {&#010;+            // clip the scheme from the syntax&#010;+            alternativeSyntax = after(alternativeSyntax, "":"");&#010;+            // trim so only userinfo&#010;+            int idx = alternativeSyntax.indexOf(""@"");&#010;+            String fields = alternativeSyntax.substring(0, idx);&#010;+            String[] names = fields.split("":"");&#010;+&#010;+            // grab authority part and grab username and/or password&#010;+            String authority = u.getAuthority();&#010;+            if (authority != null &amp;&amp; authority.contains(""@"")) {&#010;+                String username = null;&#010;+                String password = null;&#010;+&#010;+                // grab unserinfo part before @&#010;+                String userInfo = authority.substring(0, authority.indexOf(""@""));&#010;+                String[] parts = userInfo.split("":"");&#010;+                if (parts.length == 2) {&#010;+                    username = parts[0];&#010;+                    password = parts[1];&#010;+                } else {&#010;+                    // only username&#010;+                    username = userInfo;&#010;+                }&#010;+&#010;+                // remember the username and/or password which we add later to the options&#010;+                if (names.length == 2) {&#010;+                    userInfoOptions.put(names[0], username);&#010;+                    if (password != null) {&#010;+                        // password is optional&#010;+                        userInfoOptions.put(names[1], password);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // clip the scheme from the syntax&#010;+        syntax = after(syntax, "":"");&#010;+        // clip the scheme from the uri&#010;+        uri = after(uri, "":"");&#010;+        String uriPath = stripQuery(uri);&#010;+&#010;+        // strip user info from uri path&#010;+        if (!userInfoOptions.isEmpty()) {&#010;+            int idx = uriPath.indexOf('@');&#010;+            if (idx &gt; -1) {&#010;+                uriPath = uriPath.substring(idx + 1);&#010;+            }&#010;+        }&#010;+&#010;+        // strip double slash in the start&#010;+        if (uriPath != null &amp;&amp; uriPath.startsWith(""//"")) {&#010;+            uriPath = uriPath.substring(2);&#010;+        }&#010;+&#010;+        // parse the syntax and find the names of each option&#010;+        Matcher matcher = SYNTAX_PATTERN.matcher(syntax);&#010;+        List&lt;String&gt; word = new ArrayList&lt;String&gt;();&#010;+        while (matcher.find()) {&#010;+            String s = matcher.group(1);&#010;+            if (!scheme.equals(s)) {&#010;+                word.add(s);&#010;+            }&#010;+        }&#010;+        // parse the syntax and find each token between each option&#010;+        String[] tokens = SYNTAX_PATTERN.split(syntax);&#010;+&#010;+        // find the position where each option start/end&#010;+        List&lt;String&gt; word2 = new ArrayList&lt;String&gt;();&#010;+        int prev = 0;&#010;+        int prevPath = 0;&#010;+&#010;+        // special for activemq/jms where the enum for destinationType causes a token issue as it includes a colon&#010;+        // for 'temp:queue' and 'temp:topic' values&#010;+        if (""activemq"".equals(scheme) || ""jms"".equals(scheme)) {&#010;+            if (uriPath.startsWith(""temp:"")) {&#010;+                prevPath = 5;&#010;+            }&#010;+        }&#010;+&#010;+        for (String token : tokens) {&#010;+            if (token.isEmpty()) {&#010;+                continue;&#010;+            }&#010;+&#010;+            // special for some tokens where :// can be used also, eg http://foo&#010;+            int idx = -1;&#010;+            int len = 0;&#010;+            if ("":"".equals(token)) {&#010;+                idx = uriPath.indexOf(""://"", prevPath);&#010;+                len = 3;&#010;+            }&#010;+            if (idx == -1) {&#010;+                idx = uriPath.indexOf(token, prevPath);&#010;+                len = token.length();&#010;+            }&#010;+&#010;+            if (idx &gt; 0) {&#010;+                String option = uriPath.substring(prev, idx);&#010;+                word2.add(option);&#010;+                prev = idx + len;&#010;+                prevPath = prev;&#010;+            }&#010;+        }&#010;+        // special for last or if we did not add anyone&#010;+        if (prev &gt; 0 || word2.isEmpty()) {&#010;+            String option = uriPath.substring(prev);&#010;+            word2.add(option);&#010;+        }&#010;+&#010;+        rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        boolean defaultValueAdded = false;&#010;+&#010;+        // now parse the uri to know which part isw what&#010;+        Map&lt;String, String&gt; options = new LinkedHashMap&lt;String, String&gt;();&#010;+&#010;+        // include the username and password from the userinfo section&#010;+        if (!userInfoOptions.isEmpty()) {&#010;+            options.putAll(userInfoOptions);&#010;+        }&#010;+&#010;+        // word contains the syntax path elements&#010;+        Iterator&lt;String&gt; it = word2.iterator();&#010;+        for (int i = 0; i &lt; word.size(); i++) {&#010;+            String key = word.get(i);&#010;+&#010;+            boolean allOptions = word.size() == word2.size();&#010;+            boolean required = isPropertyRequired(rows, key);&#010;+            String defaultValue = getPropertyDefaultValue(rows, key);&#010;+&#010;+            // we have all options so no problem&#010;+            if (allOptions) {&#010;+                String value = it.next();&#010;+                options.put(key, value);&#010;+            } else {&#010;+                // we have a little problem as we do not not have all options&#010;+                if (!required) {&#010;+                    String value = null;&#010;+&#010;+                    boolean last = i == word.size() - 1;&#010;+                    if (last) {&#010;+                        // if its the last value then use it instead of the default value&#010;+                        value = it.hasNext() ? it.next() : null;&#010;+                        if (value != null) {&#010;+                            options.put(key, value);&#010;+                        } else {&#010;+                            value = defaultValue;&#010;+                        }&#010;+                    }&#010;+                    if (value != null) {&#010;+                        options.put(key, value);&#010;+                        defaultValueAdded = true;&#010;+                    }&#010;+                } else {&#010;+                    String value = it.hasNext() ? it.next() : null;&#010;+                    if (value != null) {&#010;+                        options.put(key, value);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        Map&lt;String, String&gt; answer = new LinkedHashMap&lt;String, String&gt;();&#010;+&#010;+        // remove all options which are using default values and are not required&#010;+        for (Map.Entry&lt;String, String&gt; entry : options.entrySet()) {&#010;+            String key = entry.getKey();&#010;+            String value = entry.getValue();&#010;+&#010;+            if (defaultValueAdded) {&#010;+                boolean required = isPropertyRequired(rows, key);&#010;+                String defaultValue = getPropertyDefaultValue(rows, key);&#010;+&#010;+                if (!required &amp;&amp; defaultValue != null) {&#010;+                    if (defaultValue.equals(value)) {&#010;+                        continue;&#010;+                    }&#010;+                }&#010;+            }&#010;+&#010;+            // we should keep this in the answer&#010;+            answer.put(key, value);&#010;+        }&#010;+&#010;+        // now parse the uri parameters&#010;+        Map&lt;String, Object&gt; parameters = URISupport.parseParameters(u);&#010;+&#010;+        // and covert the values to String so its JMX friendly&#010;+        while (!parameters.isEmpty()) {&#010;+            Map.Entry&lt;String, Object&gt; entry = parameters.entrySet().iterator().next();&#010;+            String key = entry.getKey();&#010;+            String value = entry.getValue() != null ? entry.getValue().toString() : """";&#010;+&#010;+            boolean multiValued = isPropertyMultiValue(rows, key);&#010;+            if (multiValued) {&#010;+                String prefix = getPropertyPrefix(rows, key);&#010;+                // extra all the multi valued options&#010;+                Map&lt;String, Object&gt; values = URISupport.extractProperties(parameters, prefix);&#010;+                // build a string with the extra multi valued options with the prefix and &amp; as separator&#010;+                CollectionStringBuffer csb = new CollectionStringBuffer(""&amp;"");&#010;+                for (Map.Entry&lt;String, Object&gt; multi : values.entrySet()) {&#010;+                    String line = prefix + multi.getKey() + ""="" + (multi.getValue() != null ? multi.getValue().toString() : """");&#010;+                    csb.append(line);&#010;+                }&#010;+                // append the extra multi-values to the existing (which contains the first multi value)&#010;+                if (!csb.isEmpty()) {&#010;+                    value = value + ""&amp;"" + csb.toString();&#010;+                }&#010;+            }&#010;+&#010;+            answer.put(key, value);&#010;+            // remove the parameter as we run in a while loop until no more parameters&#010;+            parameters.remove(key);&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; endpointLenientProperties(String uri) throws URISyntaxException {&#010;+        // need to normalize uri first&#010;+&#010;+        // parse the uri&#010;+        URI u = normalizeUri(uri);&#010;+        String scheme = u.getScheme();&#010;+&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        if (json == null) {&#010;+            throw new IllegalArgumentException(""Cannot find endpoint with scheme "" + scheme);&#010;+        }&#010;+&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        // now parse the uri parameters&#010;+        Map&lt;String, Object&gt; parameters = URISupport.parseParameters(u);&#010;+&#010;+        // all the known options&#010;+        Set&lt;String&gt; names = getNames(rows);&#010;+&#010;+        Map&lt;String, String&gt; answer = new LinkedHashMap&lt;&gt;();&#010;+&#010;+        // and covert the values to String so its JMX friendly&#010;+        parameters.forEach((k, v) -&gt; {&#010;+            String key = k;&#010;+            String value = v != null ? v.toString() : """";&#010;+&#010;+            // is the key a prefix property&#010;+            int dot = key.indexOf('.');&#010;+            if (dot != -1) {&#010;+                String prefix = key.substring(0, dot + 1); // include dot in prefix&#010;+                String option = getPropertyNameFromNameWithPrefix(rows, prefix);&#010;+                if (option == null || !isPropertyMultiValue(rows, option)) {&#010;+                    answer.put(key, value);&#010;+                }&#010;+            } else if (!names.contains(key)) {&#010;+                answer.put(key, value);&#010;+            }&#010;+        });&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    public String endpointComponentName(String uri) {&#010;+        if (uri != null) {&#010;+            int idx = uri.indexOf("":"");&#010;+            if (idx &gt; 0) {&#010;+                return uri.substring(0, idx);&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public String asEndpointUri(String scheme, String json, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, json, ""&amp;"", encode);&#010;+    }&#010;+&#010;+    public String asEndpointUriXml(String scheme, String json, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, json, ""&amp;amp;"", encode);&#010;+    }&#010;+&#010;+    private String doAsEndpointUri(String scheme, String json, String ampersand, boolean encode) throws URISyntaxException {&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        Map&lt;String, String&gt; copy = new HashMap&lt;String, String&gt;();&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String name = row.get(""name"");&#010;+            String required = row.get(""required"");&#010;+            String value = row.get(""value"");&#010;+            String defaultValue = row.get(""defaultValue"");&#010;+&#010;+            // only add if either required, or the value is != default value&#010;+            String valueToAdd = null;&#010;+            if (""true"".equals(required)) {&#010;+                valueToAdd = value != null ? value : defaultValue;&#010;+                if (valueToAdd == null) {&#010;+                    valueToAdd = """";&#010;+                }&#010;+            } else {&#010;+                // if we have a value and no default then add it&#010;+                if (value != null &amp;&amp; defaultValue == null) {&#010;+                    valueToAdd = value;&#010;+                }&#010;+                // otherwise only add if the value is != default value&#010;+                if (value != null &amp;&amp; defaultValue != null &amp;&amp; !value.equals(defaultValue)) {&#010;+                    valueToAdd = value;&#010;+                }&#010;+            }&#010;+&#010;+            if (valueToAdd != null) {&#010;+                copy.put(name, valueToAdd);&#010;+            }&#010;+        }&#010;+&#010;+        return doAsEndpointUri(scheme, copy, ampersand, encode);&#010;+    }&#010;+&#010;+    public String asEndpointUri(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, properties, ""&amp;"", encode);&#010;+    }&#010;+&#010;+    public String asEndpointUriXml(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, properties, ""&amp;amp;"", encode);&#010;+    }&#010;+&#010;+    String doAsEndpointUri(String scheme, Map&lt;String, String&gt; properties, String ampersand, boolean encode) throws URISyntaxException {&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        if (json == null) {&#010;+            throw new IllegalArgumentException(""Cannot find endpoint with scheme "" + scheme);&#010;+        }&#010;+&#010;+        // grab the syntax&#010;+        String syntax = null;&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""component"", json, false);&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""syntax"")) {&#010;+                syntax = row.get(""syntax"");&#010;+                break;&#010;+            }&#010;+        }&#010;+        if (syntax == null) {&#010;+            throw new IllegalArgumentException(""Endpoint with scheme "" + scheme + "" has no syntax defined in the json schema"");&#010;+        }&#010;+&#010;+        // do any properties filtering which can be needed for some special components&#010;+        properties = filterProperties(scheme, properties);&#010;+&#010;+        rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        // clip the scheme from the syntax&#010;+        syntax = after(syntax, "":"");&#010;+&#010;+        String originalSyntax = syntax;&#010;+&#010;+        // build at first according to syntax (use a tree map as we want the uri options sorted)&#010;+        Map&lt;String, String&gt; copy = new TreeMap&lt;String, String&gt;();&#010;+        for (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) {&#010;+            String key = entry.getKey();&#010;+            String value = entry.getValue() != null ? entry.getValue() : """";&#010;+            if (syntax != null &amp;&amp; syntax.contains(key)) {&#010;+                syntax = syntax.replace(key, value);&#010;+            } else {&#010;+                copy.put(key, value);&#010;+            }&#010;+        }&#010;+&#010;+        // do we have all the options the original syntax needs (easy way)&#010;+        String[] keys = syntaxKeys(originalSyntax);&#010;+        boolean hasAllKeys = properties.keySet().containsAll(Arrays.asList(keys));&#010;+&#010;+        // build endpoint uri&#010;+        StringBuilder sb = new StringBuilder();&#010;+        sb.append(scheme);&#010;+        sb.append("":"");&#010;+&#010;+        if (hasAllKeys) {&#010;+            // we have all the keys for the syntax so we can build the uri the easy way&#010;+            sb.append(syntax);&#010;+&#010;+            if (!copy.isEmpty()) {&#010;+                boolean hasQuestionmark = sb.toString().contains(""?"");&#010;+                // the last option may already contain a ? char, if so we should use &amp; instead of ?&#010;+                sb.append(hasQuestionmark ? ampersand : '?');&#010;+                String query = createQueryString(copy, ampersand, encode);&#010;+                sb.append(query);&#010;+            }&#010;+        } else {&#010;+            // TODO: revisit this and see if we can do this in another way&#010;+            // oh darn some options is missing, so we need a complex way of building the uri&#010;+&#010;+            // the tokens between the options in the path&#010;+            String[] tokens = syntax.split(""\\w+"");&#010;+&#010;+            // parse the syntax into each options&#010;+            Matcher matcher = SYNTAX_PATTERN.matcher(originalSyntax);&#010;+            List&lt;String&gt; options = new ArrayList&lt;String&gt;();&#010;+            while (matcher.find()) {&#010;+                String s = matcher.group(1);&#010;+                options.add(s);&#010;+            }&#010;+&#010;+            // need to preserve {{ and }} from the syntax&#010;+            // (we need to use words only as its provisional placeholders)&#010;+            syntax = syntax.replaceAll(""\\{\\{"", ""BEGINCAMELPLACEHOLDER"");&#010;+            syntax = syntax.replaceAll(""\\}\\}"", ""ENDCAMELPLACEHOLDER"");&#010;+&#010;+            // parse the syntax into each options&#010;+            Matcher matcher2 = SYNTAX_PATTERN.matcher(syntax);&#010;+            List&lt;String&gt; options2 = new ArrayList&lt;String&gt;();&#010;+            while (matcher2.find()) {&#010;+                String s = matcher2.group(1);&#010;+                s = s.replaceAll(""BEGINCAMELPLACEHOLDER"", ""\\{\\{"");&#010;+                s = s.replaceAll(""ENDCAMELPLACEHOLDER"", ""\\}\\}"");&#010;+                options2.add(s);&#010;+            }&#010;+&#010;+            // build the endpoint&#010;+            int range = 0;&#010;+            boolean first = true;&#010;+            boolean hasQuestionmark = false;&#010;+            for (int i = 0; i &lt; options.size(); i++) {&#010;+                String key = options.get(i);&#010;+                String key2 = options2.get(i);&#010;+                String token = null;&#010;+                if (tokens.length &gt; i) {&#010;+                    token = tokens[i];&#010;+                }&#010;+&#010;+                boolean contains = properties.containsKey(key);&#010;+                if (!contains) {&#010;+                    // if the key are similar we have no explicit value and can try to find a default value if the option is required&#010;+                    if (isPropertyRequired(rows, key)) {&#010;+                        String value = getPropertyDefaultValue(rows, key);&#010;+                        if (value != null) {&#010;+                            properties.put(key, value);&#010;+                            key2 = value;&#010;+                        }&#010;+                    }&#010;+                }&#010;+&#010;+                // was the option provided?&#010;+                if (properties.containsKey(key)) {&#010;+                    if (!first &amp;&amp; token != null) {&#010;+                        sb.append(token);&#010;+                    }&#010;+                    hasQuestionmark |= key.contains(""?"") || (token != null &amp;&amp; token.contains(""?""));&#010;+                    sb.append(key2);&#010;+                    first = false;&#010;+                }&#010;+                range++;&#010;+            }&#010;+            // append any extra options that was in surplus for the last&#010;+            while (range &lt; options2.size()) {&#010;+                String token = null;&#010;+                if (tokens.length &gt; range) {&#010;+                    token = tokens[range];&#010;+                }&#010;+                String key2 = options2.get(range);&#010;+                sb.append(token);&#010;+                sb.append(key2);&#010;+                hasQuestionmark |= key2.contains(""?"") || (token != null &amp;&amp; token.contains(""?""));&#010;+                range++;&#010;+            }&#010;+&#010;+&#010;+            if (!copy.isEmpty()) {&#010;+                // the last option may already contain a ? char, if so we should use &amp; instead of ?&#010;+                sb.append(hasQuestionmark ? ampersand : '?');&#010;+                String query = createQueryString(copy, ampersand, encode);&#010;+                sb.append(query);&#010;+            }&#010;+        }&#010;+&#010;+        return sb.toString();&#010;+    }&#010;+&#010;+    @Deprecated&#010;+    private static String[] syntaxTokens(String syntax) {&#010;+        // build tokens between the words&#010;+        List&lt;String&gt; tokens = new ArrayList&lt;&gt;();&#010;+        // preserve backwards behavior which had an empty token first&#010;+        tokens.add("""");&#010;+&#010;+        String current = """";&#010;+        for (int i = 0; i &lt; syntax.length(); i++) {&#010;+            char ch = syntax.charAt(i);&#010;+            if (Character.isLetterOrDigit(ch)) {&#010;+                // reset for new current tokens&#010;+                if (current.length() &gt; 0) {&#010;+                    tokens.add(current);&#010;+                    current = """";&#010;+                }&#010;+            } else {&#010;+                current += ch;&#010;+            }&#010;+        }&#010;+        // anything left over?&#010;+        if (current.length() &gt; 0) {&#010;+            tokens.add(current);&#010;+        }&#010;+&#010;+        return tokens.toArray(new String[tokens.size()]);&#010;+    }&#010;+&#010;+    private static String[] syntaxKeys(String syntax) {&#010;+        // build tokens between the separators&#010;+        List&lt;String&gt; tokens = new ArrayList&lt;&gt;();&#010;+&#010;+        String current = """";&#010;+        for (int i = 0; i &lt; syntax.length(); i++) {&#010;+            char ch = syntax.charAt(i);&#010;+            if (Character.isLetterOrDigit(ch)) {&#010;+                current += ch;&#010;+            } else {&#010;+                // reset for new current tokens&#010;+                if (current.length() &gt; 0) {&#010;+                    tokens.add(current);&#010;+                    current = """";&#010;+                }&#010;+            }&#010;+        }&#010;+        // anything left over?&#010;+        if (current.length() &gt; 0) {&#010;+            tokens.add(current);&#010;+        }&#010;+&#010;+        return tokens.toArray(new String[tokens.size()]);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimpleExpression(String simple) {&#010;+        return doValidateSimple(null, simple, false);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimpleExpression(ClassLoader classLoader, String simple) {&#010;+        return doValidateSimple(classLoader, simple, false);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimplePredicate(String simple) {&#010;+        return doValidateSimple(null, simple, true);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimplePredicate(ClassLoader classLoader, String simple) {&#010;+        return doValidateSimple(classLoader, simple, true);&#010;+    }&#010;+&#010;+    private SimpleValidationResult doValidateSimple(ClassLoader classLoader, String simple, boolean predicate) {&#010;+        if (classLoader == null) {&#010;+            classLoader = getClass().getClassLoader();&#010;+        }&#010;+&#010;+        // if there are {{ }}} property placeholders then we need to resolve them to something else&#010;+        // as the simple parse cannot resolve them before parsing as we dont run the actual Camel application&#010;+        // with property placeholders setup so we need to dummy this by replace the {{ }} to something else&#010;+        // therefore we use an more unlikely character: {{XXX}} to ~^XXX^~&#010;+        String resolved = simple.replaceAll(""\\{\\{(.+)\\}\\}"", ""~^$1^~"");&#010;+&#010;+        SimpleValidationResult answer = new SimpleValidationResult(simple);&#010;+&#010;+        Object instance = null;&#010;+        Class clazz = null;&#010;+        try {&#010;+            clazz = classLoader.loadClass(""org.apache.camel.language.simple.SimpleLanguage"");&#010;+            instance = clazz.newInstance();&#010;+        } catch (Exception e) {&#010;+            // ignore&#010;+        }&#010;+&#010;+        if (clazz != null &amp;&amp; instance != null) {&#010;+            Throwable cause = null;&#010;+            try {&#010;+                if (predicate) {&#010;+                    instance.getClass().getMethod(""createPredicate"", String.class).invoke(instance, resolved);&#010;+                } else {&#010;+                    instance.getClass().getMethod(""createExpression"", String.class).invoke(instance, resolved);&#010;+                }&#010;+            } catch (InvocationTargetException e) {&#010;+                cause = e.getTargetException();&#010;+            } catch (Exception e) {&#010;+                cause = e;&#010;+            }&#010;+&#010;+            if (cause != null) {&#010;+&#010;+                // reverse ~^XXX^~ back to {{XXX}}&#010;+                String errMsg = cause.getMessage();&#010;+                errMsg = errMsg.replaceAll(""\\~\\^(.+)\\^\\~"", ""{{$1}}"");&#010;+&#010;+                answer.setError(errMsg);&#010;+&#010;+                // is it simple parser exception then we can grab the index where the problem is&#010;+                if (cause.getClass().getName().equals(""org.apache.camel.language.simple.types.SimpleIllegalSyntaxException"")&#010;+                    || cause.getClass().getName().equals(""org.apache.camel.language.simple.types.SimpleParserException"")) {&#010;+                    try {&#010;+                        // we need to grab the index field from those simple parser exceptions&#010;+                        Method method = cause.getClass().getMethod(""getIndex"");&#010;+                        Object result = method.invoke(cause);&#010;+                        if (result != null) {&#010;+                            int index = (int) result;&#010;+                            answer.setIndex(index);&#010;+                        }&#010;+                    } catch (Throwable i) {&#010;+                        // ignore&#010;+                    }&#010;+                }&#010;+&#010;+                // we need to grab the short message field from this simple syntax exception&#010;+                if (cause.getClass().getName().equals(""org.apache.camel.language.simple.types.SimpleIllegalSyntaxException"")) {&#010;+                    try {&#010;+                        Method method = cause.getClass().getMethod(""getShortMessage"");&#010;+                        Object result = method.invoke(cause);&#010;+                        if (result != null) {&#010;+                            String msg = (String) result;&#010;+                            answer.setShortError(msg);&#010;+                        }&#010;+                    } catch (Throwable i) {&#010;+                        // ignore&#010;+                    }&#010;+&#010;+                    if (answer.getShortError() == null) {&#010;+                        // fallback and try to make existing message short instead&#010;+                        String msg = answer.getError();&#010;+                        // grab everything before "" at location "" which would be regarded as the short message&#010;+                        int idx = msg.indexOf("" at location "");&#010;+                        if (idx &gt; 0) {&#010;+                            msg = msg.substring(0, idx);&#010;+                            answer.setShortError(msg);&#010;+                        }&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    public LanguageValidationResult validateLanguagePredicate(ClassLoader classLoader, String language, String text) {&#010;+        return doValidateLanguage(classLoader, language, text, true);&#010;+    }&#010;+&#010;+    public LanguageValidationResult validateLanguageExpression(ClassLoader classLoader, String language, String text) {&#010;+        return doValidateLanguage(classLoader, language, text, false);&#010;+    }&#010;+&#010;+    private LanguageValidationResult doValidateLanguage(ClassLoader classLoader, String language, String text, boolean predicate) {&#010;+        if (classLoader == null) {&#010;+            classLoader = getClass().getClassLoader();&#010;+        }&#010;+&#010;+        SimpleValidationResult answer = new SimpleValidationResult(text);&#010;+&#010;+        String json = jsonSchemaResolver.getLanguageJSonSchema(language);&#010;+        if (json == null) {&#010;+            answer.setError(""Unknown language "" + language);&#010;+            return answer;&#010;+        }&#010;+&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""language"", json, false);&#010;+        String className = null;&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""javaType"")) {&#010;+                className = row.get(""javaType"");&#010;+            }&#010;+        }&#010;+&#010;+        if (className == null) {&#010;+            answer.setError(""Cannot find javaType for language "" + language);&#010;+            return answer;&#010;+        }&#010;+&#010;+        Object instance = null;&#010;+        Class clazz = null;&#010;+        try {&#010;+            clazz = classLoader.loadClass(className);&#010;+            instance = clazz.newInstance();&#010;+        } catch (Exception e) {&#010;+            // ignore&#010;+        }&#010;+&#010;+        if (clazz != null &amp;&amp; instance != null) {&#010;+            Throwable cause = null;&#010;+            try {&#010;+                if (predicate) {&#010;+                    instance.getClass().getMethod(""createPredicate"", String.class).invoke(instance, text);&#010;+                } else {&#010;+                    instance.getClass().getMethod(""createExpression"", String.class).invoke(instance, text);&#010;+                }&#010;+            } catch (InvocationTargetException e) {&#010;+                cause = e.getTargetException();&#010;+            } catch (Exception e) {&#010;+                cause = e;&#010;+            }&#010;+&#010;+            if (cause != null) {&#010;+                answer.setError(cause.getMessage());&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    /**&#010;+     * Special logic for log endpoints to deal when showAll=true&#010;+     */&#010;+    private Map&lt;String, String&gt; filterProperties(String scheme, Map&lt;String, String&gt; options) {&#010;+        if (""log"".equals(scheme)) {&#010;+            String showAll = options.get(""showAll"");&#010;+            if (""true"".equals(showAll)) {&#010;+                Map&lt;String, String&gt; filtered = new LinkedHashMap&lt;String, String&gt;();&#010;+                // remove all the other showXXX options when showAll=true&#010;+                for (Map.Entry&lt;String, String&gt; entry : options.entrySet()) {&#010;+                    String key = entry.getKey();&#010;+                    boolean skip = key.startsWith(""show"") &amp;&amp; !key.equals(""showAll"");&#010;+                    if (!skip) {&#010;+                        filtered.put(key, entry.getValue());&#010;+                    }&#010;+                }&#010;+                return filtered;&#010;+            }&#010;+        }&#010;+        // use as-is&#010;+        return options;&#010;+    }&#010;+&#010;+    private static boolean validateInteger(String value) {&#010;+        boolean valid = false;&#010;+        try {&#010;+            valid = Integer.valueOf(value) != null;&#010;+        } catch (Exception e) {&#010;+            // ignore&#010;+        }&#010;+        if (!valid) {&#010;+            // it may be a time pattern, such as 5s for 5 seconds = 5000&#010;+            try {&#010;+                TimePatternConverter.toMilliSeconds(value);&#010;+                valid = true;&#010;+            } catch (Exception e) {&#010;+                // ignore&#010;+            }&#010;+        }&#010;+        return valid;&#010;+    }&#010;+&#010;+    // CHECKSTYLE:ON&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java&#010;new file mode 100644&#010;index 0000000..d3a448c&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java&#010;@@ -0,0 +1,80 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.IOException;&#010;+&#010;+import org.apache.camel.CamelContext;&#010;+&#010;+/**&#010;+ * Uses runtime {@link CamelContext} to resolve the JSon schema files.&#010;+ */&#010;+public class CamelContextJSonSchemaResolver implements JSonSchemaResolver {&#010;+&#010;+    private final CamelContext camelContext;&#010;+&#010;+    public CamelContextJSonSchemaResolver(CamelContext camelContext) {&#010;+        this.camelContext = camelContext;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getComponentJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getComponentParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getDataFormatJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getDataFormatParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getLanguageJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getLanguageParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getOtherJSonSchema(String name) {&#010;+        // not supported&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getModelJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getEipParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java&#010;new file mode 100644&#010;index 0000000..1b224df&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java&#010;@@ -0,0 +1,179 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.BufferedReader;&#010;+import java.io.IOException;&#010;+import java.io.InputStream;&#010;+import java.io.InputStreamReader;&#010;+import java.io.LineNumberReader;&#010;+import java.util.List;&#010;+&#010;+public final class CatalogHelper {&#010;+&#010;+    private CatalogHelper() {&#010;+    }&#010;+&#010;+    /**&#010;+     * Loads the entire stream into memory as a String and returns it.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Notice:&lt;/b&gt; This implementation appends a &lt;tt&gt;\n&lt;/tt&gt; as line&#010;+     * terminator at the of the text.&#010;+     * &lt;p/&gt;&#010;+     * Warning, don't use for crazy big streams :)&#010;+     */&#010;+    public static void loadLines(InputStream in, List&lt;String&gt; lines) throws IOException {&#010;+        try (final InputStreamReader isr = new InputStreamReader(in);&#010;+            final BufferedReader reader = new LineNumberReader(isr)) {&#010;+            String line;&#010;+            while ((line = reader.readLine()) != null) {&#010;+                lines.add(line);&#010;+            }&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Loads the entire stream into memory as a String and returns it.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Notice:&lt;/b&gt; This implementation appends a &lt;tt&gt;\n&lt;/tt&gt; as line&#010;+     * terminator at the of the text.&#010;+     * &lt;p/&gt;&#010;+     * Warning, don't use for crazy big streams :)&#010;+     */&#010;+    public static String loadText(InputStream in) throws IOException {&#010;+        StringBuilder builder = new StringBuilder();&#010;+        try (final InputStreamReader isr = new InputStreamReader(in);&#010;+            final BufferedReader reader = new LineNumberReader(isr)) {&#010;+            String line;&#010;+            while ((line = reader.readLine()) != null) {&#010;+                builder.append(line);&#010;+                builder.append(""\n"");&#010;+            }&#010;+            return builder.toString();&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Matches the name with the pattern.&#010;+     *&#010;+     * @param name  the name&#010;+     * @param pattern the pattern&#010;+     * @return &lt;tt&gt;true&lt;/tt&gt; if matched, or &lt;tt&gt;false&lt;/tt&gt; if not&#010;+     */&#010;+    public static boolean matchWildcard(String name, String pattern) {&#010;+        // we have wildcard support in that hence you can match with: file* to match any file endpoints&#010;+        if (pattern.endsWith(""*"") &amp;&amp; name.startsWith(pattern.substring(0, pattern.length() - 1))) {&#010;+            return true;&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    /**&#010;+     * Returns the string after the given token&#010;+     *&#010;+     * @param text  the text&#010;+     * @param after the token&#010;+     * @return the text after the token, or &lt;tt&gt;null&lt;/tt&gt; if text does not contain the token&#010;+     */&#010;+    public static String after(String text, String after) {&#010;+        if (!text.contains(after)) {&#010;+            return null;&#010;+        }&#010;+        return text.substring(text.indexOf(after) + after.length());&#010;+    }&#010;+&#010;+    /**&#010;+     * Returns the string before the given token&#010;+     *&#010;+     * @param text  the text&#010;+     * @param before the token&#010;+     * @return the text before the token, or &lt;tt&gt;null&lt;/tt&gt; if text does not contain the token&#010;+     */&#010;+    public static String before(String text, String before) {&#010;+        if (!text.contains(before)) {&#010;+            return null;&#010;+        }&#010;+        return text.substring(0, text.indexOf(before));&#010;+    }&#010;+&#010;+    /**&#010;+     * Returns the string between the given tokens&#010;+     *&#010;+     * @param text  the text&#010;+     * @param after the before token&#010;+     * @param before the after token&#010;+     * @return the text between the tokens, or &lt;tt&gt;null&lt;/tt&gt; if text does not contain the tokens&#010;+     */&#010;+    public static String between(String text, String after, String before) {&#010;+        text = after(text, after);&#010;+        if (text == null) {&#010;+            return null;&#010;+        }&#010;+        return before(text, before);&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if empty&#010;+     */&#010;+    public static boolean isEmpty(Object value) {&#010;+        return !isNotEmpty(value);&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;b&gt;not&lt;/b&gt; &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if &lt;b&gt;not&lt;/b&gt; empty&#010;+     */&#010;+    public static boolean isNotEmpty(Object value) {&#010;+        if (value == null) {&#010;+            return false;&#010;+        } else if (value instanceof String) {&#010;+            String text = (String) value;&#010;+            return text.trim().length() &gt; 0;&#010;+        } else {&#010;+            return true;&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Removes all leading and ending quotes (single and double) from the string&#010;+     *&#010;+     * @param s  the string&#010;+     * @return the string without leading and ending quotes (single and double)&#010;+     */&#010;+    public static String removeLeadingAndEndingQuotes(String s) {&#010;+        if (isEmpty(s)) {&#010;+            return s;&#010;+        }&#010;+&#010;+        String copy = s.trim();&#010;+        if (copy.startsWith(""'"") &amp;&amp; copy.endsWith(""'"")) {&#010;+            return copy.substring(1, copy.length() - 1);&#010;+        }&#010;+        if (copy.startsWith(""\"""") &amp;&amp; copy.endsWith(""\"""")) {&#010;+            return copy.substring(1, copy.length() - 1);&#010;+        }&#010;+&#010;+        // no quotes, so return as-is&#010;+        return s;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java&#010;new file mode 100644&#010;index 0000000..f6484b8&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java&#010;@@ -0,0 +1,57 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+public class CollectionStringBuffer {&#010;+    private final StringBuilder buffer = new StringBuilder();&#010;+    private String separator;&#010;+    private boolean first = true;&#010;+&#010;+    public CollectionStringBuffer() {&#010;+        this("", "");&#010;+    }&#010;+&#010;+    public CollectionStringBuffer(String separator) {&#010;+        this.separator = separator;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String toString() {&#010;+        return buffer.toString();&#010;+    }&#010;+&#010;+    public void append(Object value) {&#010;+        if (first) {&#010;+            first = false;&#010;+        } else {&#010;+            buffer.append(separator);&#010;+        }&#010;+        buffer.append(value);&#010;+    }&#010;+&#010;+    public String getSeparator() {&#010;+        return separator;&#010;+    }&#010;+&#010;+    public void setSeparator(String separator) {&#010;+        this.separator = separator;&#010;+    }&#010;+&#010;+    public boolean isEmpty() {&#010;+        return first;&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java&#010;new file mode 100644&#010;index 0000000..7648e64&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java&#010;@@ -0,0 +1,136 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.HashMap;&#010;+import java.util.Map;&#010;+&#010;+import org.apache.camel.CamelContext;&#010;+&#010;+/**&#010;+ * Default {@link RuntimeCamelCatalog}.&#010;+ */&#010;+public class DefaultRuntimeCamelCatalog extends AbstractCamelCatalog implements RuntimeCamelCatalog {&#010;+&#010;+    // cache of operation -&gt; result&#010;+    private final Map&lt;String, Object&gt; cache = new HashMap&lt;String, Object&gt;();&#010;+    private boolean caching;&#010;+&#010;+    /**&#010;+     * Creates the {@link RuntimeCamelCatalog} without caching enabled.&#010;+     *&#010;+     * @param camelContext  the camel context&#010;+     */&#010;+    public DefaultRuntimeCamelCatalog(CamelContext camelContext) {&#010;+        this(camelContext, false);&#010;+    }&#010;+&#010;+    /**&#010;+     * Creates the {@link RuntimeCamelCatalog}&#010;+     *&#010;+     * @param camelContext  the camel context&#010;+     * @param caching  whether to use cache&#010;+     */&#010;+    public DefaultRuntimeCamelCatalog(CamelContext camelContext, boolean caching) {&#010;+        this.caching = caching;&#010;+        setJSonSchemaResolver(new CamelContextJSonSchemaResolver(camelContext));&#010;+    }&#010;+&#010;+    @Override&#010;+    public void start() throws Exception {&#010;+        // noop&#010;+    }&#010;+&#010;+    @Override&#010;+    public void stop() throws Exception {&#010;+        cache.clear();&#010;+    }&#010;+&#010;+    @Override&#010;+    public String modelJSonSchema(String name) {&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""model-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getModelJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""model-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String componentJSonSchema(String name) {&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""component-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getComponentJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""component-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String dataFormatJSonSchema(String name) {&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""dataformat-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getDataFormatJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""dataformat-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String languageJSonSchema(String name) {&#010;+        // if we try to look method then its in the bean.json file&#010;+        if (""method"".equals(name)) {&#010;+            name = ""bean"";&#010;+        }&#010;+&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""language-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getLanguageJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""language-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java&#010;new file mode 100644&#010;index 0000000..7d1c657&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java&#010;@@ -0,0 +1,451 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.Serializable;&#010;+import java.util.Arrays;&#010;+import java.util.Collections;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.LinkedHashSet;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+import java.util.Set;&#010;+&#010;+import static org.apache.camel.runtimecatalog.URISupport.isEmpty;&#010;+&#010;+/**&#010;+ * Details result of validating endpoint uri.&#010;+ */&#010;+public class EndpointValidationResult implements Serializable {&#010;+&#010;+    private final String uri;&#010;+    private int errors;&#010;+&#010;+    // general&#010;+    private String syntaxError;&#010;+    private String unknownComponent;&#010;+    private String incapable;&#010;+&#010;+    // options&#010;+    private Set&lt;String&gt; unknown;&#010;+    private Map&lt;String, String[]&gt; unknownSuggestions;&#010;+    private Set&lt;String&gt; lenient;&#010;+    private Set&lt;String&gt; notConsumerOnly;&#010;+    private Set&lt;String&gt; notProducerOnly;&#010;+    private Set&lt;String&gt; required;&#010;+    private Map&lt;String, String&gt; invalidEnum;&#010;+    private Map&lt;String, String[]&gt; invalidEnumChoices;&#010;+    private Map&lt;String, String[]&gt; invalidEnumSuggestions;&#010;+    private Map&lt;String, String&gt; invalidReference;&#010;+    private Map&lt;String, String&gt; invalidBoolean;&#010;+    private Map&lt;String, String&gt; invalidInteger;&#010;+    private Map&lt;String, String&gt; invalidNumber;&#010;+    private Map&lt;String, String&gt; defaultValues;&#010;+&#010;+    public EndpointValidationResult() {&#010;+        this(null);&#010;+    }&#010;+&#010;+    public EndpointValidationResult(String uri) {&#010;+        this.uri = uri;&#010;+    }&#010;+&#010;+    public String getUri() {&#010;+        return uri;&#010;+    }&#010;+&#010;+    public boolean hasErrors() {&#010;+        return errors &gt; 0;&#010;+    }&#010;+&#010;+    public int getNumberOfErrors() {&#010;+        return errors;&#010;+    }&#010;+&#010;+    public boolean isSuccess() {&#010;+        boolean ok = syntaxError == null &amp;&amp; unknownComponent == null &amp;&amp; incapable == null&#010;+                &amp;&amp; unknown == null &amp;&amp; required == null;&#010;+        if (ok) {&#010;+            ok = notConsumerOnly == null &amp;&amp; notProducerOnly == null;&#010;+        }&#010;+        if (ok) {&#010;+            ok = invalidEnum == null &amp;&amp; invalidEnumChoices == null &amp;&amp; invalidReference == null&#010;+                &amp;&amp; invalidBoolean == null &amp;&amp; invalidInteger == null &amp;&amp; invalidNumber == null;&#010;+        }&#010;+        return ok;&#010;+    }&#010;+&#010;+    public void addSyntaxError(String syntaxError) {&#010;+        this.syntaxError = syntaxError;&#010;+        errors++;&#010;+    }&#010;+&#010;+    public void addIncapable(String uri) {&#010;+        this.incapable = uri;&#010;+        errors++;&#010;+    }&#010;+&#010;+    public void addUnknownComponent(String name) {&#010;+        this.unknownComponent = name;&#010;+        errors++;&#010;+    }&#010;+&#010;+    public void addUnknown(String name) {&#010;+        if (unknown == null) {&#010;+            unknown = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!unknown.contains(name)) {&#010;+            unknown.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addUnknownSuggestions(String name, String[] suggestions) {&#010;+        if (unknownSuggestions == null) {&#010;+            unknownSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;+        }&#010;+        unknownSuggestions.put(name, suggestions);&#010;+    }&#010;+&#010;+    public void addLenient(String name) {&#010;+        if (lenient == null) {&#010;+            lenient = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!lenient.contains(name)) {&#010;+            lenient.add(name);&#010;+        }&#010;+    }&#010;+&#010;+    public void addRequired(String name) {&#010;+        if (required == null) {&#010;+            required = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!required.contains(name)) {&#010;+            required.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidEnum(String name, String value) {&#010;+        if (invalidEnum == null) {&#010;+            invalidEnum = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidEnum.containsKey(name)) {&#010;+            invalidEnum.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidEnumChoices(String name, String[] choices) {&#010;+        if (invalidEnumChoices == null) {&#010;+            invalidEnumChoices = new LinkedHashMap&lt;String, String[]&gt;();&#010;+        }&#010;+        invalidEnumChoices.put(name, choices);&#010;+    }&#010;+&#010;+    public void addInvalidEnumSuggestions(String name, String[] suggestions) {&#010;+        if (invalidEnumSuggestions == null) {&#010;+            invalidEnumSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;+        }&#010;+        invalidEnumSuggestions.put(name, suggestions);&#010;+    }&#010;+&#010;+    public void addInvalidReference(String name, String value) {&#010;+        if (invalidReference == null) {&#010;+            invalidReference = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidReference.containsKey(name)) {&#010;+            invalidReference.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidBoolean(String name, String value) {&#010;+        if (invalidBoolean == null) {&#010;+            invalidBoolean = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidBoolean.containsKey(name)) {&#010;+            invalidBoolean.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidInteger(String name, String value) {&#010;+        if (invalidInteger == null) {&#010;+            invalidInteger = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidInteger.containsKey(name)) {&#010;+            invalidInteger.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidNumber(String name, String value) {&#010;+        if (invalidNumber == null) {&#010;+            invalidNumber = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidNumber.containsKey(name)) {&#010;+            invalidNumber.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addDefaultValue(String name, String value)  {&#010;+        if (defaultValues == null) {&#010;+            defaultValues = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        defaultValues.put(name, value);&#010;+    }&#010;+&#010;+    public void addNotConsumerOnly(String name) {&#010;+        if (notConsumerOnly == null) {&#010;+            notConsumerOnly = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!notConsumerOnly.contains(name)) {&#010;+            notConsumerOnly.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addNotProducerOnly(String name) {&#010;+        if (notProducerOnly == null) {&#010;+            notProducerOnly = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!notProducerOnly.contains(name)) {&#010;+            notProducerOnly.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public String getSyntaxError() {&#010;+        return syntaxError;&#010;+    }&#010;+&#010;+    public String getIncapable() {&#010;+        return incapable;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getUnknown() {&#010;+        return unknown;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getLenient() {&#010;+        return lenient;&#010;+    }&#010;+&#010;+    public Map&lt;String, String[]&gt; getUnknownSuggestions() {&#010;+        return unknownSuggestions;&#010;+    }&#010;+&#010;+    public String getUnknownComponent() {&#010;+        return unknownComponent;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getRequired() {&#010;+        return required;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidEnum() {&#010;+        return invalidEnum;&#010;+    }&#010;+&#010;+    public Map&lt;String, String[]&gt; getInvalidEnumChoices() {&#010;+        return invalidEnumChoices;&#010;+    }&#010;+&#010;+    public List&lt;String&gt; getEnumChoices(String optionName) {&#010;+        if (invalidEnumChoices != null) {&#010;+            String[] enums = invalidEnumChoices.get(optionName);&#010;+            if (enums != null) {&#010;+                return Arrays.asList(enums);&#010;+            }&#010;+        }&#010;+&#010;+        return Collections.emptyList();&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidReference() {&#010;+        return invalidReference;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidBoolean() {&#010;+        return invalidBoolean;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidInteger() {&#010;+        return invalidInteger;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidNumber() {&#010;+        return invalidNumber;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getDefaultValues() {&#010;+        return defaultValues;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getNotConsumerOnly() {&#010;+        return notConsumerOnly;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getNotProducerOnly() {&#010;+        return notProducerOnly;&#010;+    }&#010;+&#010;+    /**&#010;+     * A human readable summary of the validation errors.&#010;+     *&#010;+     * @param includeHeader whether to include a header&#010;+     * @return the summary, or &lt;tt&gt;null&lt;/tt&gt; if no validation errors&#010;+     */&#010;+    public String summaryErrorMessage(boolean includeHeader) {&#010;+        if (isSuccess()) {&#010;+            return null;&#010;+        }&#010;+&#010;+        if (incapable != null) {&#010;+            return ""\tIncapable of parsing uri: "" + incapable;&#010;+        } else if (syntaxError != null) {&#010;+            return ""\tSyntax error: "" + syntaxError;&#010;+        } else if (unknownComponent != null) {&#010;+            return ""\tUnknown component: "" + unknownComponent;&#010;+        }&#010;+&#010;+        // for each invalid option build a reason message&#010;+        Map&lt;String, String&gt; options = new LinkedHashMap&lt;String, String&gt;();&#010;+        if (unknown != null) {&#010;+            for (String name : unknown) {&#010;+                if (unknownSuggestions != null &amp;&amp; unknownSuggestions.containsKey(name)) {&#010;+                    String[] suggestions = unknownSuggestions.get(name);&#010;+                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;+                        String str = Arrays.asList(suggestions).toString();&#010;+                        options.put(name, ""Unknown option. Did you mean: "" + str);&#010;+                    } else {&#010;+                        options.put(name, ""Unknown option"");&#010;+                    }&#010;+                } else {&#010;+                    options.put(name, ""Unknown option"");&#010;+                }&#010;+            }&#010;+        }&#010;+        if (notConsumerOnly != null) {&#010;+            for (String name : notConsumerOnly) {&#010;+                options.put(name, ""Option not applicable in consumer only mode"");&#010;+            }&#010;+        }&#010;+        if (notProducerOnly != null) {&#010;+            for (String name : notProducerOnly) {&#010;+                options.put(name, ""Option not applicable in producer only mode"");&#010;+            }&#010;+        }&#010;+        if (required != null) {&#010;+            for (String name : required) {&#010;+                options.put(name, ""Missing required option"");&#010;+            }&#010;+        }&#010;+        if (invalidEnum != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidEnum.entrySet()) {&#010;+                String name = entry.getKey();&#010;+                String[] choices = invalidEnumChoices.get(name);&#010;+                String defaultValue = defaultValues != null ? defaultValues.get(entry.getKey()) : null;&#010;+                String str = Arrays.asList(choices).toString();&#010;+                String msg = ""Invalid enum value: "" + entry.getValue() + "". Possible values: "" + str;&#010;+                if (invalidEnumSuggestions != null) {&#010;+                    String[] suggestions = invalidEnumSuggestions.get(name);&#010;+                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;+                        str = Arrays.asList(suggestions).toString();&#010;+                        msg += "". Did you mean: "" + str;&#010;+                    }&#010;+                }&#010;+                if (defaultValue != null) {&#010;+                    msg += "". Default value: "" + defaultValue;&#010;+                }&#010;+&#010;+                options.put(entry.getKey(), msg);&#010;+            }&#010;+        }&#010;+        if (invalidReference != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidReference.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty reference value"");&#010;+                } else if (!entry.getValue().startsWith(""#"")) {&#010;+                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue() + "" must start with #"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+        if (invalidBoolean != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidBoolean.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty boolean value"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid boolean value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+        if (invalidInteger != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidInteger.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty integer value"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid integer value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+        if (invalidNumber != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidNumber.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty number value"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid number value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // build a table with the error summary nicely formatted&#010;+        // lets use 24 as min length&#010;+        int maxLen = 24;&#010;+        for (String key : options.keySet()) {&#010;+            maxLen = Math.max(maxLen, key.length());&#010;+        }&#010;+        String format = ""%"" + maxLen + ""s    %s"";&#010;+&#010;+        // build the human error summary&#010;+        StringBuilder sb = new StringBuilder();&#010;+        if (includeHeader) {&#010;+            sb.append(""Endpoint validator error\n"");&#010;+            sb.append(""---------------------------------------------------------------------------------------------------------------------------------------\n"");&#010;+            sb.append(""\n"");&#010;+        }&#010;+        if (uri != null) {&#010;+            sb.append(""\t"").append(uri).append(""\n"");&#010;+        } else {&#010;+            sb.append(""\n"");&#010;+        }&#010;+        for (Map.Entry&lt;String, String&gt; option : options.entrySet()) {&#010;+            String out = String.format(format, option.getKey(), option.getValue());&#010;+            sb.append(""\n\t"").append(out);&#010;+        }&#010;+&#010;+        return sb.toString();&#010;+    }&#010;+}&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C0ffd278dae9f48d5849d5bd0dc60655f%40git.apache.org%3E,2017-04-14 10:52,commits,4.0,325.0,  [4/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
15,326.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java b/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&#010;deleted file mode 100644&#010;index 9bb98f0..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&#010;+++ /dev/null&#010;@@ -1,451 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.io.Serializable;&#010;-import java.util.Arrays;&#010;-import java.util.Collections;&#010;-import java.util.LinkedHashMap;&#010;-import java.util.LinkedHashSet;&#010;-import java.util.List;&#010;-import java.util.Map;&#010;-import java.util.Set;&#010;-&#010;-import static org.apache.camel.catalog.URISupport.isEmpty;&#010;-&#010;-/**&#010;- * Details result of validating endpoint uri.&#010;- */&#010;-public class EndpointValidationResult implements Serializable {&#010;-&#010;-    private final String uri;&#010;-    private int errors;&#010;-&#010;-    // general&#010;-    private String syntaxError;&#010;-    private String unknownComponent;&#010;-    private String incapable;&#010;-&#010;-    // options&#010;-    private Set&lt;String&gt; unknown;&#010;-    private Map&lt;String, String[]&gt; unknownSuggestions;&#010;-    private Set&lt;String&gt; lenient;&#010;-    private Set&lt;String&gt; notConsumerOnly;&#010;-    private Set&lt;String&gt; notProducerOnly;&#010;-    private Set&lt;String&gt; required;&#010;-    private Map&lt;String, String&gt; invalidEnum;&#010;-    private Map&lt;String, String[]&gt; invalidEnumChoices;&#010;-    private Map&lt;String, String[]&gt; invalidEnumSuggestions;&#010;-    private Map&lt;String, String&gt; invalidReference;&#010;-    private Map&lt;String, String&gt; invalidBoolean;&#010;-    private Map&lt;String, String&gt; invalidInteger;&#010;-    private Map&lt;String, String&gt; invalidNumber;&#010;-    private Map&lt;String, String&gt; defaultValues;&#010;-&#010;-    public EndpointValidationResult() {&#010;-        this(null);&#010;-    }&#010;-&#010;-    public EndpointValidationResult(String uri) {&#010;-        this.uri = uri;&#010;-    }&#010;-&#010;-    public String getUri() {&#010;-        return uri;&#010;-    }&#010;-&#010;-    public boolean hasErrors() {&#010;-        return errors &gt; 0;&#010;-    }&#010;-&#010;-    public int getNumberOfErrors() {&#010;-        return errors;&#010;-    }&#010;-&#010;-    public boolean isSuccess() {&#010;-        boolean ok = syntaxError == null &amp;&amp; unknownComponent == null &amp;&amp; incapable == null&#010;-                &amp;&amp; unknown == null &amp;&amp; required == null;&#010;-        if (ok) {&#010;-            ok = notConsumerOnly == null &amp;&amp; notProducerOnly == null;&#010;-        }&#010;-        if (ok) {&#010;-            ok = invalidEnum == null &amp;&amp; invalidEnumChoices == null &amp;&amp; invalidReference == null&#010;-                &amp;&amp; invalidBoolean == null &amp;&amp; invalidInteger == null &amp;&amp; invalidNumber == null;&#010;-        }&#010;-        return ok;&#010;-    }&#010;-&#010;-    public void addSyntaxError(String syntaxError) {&#010;-        this.syntaxError = syntaxError;&#010;-        errors++;&#010;-    }&#010;-&#010;-    public void addIncapable(String uri) {&#010;-        this.incapable = uri;&#010;-        errors++;&#010;-    }&#010;-&#010;-    public void addUnknownComponent(String name) {&#010;-        this.unknownComponent = name;&#010;-        errors++;&#010;-    }&#010;-&#010;-    public void addUnknown(String name) {&#010;-        if (unknown == null) {&#010;-            unknown = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!unknown.contains(name)) {&#010;-            unknown.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addUnknownSuggestions(String name, String[] suggestions) {&#010;-        if (unknownSuggestions == null) {&#010;-            unknownSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;-        }&#010;-        unknownSuggestions.put(name, suggestions);&#010;-    }&#010;-&#010;-    public void addLenient(String name) {&#010;-        if (lenient == null) {&#010;-            lenient = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!lenient.contains(name)) {&#010;-            lenient.add(name);&#010;-        }&#010;-    }&#010;-&#010;-    public void addRequired(String name) {&#010;-        if (required == null) {&#010;-            required = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!required.contains(name)) {&#010;-            required.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidEnum(String name, String value) {&#010;-        if (invalidEnum == null) {&#010;-            invalidEnum = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidEnum.containsKey(name)) {&#010;-            invalidEnum.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidEnumChoices(String name, String[] choices) {&#010;-        if (invalidEnumChoices == null) {&#010;-            invalidEnumChoices = new LinkedHashMap&lt;String, String[]&gt;();&#010;-        }&#010;-        invalidEnumChoices.put(name, choices);&#010;-    }&#010;-&#010;-    public void addInvalidEnumSuggestions(String name, String[] suggestions) {&#010;-        if (invalidEnumSuggestions == null) {&#010;-            invalidEnumSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;-        }&#010;-        invalidEnumSuggestions.put(name, suggestions);&#010;-    }&#010;-&#010;-    public void addInvalidReference(String name, String value) {&#010;-        if (invalidReference == null) {&#010;-            invalidReference = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidReference.containsKey(name)) {&#010;-            invalidReference.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidBoolean(String name, String value) {&#010;-        if (invalidBoolean == null) {&#010;-            invalidBoolean = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidBoolean.containsKey(name)) {&#010;-            invalidBoolean.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidInteger(String name, String value) {&#010;-        if (invalidInteger == null) {&#010;-            invalidInteger = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidInteger.containsKey(name)) {&#010;-            invalidInteger.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidNumber(String name, String value) {&#010;-        if (invalidNumber == null) {&#010;-            invalidNumber = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidNumber.containsKey(name)) {&#010;-            invalidNumber.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addDefaultValue(String name, String value)  {&#010;-        if (defaultValues == null) {&#010;-            defaultValues = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        defaultValues.put(name, value);&#010;-    }&#010;-&#010;-    public void addNotConsumerOnly(String name) {&#010;-        if (notConsumerOnly == null) {&#010;-            notConsumerOnly = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!notConsumerOnly.contains(name)) {&#010;-            notConsumerOnly.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addNotProducerOnly(String name) {&#010;-        if (notProducerOnly == null) {&#010;-            notProducerOnly = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!notProducerOnly.contains(name)) {&#010;-            notProducerOnly.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public String getSyntaxError() {&#010;-        return syntaxError;&#010;-    }&#010;-&#010;-    public String getIncapable() {&#010;-        return incapable;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getUnknown() {&#010;-        return unknown;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getLenient() {&#010;-        return lenient;&#010;-    }&#010;-&#010;-    public Map&lt;String, String[]&gt; getUnknownSuggestions() {&#010;-        return unknownSuggestions;&#010;-    }&#010;-&#010;-    public String getUnknownComponent() {&#010;-        return unknownComponent;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getRequired() {&#010;-        return required;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidEnum() {&#010;-        return invalidEnum;&#010;-    }&#010;-&#010;-    public Map&lt;String, String[]&gt; getInvalidEnumChoices() {&#010;-        return invalidEnumChoices;&#010;-    }&#010;-&#010;-    public List&lt;String&gt; getEnumChoices(String optionName) {&#010;-        if (invalidEnumChoices != null) {&#010;-            String[] enums = invalidEnumChoices.get(optionName);&#010;-            if (enums != null) {&#010;-                return Arrays.asList(enums);&#010;-            }&#010;-        }&#010;-&#010;-        return Collections.emptyList();&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidReference() {&#010;-        return invalidReference;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidBoolean() {&#010;-        return invalidBoolean;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidInteger() {&#010;-        return invalidInteger;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidNumber() {&#010;-        return invalidNumber;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getDefaultValues() {&#010;-        return defaultValues;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getNotConsumerOnly() {&#010;-        return notConsumerOnly;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getNotProducerOnly() {&#010;-        return notProducerOnly;&#010;-    }&#010;-&#010;-    /**&#010;-     * A human readable summary of the validation errors.&#010;-     *&#010;-     * @param includeHeader whether to include a header&#010;-     * @return the summary, or &lt;tt&gt;null&lt;/tt&gt; if no validation errors&#010;-     */&#010;-    public String summaryErrorMessage(boolean includeHeader) {&#010;-        if (isSuccess()) {&#010;-            return null;&#010;-        }&#010;-&#010;-        if (incapable != null) {&#010;-            return ""\tIncapable of parsing uri: "" + incapable;&#010;-        } else if (syntaxError != null) {&#010;-            return ""\tSyntax error: "" + syntaxError;&#010;-        } else if (unknownComponent != null) {&#010;-            return ""\tUnknown component: "" + unknownComponent;&#010;-        }&#010;-&#010;-        // for each invalid option build a reason message&#010;-        Map&lt;String, String&gt; options = new LinkedHashMap&lt;String, String&gt;();&#010;-        if (unknown != null) {&#010;-            for (String name : unknown) {&#010;-                if (unknownSuggestions != null &amp;&amp; unknownSuggestions.containsKey(name)) {&#010;-                    String[] suggestions = unknownSuggestions.get(name);&#010;-                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;-                        String str = Arrays.asList(suggestions).toString();&#010;-                        options.put(name, ""Unknown option. Did you mean: "" + str);&#010;-                    } else {&#010;-                        options.put(name, ""Unknown option"");&#010;-                    }&#010;-                } else {&#010;-                    options.put(name, ""Unknown option"");&#010;-                }&#010;-            }&#010;-        }&#010;-        if (notConsumerOnly != null) {&#010;-            for (String name : notConsumerOnly) {&#010;-                options.put(name, ""Option not applicable in consumer only mode"");&#010;-            }&#010;-        }&#010;-        if (notProducerOnly != null) {&#010;-            for (String name : notProducerOnly) {&#010;-                options.put(name, ""Option not applicable in producer only mode"");&#010;-            }&#010;-        }&#010;-        if (required != null) {&#010;-            for (String name : required) {&#010;-                options.put(name, ""Missing required option"");&#010;-            }&#010;-        }&#010;-        if (invalidEnum != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidEnum.entrySet()) {&#010;-                String name = entry.getKey();&#010;-                String[] choices = invalidEnumChoices.get(name);&#010;-                String defaultValue = defaultValues != null ? defaultValues.get(entry.getKey()) : null;&#010;-                String str = Arrays.asList(choices).toString();&#010;-                String msg = ""Invalid enum value: "" + entry.getValue() + "". Possible values: "" + str;&#010;-                if (invalidEnumSuggestions != null) {&#010;-                    String[] suggestions = invalidEnumSuggestions.get(name);&#010;-                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;-                        str = Arrays.asList(suggestions).toString();&#010;-                        msg += "". Did you mean: "" + str;&#010;-                    }&#010;-                }&#010;-                if (defaultValue != null) {&#010;-                    msg += "". Default value: "" + defaultValue;&#010;-                }&#010;-&#010;-                options.put(entry.getKey(), msg);&#010;-            }&#010;-        }&#010;-        if (invalidReference != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidReference.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty reference value"");&#010;-                } else if (!entry.getValue().startsWith(""#"")) {&#010;-                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue() + "" must start with #"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-        if (invalidBoolean != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidBoolean.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty boolean value"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid boolean value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-        if (invalidInteger != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidInteger.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty integer value"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid integer value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-        if (invalidNumber != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidNumber.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty number value"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid number value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-&#010;-        // build a table with the error summary nicely formatted&#010;-        // lets use 24 as min length&#010;-        int maxLen = 24;&#010;-        for (String key : options.keySet()) {&#010;-            maxLen = Math.max(maxLen, key.length());&#010;-        }&#010;-        String format = ""%"" + maxLen + ""s    %s"";&#010;-&#010;-        // build the human error summary&#010;-        StringBuilder sb = new StringBuilder();&#010;-        if (includeHeader) {&#010;-            sb.append(""Endpoint validator error\n"");&#010;-            sb.append(""---------------------------------------------------------------------------------------------------------------------------------------\n"");&#010;-            sb.append(""\n"");&#010;-        }&#010;-        if (uri != null) {&#010;-            sb.append(""\t"").append(uri).append(""\n"");&#010;-        } else {&#010;-            sb.append(""\n"");&#010;-        }&#010;-        for (Map.Entry&lt;String, String&gt; option : options.entrySet()) {&#010;-            String out = String.format(format, option.getKey(), option.getValue());&#010;-            sb.append(""\n\t"").append(out);&#010;-        }&#010;-&#010;-        return sb.toString();&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java b/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&#010;deleted file mode 100644&#010;index 774facd..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&#010;+++ /dev/null&#010;@@ -1,424 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.ArrayList;&#010;-import java.util.LinkedHashMap;&#010;-import java.util.LinkedHashSet;&#010;-import java.util.List;&#010;-import java.util.Map;&#010;-import java.util.Set;&#010;-import java.util.regex.Matcher;&#010;-import java.util.regex.Pattern;&#010;-&#010;-public final class JSonSchemaHelper {&#010;-&#010;-    // 0 = text, 1 = enum, 2 = boolean, 3 = integer or number&#010;-    private static final Pattern PATTERN = Pattern.compile(""\""(.+?)\""|\\[(.+)\\]|(true|false)|(-?\\d+\\.?\\d*)"");&#010;-    private static final String QUOT = ""&amp;quot;"";&#010;-&#010;-    private JSonSchemaHelper() {&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the json schema to split it into a list or rows, where each row contains key value pairs with the metadata&#010;-     *&#010;-     * @param group the group to parse from such as &lt;tt&gt;component&lt;/tt&gt;, &lt;tt&gt;componentProperties&lt;/tt&gt;, or &lt;tt&gt;properties&lt;/tt&gt;.&#010;-     * @param json the json&#010;-     * @return a list of all the rows, where each row is a set of key value pairs with metadata&#010;-     */&#010;-    public static List&lt;Map&lt;String, String&gt;&gt; parseJsonSchema(String group, String json, boolean parseProperties) {&#010;-        List&lt;Map&lt;String, String&gt;&gt; answer = new ArrayList&lt;Map&lt;String, String&gt;&gt;();&#010;-        if (json == null) {&#010;-            return answer;&#010;-        }&#010;-&#010;-        boolean found = false;&#010;-&#010;-        // parse line by line&#010;-        String[] lines = json.split(""\n"");&#010;-        for (String line : lines) {&#010;-            // we need to find the group first&#010;-            if (!found) {&#010;-                String s = line.trim();&#010;-                found = s.startsWith(""\"""" + group + ""\"":"") &amp;&amp; s.endsWith(""{"");&#010;-                continue;&#010;-            }&#010;-&#010;-            // we should stop when we end the group&#010;-            if (line.equals(""  },"") || line.equals(""  }"")) {&#010;-                break;&#010;-            }&#010;-&#010;-            // need to safe encode \"" so we can parse the line&#010;-            line = line.replaceAll(""\""\\\\\""\"""", '""' + QUOT + '""');&#010;-&#010;-            Map&lt;String, String&gt; row = new LinkedHashMap&lt;String, String&gt;();&#010;-            Matcher matcher = PATTERN.matcher(line);&#010;-&#010;-            String key;&#010;-            if (parseProperties) {&#010;-                // when parsing properties the first key is given as name, so the first parsed token is the value of the name&#010;-                key = ""name"";&#010;-            } else {&#010;-                key = null;&#010;-            }&#010;-            while (matcher.find()) {&#010;-                if (key == null) {&#010;-                    key = matcher.group(1);&#010;-                } else {&#010;-                    String value = matcher.group(1);&#010;-                    if (value != null) {&#010;-                        // its text based&#010;-                        value = value.trim();&#010;-                        // decode&#010;-                        value = value.replaceAll(QUOT, ""\"""");&#010;-                        value = decodeJson(value);&#010;-                    }&#010;-                    if (value == null) {&#010;-                        // not text then its maybe an enum?&#010;-                        value = matcher.group(2);&#010;-                        if (value != null) {&#010;-                            // its an enum so strip out "" and trim spaces after comma&#010;-                            value = value.replaceAll(""\"""", """");&#010;-                            value = value.replaceAll("", "", "","");&#010;-                            value = value.trim();&#010;-                        }&#010;-                    }&#010;-                    if (value == null) {&#010;-                        // not text then its maybe a boolean?&#010;-                        value = matcher.group(3);&#010;-                    }&#010;-                    if (value == null) {&#010;-                        // not text then its maybe a integer?&#010;-                        value = matcher.group(4);&#010;-                    }&#010;-                    if (value != null) {&#010;-                        row.put(key, value);&#010;-                    }&#010;-                    // reset&#010;-                    key = null;&#010;-                }&#010;-            }&#010;-            if (!row.isEmpty()) {&#010;-                answer.add(row);&#010;-            }&#010;-        }&#010;-&#010;-        return answer;&#010;-    }&#010;-&#010;-    private static String decodeJson(String value) {&#010;-        // json encodes a \ as \\ so we need to decode from \\ back to \&#010;-        if (""\\\\"".equals(value)) {&#010;-            value = ""\\"";&#010;-        }&#010;-        return value;&#010;-    }&#010;-&#010;-    public static boolean isComponentLenientProperties(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""lenientProperties"")) {&#010;-                return ""true"".equals(row.get(""lenientProperties""));&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isComponentConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""consumerOnly"")) {&#010;-                return ""true"".equals(row.get(""consumerOnly""));&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isComponentProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""producerOnly"")) {&#010;-                return ""true"".equals(row.get(""producerOnly""));&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String labels = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""label"")) {&#010;-                labels = row.get(""label"");&#010;-            }&#010;-            if (found) {&#010;-                return labels != null &amp;&amp; labels.contains(""consumer"");&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String labels = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""label"")) {&#010;-                labels = row.get(""label"");&#010;-            }&#010;-            if (found) {&#010;-                return labels != null &amp;&amp; labels.contains(""producer"");&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyRequired(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            boolean required = false;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""required"")) {&#010;-                required = ""true"".equals(row.get(""required""));&#010;-            }&#010;-            if (found) {&#010;-                return required;&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static String getPropertyKind(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String kind = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""kind"")) {&#010;-                kind = row.get(""kind"");&#010;-            }&#010;-            if (found) {&#010;-                return kind;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static boolean isPropertyBoolean(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""boolean"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyInteger(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""integer"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyNumber(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""number"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyObject(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""object"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static String getPropertyDefaultValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String defaultValue = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""defaultValue"")) {&#010;-                defaultValue = row.get(""defaultValue"");&#010;-            }&#010;-            if (found) {&#010;-                return defaultValue;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static String stripOptionalPrefixFromName(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String optionalPrefix = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""optionalPrefix"")) {&#010;-                optionalPrefix = row.get(""optionalPrefix"");&#010;-            }&#010;-            if (row.containsKey(""name"")) {&#010;-                if (optionalPrefix != null &amp;&amp; name.startsWith(optionalPrefix)) {&#010;-                    name = name.substring(optionalPrefix.length());&#010;-                    // try again&#010;-                    return stripOptionalPrefixFromName(rows, name);&#010;-                } else {&#010;-                    found = name.equals(row.get(""name""));&#010;-                }&#010;-            }&#010;-            if (found) {&#010;-                return name;&#010;-            }&#010;-        }&#010;-        return name;&#010;-    }&#010;-&#010;-    public static String getPropertyEnum(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String enums = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""enum"")) {&#010;-                enums = row.get(""enum"");&#010;-            }&#010;-            if (found) {&#010;-                return enums;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static String getPropertyPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String prefix = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""prefix"")) {&#010;-                prefix = row.get(""prefix"");&#010;-            }&#010;-            if (found) {&#010;-                return prefix;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static boolean isPropertyMultiValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            boolean multiValue = false;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""multiValue"")) {&#010;-                multiValue = ""true"".equals(row.get(""multiValue""));&#010;-            }&#010;-            if (found) {&#010;-                return multiValue;&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static String getPropertyNameFromNameWithPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String propertyName = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                propertyName = row.get(""name"");&#010;-            }&#010;-            if (row.containsKey(""prefix"")) {&#010;-                String preifx = row.get(""prefix"");&#010;-                found = name.startsWith(preifx);&#010;-            }&#010;-            if (found) {&#010;-                return propertyName;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static Map&lt;String, String&gt; getRow(List&lt;Map&lt;String, String&gt;&gt; rows, String key) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (key.equals(row.get(""name""))) {&#010;-                return row;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static Set&lt;String&gt; getNames(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        Set&lt;String&gt; answer = new LinkedHashSet&lt;String&gt;();&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""name"")) {&#010;-                answer.add(row.get(""name""));&#010;-            }&#010;-        }&#010;-        return answer;&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java b/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&#010;deleted file mode 100644&#010;index 9bf09cc..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&#010;+++ /dev/null&#010;@@ -1,64 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-/**&#010;- * Pluggable resolver to load JSon schema files for components, data formats, languages etc.&#010;- */&#010;-public interface JSonSchemaResolver {&#010;-&#010;-    /**&#010;-     * Returns the component information as JSon format.&#010;-     *&#010;-     * @param name the component name&#010;-     * @return component details in JSon&#010;-     */&#010;-    String getComponentJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the data format information as JSon format.&#010;-     *&#010;-     * @param name the data format name&#010;-     * @return data format details in JSon&#010;-     */&#010;-    String getDataFormatJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the language information as JSon format.&#010;-     *&#010;-     * @param name the language name&#010;-     * @return language details in JSon&#010;-     */&#010;-    String getLanguageJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the other (miscellaneous) information as JSon format.&#010;-     *&#010;-     * @param name the other (miscellaneous) name&#010;-     * @return other (miscellaneous) details in JSon&#010;-     */&#010;-    String getOtherJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the model information as JSon format.&#010;-     *&#010;-     * @param name the model name&#010;-     * @return model details in JSon&#010;-     */&#010;-    String getModelJSonSchema(String name);&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java b/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&#010;deleted file mode 100644&#010;index 4a977eb..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&#010;+++ /dev/null&#010;@@ -1,65 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.io.Serializable;&#010;-&#010;-/**&#010;- * Validation result of parsing a language expression or predicate&#010;- */&#010;-public class LanguageValidationResult implements Serializable {&#010;-    private final String text;&#010;-    private String error;&#010;-    private String shortError;&#010;-    private int index;&#010;-&#010;-    public LanguageValidationResult(String text) {&#010;-        this.text = text;&#010;-    }&#010;-&#010;-    public String getText() {&#010;-        return text;&#010;-    }&#010;-&#010;-    public boolean isSuccess() {&#010;-        return error == null;&#010;-    }&#010;-&#010;-    public void setError(String error) {&#010;-        this.error = error;&#010;-    }&#010;-&#010;-    public String getError() {&#010;-        return error;&#010;-    }&#010;-&#010;-    public String getShortError() {&#010;-        return shortError;&#010;-    }&#010;-&#010;-    public void setShortError(String shortError) {&#010;-        this.shortError = shortError;&#010;-    }&#010;-&#010;-    public int getIndex() {&#010;-        return index;&#010;-    }&#010;-&#010;-    public void setIndex(int index) {&#010;-        this.index = index;&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java&#010;deleted file mode 100644&#010;index b46edab..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java&#010;+++ /dev/null&#010;@@ -1,234 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.net.URISyntaxException;&#010;-import java.util.Map;&#010;-&#010;-import org.apache.camel.StaticService;&#010;-&#010;-/**&#010;- * Runtime based CamelCatalog which are included in camel-core that can provided limit CamelCatalog capabilities&#010;- */&#010;-public interface RuntimeCamelCatalog extends StaticService {&#010;-&#010;-    /**&#010;-     * Returns the component information as JSon format.&#010;-     *&#010;-     * @param name the component name&#010;-     * @return component details in JSon&#010;-     */&#010;-    String componentJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the data format information as JSon format.&#010;-     *&#010;-     * @param name the data format name&#010;-     * @return data format details in JSon&#010;-     */&#010;-    String dataFormatJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the language information as JSon format.&#010;-     *&#010;-     * @param name the language name&#010;-     * @return language details in JSon&#010;-     */&#010;-    String languageJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the model information as JSon format.&#010;-     *&#010;-     * @param name the model name&#010;-     * @return model details in JSon&#010;-     */&#010;-    String modelJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Parses the endpoint uri and constructs a key/value properties of each option&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return properties as key value pairs of each endpoint option&#010;-     */&#010;-    Map&lt;String, String&gt; endpointProperties(String uri) throws URISyntaxException;&#010;-&#010;-    /**&#010;-     * Parses the endpoint uri and constructs a key/value properties of only the lenient properties (eg custom options)&#010;-     * &lt;p/&gt;&#010;-     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return properties as key value pairs of each lenient properties&#010;-     */&#010;-    Map&lt;String, String&gt; endpointLenientProperties(String uri) throws URISyntaxException;&#010;-&#010;-    /**&#010;-     * Validates the pattern whether its a valid time pattern.&#010;-     *&#010;-     * @param pattern  the pattern such as 5000, 5s, 5sec, 4min, 4m30s, 1h, etc.&#010;-     * @return &lt;tt&gt;true&lt;/tt&gt; if valid, &lt;tt&gt;false&lt;/tt&gt; if invalid&#010;-     */&#010;-    boolean validateTimePattern(String pattern);&#010;-&#010;-    /**&#010;-     * Validates the properties for the given scheme against component and endpoint&#010;-     *&#010;-     * @param scheme  the endpoint scheme&#010;-     * @param properties  the endpoint properties&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateProperties(String scheme, Map&lt;String, String&gt; properties);&#010;-&#010;-    /**&#010;-     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateEndpointProperties(String uri);&#010;-&#010;-    /**&#010;-     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;-     * &lt;p/&gt;&#010;-     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;-     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;-     * but in the uri because of using lenient properties.&#010;-     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties);&#010;-&#010;-    /**&#010;-     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;-     * &lt;p/&gt;&#010;-     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;-     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;-     * but in the uri because of using lenient properties.&#010;-     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;-     * @param consumerOnly whether the endpoint is only used as a consumer&#010;-     * @param producerOnly whether the endpoint is only used as a producer&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties, boolean consumerOnly, boolean producerOnly);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple expression.&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param simple  the simple expression&#010;-     * @return validation result&#010;-     * @deprecated use {@link #validateSimpleExpression(ClassLoader, String)}&#010;-     */&#010;-    @Deprecated&#010;-    SimpleValidationResult validateSimpleExpression(String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple expression.&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param simple  the simple expression&#010;-     * @return validation result&#010;-     */&#010;-    SimpleValidationResult validateSimpleExpression(ClassLoader classLoader, String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple predicate&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param simple  the simple predicate&#010;-     * @return validation result&#010;-     * @deprecated use {@link #validateSimplePredicate(ClassLoader, String)}&#010;-     */&#010;-    @Deprecated&#010;-    SimpleValidationResult validateSimplePredicate(String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple predicate&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param simple  the simple predicate&#010;-     * @return validation result&#010;-     */&#010;-    SimpleValidationResult validateSimplePredicate(ClassLoader classLoader, String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the language as a predicate&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param language the name of the language&#010;-     * @param text  the predicate text&#010;-     * @return validation result&#010;-     */&#010;-    LanguageValidationResult validateLanguagePredicate(ClassLoader classLoader, String language, String text);&#010;-&#010;-    /**&#010;-     * Parses and validates the language as an expression&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param language the name of the language&#010;-     * @param text  the expression text&#010;-     * @return validation result&#010;-     */&#010;-    LanguageValidationResult validateLanguageExpression(ClassLoader classLoader, String language, String text);&#010;-&#010;-    /**&#010;-     * Returns the component name from the given endpoint uri&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return the component name (aka scheme), or &lt;tt&gt;null&lt;/tt&gt; if not possible to determine&#010;-     */&#010;-    String endpointComponentName(String uri);&#010;-&#010;-    /**&#010;-     * Creates an endpoint uri in Java style from the information from the properties&#010;-     *&#010;-     * @param scheme the endpoint schema&#010;-     * @param properties the properties as key value pairs&#010;-     * @param encode whether to URL encode the returned uri or not&#010;-     * @return the constructed endpoint uri&#010;-     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;-     */&#010;-    String asEndpointUri(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;-&#010;-    /**&#010;-     * Creates an endpoint uri in XML style (eg escape &amp; as &amp;ampl;) from the information from the properties&#010;-     *&#010;-     * @param scheme the endpoint schema&#010;-     * @param properties the properties as key value pairs&#010;-     * @param encode whether to URL encode the returned uri or not&#010;-     * @return the constructed endpoint uri&#010;-     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;-     */&#010;-    String asEndpointUriXml(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java b/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&#010;deleted file mode 100644&#010;index 5c86f23..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&#010;+++ /dev/null&#010;@@ -1,32 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-/**&#010;- * To be backwards compatible, but favor using {@link LanguageValidationResult} instead.&#010;- */&#010;-public class SimpleValidationResult extends LanguageValidationResult {&#010;-&#010;-    public SimpleValidationResult(String text) {&#010;-        super(text);&#010;-    }&#010;-&#010;-    public String getSimple() {&#010;-        return getText();&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java b/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&#010;deleted file mode 100644&#010;index 057d372..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&#010;+++ /dev/null&#010;@@ -1,34 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.Set;&#010;-&#010;-/**&#010;- * Strategy to provide suggestions for unknown endpoint options&#010;- */&#010;-public interface SuggestionStrategy {&#010;-&#010;-    /**&#010;-     * Provides a list of valid option names for a did you mean function.&#010;-     *&#010;-     * @param names         valid names&#010;-     * @param unknownOption unknown option name&#010;-     * @return a list of suggested names (did you mean)&#010;-     */&#010;-    String[] suggestEndpointOptions(Set&lt;String&gt; names, String unknownOption);&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java b/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&#010;deleted file mode 100644&#010;index 4ed843a..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&#010;+++ /dev/null&#010;@@ -1,120 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.regex.Matcher;&#010;-import java.util.regex.Pattern;&#010;-&#010;-/**&#010;- * This class is a copy from camel-core so we can use it independent to validate uris with time patterns&#010;- */&#010;-public final class TimePatternConverter {&#010;-    private static final Pattern NUMBERS_ONLY_STRING_PATTERN = Pattern.compile(""^[-]?(\\d)+$"", Pattern.CASE_INSENSITIVE);&#010;-    private static final Pattern HOUR_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))h(our(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;-    private static final Pattern MINUTES_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))m(in(ute(s)?)?)?"", Pattern.CASE_INSENSITIVE);&#010;-    private static final Pattern SECONDS_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))s(ec(ond)?(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;-&#010;-    /**&#010;-     * Utility classes should not have a public constructor.&#010;-     */&#010;-    private TimePatternConverter() {&#010;-    }&#010;-&#010;-    public static long toMilliSeconds(String source) throws IllegalArgumentException {&#010;-        long milliseconds = 0;&#010;-        boolean foundFlag = false;&#010;-&#010;-        checkCorrectnessOfPattern(source);&#010;-        Matcher matcher;&#010;-&#010;-        matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;-        if (matcher.find()) {&#010;-            // Note: This will also be used for regular numeric strings.&#010;-            //       This String -&gt; long converter will be used for all strings.&#010;-            milliseconds = Long.valueOf(source);&#010;-        } else {&#010;-            matcher = createMatcher(HOUR_REGEX_PATTERN, source);&#010;-            if (matcher.find()) {&#010;-                milliseconds = milliseconds + (3600000 * Long.valueOf(matcher.group(1)));&#010;-                foundFlag = true;&#010;-            }&#010;-&#010;-            matcher = createMatcher(MINUTES_REGEX_PATTERN, source);&#010;-            if (matcher.find()) {&#010;-                long minutes = Long.valueOf(matcher.group(1));&#010;-                if ((minutes &gt; 59) &amp;&amp; foundFlag) {&#010;-                    throw new IllegalArgumentException(""Minutes should contain a valid value between 0 and 59: "" + source);&#010;-                }&#010;-                foundFlag = true;&#010;-                milliseconds = milliseconds + (60000 * minutes);&#010;-            }&#010;-&#010;-            matcher = createMatcher(SECONDS_REGEX_PATTERN, source);&#010;-            if (matcher.find()) {&#010;-                long seconds = Long.valueOf(matcher.group(1));&#010;-                if ((seconds &gt; 59) &amp;&amp; foundFlag) {&#010;-                    throw new IllegalArgumentException(""Seconds should contain a valid value between 0 and 59: "" + source);&#010;-                }&#010;-                foundFlag = true;&#010;-                milliseconds = milliseconds + (1000 * seconds);&#010;-            }&#010;-&#010;-            // No pattern matched... initiating fallback check and conversion (if required).&#010;-            // The source at this point may contain illegal values or special characters&#010;-            if (!foundFlag) {&#010;-                milliseconds = Long.valueOf(source);&#010;-            }&#010;-        }&#010;-&#010;-        return milliseconds;&#010;-    }&#010;-&#010;-    private static void checkCorrectnessOfPattern(String source) {&#010;-        //replace only numbers once&#010;-        Matcher matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;-        String replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        //replace hour string once&#010;-        matcher = createMatcher(HOUR_REGEX_PATTERN, replaceSource);&#010;-        if (matcher.find() &amp;&amp; matcher.find()) {&#010;-            throw new IllegalArgumentException(""Hours should not be specified more then once: "" + source);&#010;-        }&#010;-        replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        //replace minutes once&#010;-        matcher = createMatcher(MINUTES_REGEX_PATTERN, replaceSource);&#010;-        if (matcher.find() &amp;&amp; matcher.find()) {&#010;-            throw new IllegalArgumentException(""Minutes should not be specified more then once: "" + source);&#010;-        }&#010;-        replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        //replace seconds once&#010;-        matcher = createMatcher(SECONDS_REGEX_PATTERN, replaceSource);&#010;-        if (matcher.find() &amp;&amp; matcher.find()) {&#010;-            throw new IllegalArgumentException(""Seconds should not be specified more then once: "" + source);&#010;-        }&#010;-        replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        if (replaceSource.length() &gt; 0) {&#010;-            throw new IllegalArgumentException(""Illegal characters: "" + source);&#010;-        }&#010;-    }&#010;-&#010;-    private static Matcher createMatcher(Pattern pattern, String source) {&#010;-        return pattern.matcher(source);&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java b/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java&#010;deleted file mode 100644&#010;index ea1ecd5..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java&#010;+++ /dev/null&#010;@@ -1,392 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.io.UnsupportedEncodingException;&#010;-import java.net.URI;&#010;-import java.net.URISyntaxException;&#010;-import java.net.URLDecoder;&#010;-import java.net.URLEncoder;&#010;-import java.util.ArrayList;&#010;-import java.util.Iterator;&#010;-import java.util.LinkedHashMap;&#010;-import java.util.List;&#010;-import java.util.Map;&#010;-&#010;-/**&#010;- * Copied from org.apache.camel.util.URISupport&#010;- */&#010;-public final class URISupport {&#010;-&#010;-    public static final String RAW_TOKEN_START = ""RAW("";&#010;-    public static final String RAW_TOKEN_END = "")"";&#010;-&#010;-    private static final String CHARSET = ""UTF-8"";&#010;-&#010;-    private URISupport() {&#010;-        // Helper class&#010;-    }&#010;-&#010;-    /**&#010;-     * Normalizes the URI so unsafe characters is encoded&#010;-     *&#010;-     * @param uri the input uri&#010;-     * @return as URI instance&#010;-     * @throws URISyntaxException is thrown if syntax error in the input uri&#010;-     */&#010;-    public static URI normalizeUri(String uri) throws URISyntaxException {&#010;-        return new URI(UnsafeUriCharactersEncoder.encode(uri, true));&#010;-    }&#010;-&#010;-    public static Map&lt;String, Object&gt; extractProperties(Map&lt;String, Object&gt; properties, String optionPrefix) {&#010;-        Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;(properties.size());&#010;-&#010;-        for (Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; it = properties.entrySet().iterator(); it.hasNext();) {&#010;-            Map.Entry&lt;String, Object&gt; entry = it.next();&#010;-            String name = entry.getKey();&#010;-            if (name.startsWith(optionPrefix)) {&#010;-                Object value = properties.get(name);&#010;-                name = name.substring(optionPrefix.length());&#010;-                rc.put(name, value);&#010;-                it.remove();&#010;-            }&#010;-        }&#010;-&#010;-        return rc;&#010;-    }&#010;-&#010;-    /**&#010;-     * Strips the query parameters from the uri&#010;-     *&#010;-     * @param uri  the uri&#010;-     * @return the uri without the query parameter&#010;-     */&#010;-    public static String stripQuery(String uri) {&#010;-        int idx = uri.indexOf('?');&#010;-        if (idx &gt; -1) {&#010;-            uri = uri.substring(0, idx);&#010;-        }&#010;-        return uri;&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the query parameters of the uri (eg the query part).&#010;-     *&#010;-     * @param uri the uri&#010;-     * @return the parameters, or an empty map if no parameters (eg never null)&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     */&#010;-    public static Map&lt;String, Object&gt; parseParameters(URI uri) throws URISyntaxException {&#010;-        String query = uri.getQuery();&#010;-        if (query == null) {&#010;-            String schemeSpecificPart = uri.getSchemeSpecificPart();&#010;-            int idx = schemeSpecificPart.indexOf('?');&#010;-            if (idx &lt; 0) {&#010;-                // return an empty map&#010;-                return new LinkedHashMap&lt;String, Object&gt;(0);&#010;-            } else {&#010;-                query = schemeSpecificPart.substring(idx + 1);&#010;-            }&#010;-        } else {&#010;-            query = stripPrefix(query, ""?"");&#010;-        }&#010;-        return parseQuery(query);&#010;-    }&#010;-&#010;-    /**&#010;-     * Strips the prefix from the value.&#010;-     * &lt;p/&gt;&#010;-     * Returns the value as-is if not starting with the prefix.&#010;-     *&#010;-     * @param value  the value&#010;-     * @param prefix the prefix to remove from value&#010;-     * @return the value without the prefix&#010;-     */&#010;-    public static String stripPrefix(String value, String prefix) {&#010;-        if (value != null &amp;&amp; value.startsWith(prefix)) {&#010;-            return value.substring(prefix.length());&#010;-        }&#010;-        return value;&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the query part of the uri (eg the parameters).&#010;-     * &lt;p/&gt;&#010;-     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;-     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;-     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;-     *&#010;-     * @param uri the uri&#010;-     * @return the parameters, or an empty map if no parameters (eg never null)&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     * @see #RAW_TOKEN_START&#010;-     * @see #RAW_TOKEN_END&#010;-     */&#010;-    public static Map&lt;String, Object&gt; parseQuery(String uri) throws URISyntaxException {&#010;-        return parseQuery(uri, false);&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the query part of the uri (eg the parameters).&#010;-     * &lt;p/&gt;&#010;-     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;-     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;-     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;-     *&#010;-     * @param uri the uri&#010;-     * @param useRaw whether to force using raw values&#010;-     * @return the parameters, or an empty map if no parameters (eg never null)&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     * @see #RAW_TOKEN_START&#010;-     * @see #RAW_TOKEN_END&#010;-     */&#010;-    public static Map&lt;String, Object&gt; parseQuery(String uri, boolean useRaw) throws URISyntaxException {&#010;-        // must check for trailing &amp; as the uri.split(""&amp;"") will ignore those&#010;-        if (uri != null &amp;&amp; uri.endsWith(""&amp;"")) {&#010;-            throw new URISyntaxException(uri, ""Invalid uri syntax: Trailing &amp; marker found. ""&#010;-                    + ""Check the uri and remove the trailing &amp; marker."");&#010;-        }&#010;-&#010;-        if (isEmpty(uri)) {&#010;-            // return an empty map&#010;-            return new LinkedHashMap&lt;String, Object&gt;(0);&#010;-        }&#010;-&#010;-        // need to parse the uri query parameters manually as we cannot rely on splitting by &amp;,&#010;-        // as &amp; can be used in a parameter value as well.&#010;-&#010;-        try {&#010;-            // use a linked map so the parameters is in the same order&#010;-            Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;();&#010;-&#010;-            boolean isKey = true;&#010;-            boolean isValue = false;&#010;-            boolean isRaw = false;&#010;-            StringBuilder key = new StringBuilder();&#010;-            StringBuilder value = new StringBuilder();&#010;-&#010;-            // parse the uri parameters char by char&#010;-            for (int i = 0; i &lt; uri.length(); i++) {&#010;-                // current char&#010;-                char ch = uri.charAt(i);&#010;-                // look ahead of the next char&#010;-                char next;&#010;-                if (i &lt;= uri.length() - 2) {&#010;-                    next = uri.charAt(i + 1);&#010;-                } else {&#010;-                    next = '\u0000';&#010;-                }&#010;-&#010;-                // are we a raw value&#010;-                isRaw = value.toString().startsWith(RAW_TOKEN_START);&#010;-&#010;-                // if we are in raw mode, then we keep adding until we hit the end marker&#010;-                if (isRaw) {&#010;-                    if (isKey) {&#010;-                        key.append(ch);&#010;-                    } else if (isValue) {&#010;-                        value.append(ch);&#010;-                    }&#010;-&#010;-                    // we only end the raw marker if its )&amp; or at the end of the value&#010;-&#010;-                    boolean end = ch == RAW_TOKEN_END.charAt(0) &amp;&amp; (next == '&amp;' || next == '\u0000');&#010;-                    if (end) {&#010;-                        // raw value end, so add that as a parameter, and reset flags&#010;-                        addParameter(key.toString(), value.toString(), rc, useRaw || isRaw);&#010;-                        key.setLength(0);&#010;-                        value.setLength(0);&#010;-                        isKey = true;&#010;-                        isValue = false;&#010;-                        isRaw = false;&#010;-                        // skip to next as we are in raw mode and have already added the value&#010;-                        i++;&#010;-                    }&#010;-                    continue;&#010;-                }&#010;-&#010;-                // if its a key and there is a = sign then the key ends and we are in value mode&#010;-                if (isKey &amp;&amp; ch == '=') {&#010;-                    isKey = false;&#010;-                    isValue = true;&#010;-                    isRaw = false;&#010;-                    continue;&#010;-                }&#010;-&#010;-                // the &amp; denote parameter is ended&#010;-                if (ch == '&amp;') {&#010;-                    // parameter is ended, as we hit &amp; separator&#010;-                    String aKey = key.toString();&#010;-                    // the key may be a placeholder of options which we then do not know what is&#010;-                    boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;-                    if (validKey) {&#010;-                        addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;-                    }&#010;-                    key.setLength(0);&#010;-                    value.setLength(0);&#010;-                    isKey = true;&#010;-                    isValue = false;&#010;-                    isRaw = false;&#010;-                    continue;&#010;-                }&#010;-&#010;-                // regular char so add it to the key or value&#010;-                if (isKey) {&#010;-                    key.append(ch);&#010;-                } else if (isValue) {&#010;-                    value.append(ch);&#010;-                }&#010;-            }&#010;-&#010;-            // any left over parameters, then add that&#010;-            if (key.length() &gt; 0) {&#010;-                String aKey = key.toString();&#010;-                // the key may be a placeholder of options which we then do not know what is&#010;-                boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;-                if (validKey) {&#010;-                    addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;-                }&#010;-            }&#010;-&#010;-            return rc;&#010;-&#010;-        } catch (UnsupportedEncodingException e) {&#010;-            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;-            se.initCause(e);&#010;-            throw se;&#010;-        }&#010;-    }&#010;-&#010;-    @SuppressWarnings(""unchecked"")&#010;-    private static void addParameter(String name, String value, Map&lt;String, Object&gt; map, boolean isRaw) throws UnsupportedEncodingException {&#010;-        name = URLDecoder.decode(name, CHARSET);&#010;-        if (!isRaw) {&#010;-            // need to replace % with %25&#010;-            value = URLDecoder.decode(value.replaceAll(""%"", ""%25""), CHARSET);&#010;-        }&#010;-&#010;-        // does the key already exist?&#010;-        if (map.containsKey(name)) {&#010;-            // yes it does, so make sure we can support multiple values, but using a list&#010;-            // to hold the multiple values&#010;-            Object existing = map.get(name);&#010;-            List&lt;String&gt; list;&#010;-            if (existing instanceof List) {&#010;-                list = (List&lt;String&gt;) existing;&#010;-            } else {&#010;-                // create a new list to hold the multiple values&#010;-                list = new ArrayList&lt;String&gt;();&#010;-                String s = existing != null ? existing.toString() : null;&#010;-                if (s != null) {&#010;-                    list.add(s);&#010;-                }&#010;-            }&#010;-            list.add(value);&#010;-            map.put(name, list);&#010;-        } else {&#010;-            map.put(name, value);&#010;-        }&#010;-    }&#010;-&#010;-    /**&#010;-     * Assembles a query from the given map.&#010;-     *&#010;-     * @param options  the map with the options (eg key/value pairs)&#010;-     * @param ampersand to use &amp; for Java code, and &amp;amp; for XML&#010;-     * @return a query string with &lt;tt&gt;key1=value&amp;key2=value2&amp;...&lt;/tt&gt;, or an empty string if there is no options.&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     */&#010;-    public static String createQueryString(Map&lt;String, String&gt; options, String ampersand, boolean encode) throws URISyntaxException {&#010;-        try {&#010;-            if (options.size() &gt; 0) {&#010;-                StringBuilder rc = new StringBuilder();&#010;-                boolean first = true;&#010;-                for (Object o : options.keySet()) {&#010;-                    if (first) {&#010;-                        first = false;&#010;-                    } else {&#010;-                        rc.append(ampersand);&#010;-                    }&#010;-&#010;-                    String key = (String) o;&#010;-                    Object value = options.get(key);&#010;-&#010;-                    // use the value as a String&#010;-                    String s = value != null ? value.toString() : null;&#010;-                    appendQueryStringParameter(key, s, rc, encode);&#010;-                }&#010;-                return rc.toString();&#010;-            } else {&#010;-                return """";&#010;-            }&#010;-        } catch (UnsupportedEncodingException e) {&#010;-            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;-            se.initCause(e);&#010;-            throw se;&#010;-        }&#010;-    }&#010;-&#010;-    private static void appendQueryStringParameter(String key, String value, StringBuilder rc, boolean encode) throws UnsupportedEncodingException {&#010;-        if (encode) {&#010;-            rc.append(URLEncoder.encode(key, CHARSET));&#010;-        } else {&#010;-            rc.append(key);&#010;-        }&#010;-        // only append if value is not null&#010;-        if (value != null) {&#010;-            rc.append(""="");&#010;-            if (value.startsWith(RAW_TOKEN_START) &amp;&amp; value.endsWith(RAW_TOKEN_END)) {&#010;-                // do not encode RAW parameters&#010;-                rc.append(value);&#010;-            } else {&#010;-                if (encode) {&#010;-                    rc.append(URLEncoder.encode(value, CHARSET));&#010;-                } else {&#010;-                    rc.append(value);&#010;-                }&#010;-            }&#010;-        }&#010;-    }&#010;-&#010;-    /**&#010;-     * Tests whether the value is &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;-     *&#010;-     * @param value  the value, if its a String it will be tested for text length as well&#010;-     * @return true if empty&#010;-     */&#010;-    public static boolean isEmpty(Object value) {&#010;-        return !isNotEmpty(value);&#010;-    }&#010;-&#010;-    /**&#010;-     * Tests whether the value is &lt;b&gt;not&lt;/b&gt; &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;-     *&#010;-     * @param value  the value, if its a String it will be tested for text length as well&#010;-     * @return true if &lt;b&gt;not&lt;/b&gt; empty&#010;-     */&#010;-    public static boolean isNotEmpty(Object value) {&#010;-        if (value == null) {&#010;-            return false;&#010;-        } else if (value instanceof String) {&#010;-            String text = (String) value;&#010;-            return text.trim().length() &gt; 0;&#010;-        } else {&#010;-            return true;&#010;-        }&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java b/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&#010;deleted file mode 100644&#010;index 563bac2..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&#010;+++ /dev/null&#010;@@ -1,206 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.ArrayList;&#010;-import java.util.BitSet;&#010;-import java.util.List;&#010;-import java.util.regex.Matcher;&#010;-import java.util.regex.Pattern;&#010;-&#010;-/**&#010;- * Encoder for unsafe URI characters.&#010;- * &lt;p/&gt;&#010;- * A good source for details is &lt;a href=""http://en.wikipedia.org/wiki/Url_encode""&gt;wikipedia url encode&lt;/a&gt; article.&#010;- */&#010;-public final class UnsafeUriCharactersEncoder {&#010;-    private static BitSet unsafeCharactersRfc1738;&#010;-    private static BitSet unsafeCharactersHttp;&#010;-    private static final char[] HEX_DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C',&#010;-        'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'};&#010;-    private static final Pattern RAW_PATTERN = Pattern.compile(""RAW\\([^\\)]+\\)"");&#010;-&#010;-    static {&#010;-        unsafeCharactersRfc1738 = new BitSet(256);&#010;-        unsafeCharactersRfc1738.set(' ');&#010;-        unsafeCharactersRfc1738.set('""');&#010;-        unsafeCharactersRfc1738.set('&lt;');&#010;-        unsafeCharactersRfc1738.set('&gt;');&#010;-        unsafeCharactersRfc1738.set('#');&#010;-        unsafeCharactersRfc1738.set('%');&#010;-        unsafeCharactersRfc1738.set('{');&#010;-        unsafeCharactersRfc1738.set('}');&#010;-        unsafeCharactersRfc1738.set('|');&#010;-        unsafeCharactersRfc1738.set('\\');&#010;-        unsafeCharactersRfc1738.set('^');&#010;-        unsafeCharactersRfc1738.set('~');&#010;-        unsafeCharactersRfc1738.set('[');&#010;-        unsafeCharactersRfc1738.set(']');&#010;-        unsafeCharactersRfc1738.set('`');&#010;-    }&#010;-&#010;-    static {&#010;-        unsafeCharactersHttp = new BitSet(256);&#010;-        unsafeCharactersHttp.set(' ');&#010;-        unsafeCharactersHttp.set('""');&#010;-        unsafeCharactersHttp.set('&lt;');&#010;-        unsafeCharactersHttp.set('&gt;');&#010;-        unsafeCharactersHttp.set('#');&#010;-        unsafeCharactersHttp.set('%');&#010;-        unsafeCharactersHttp.set('{');&#010;-        unsafeCharactersHttp.set('}');&#010;-        unsafeCharactersHttp.set('|');&#010;-        unsafeCharactersHttp.set('\\');&#010;-        unsafeCharactersHttp.set('^');&#010;-        unsafeCharactersHttp.set('~');&#010;-        unsafeCharactersHttp.set('`');&#010;-    }&#010;-&#010;-    private UnsafeUriCharactersEncoder() {&#010;-        // util class&#010;-    }&#010;-&#010;-    public static String encode(String s) {&#010;-        return encode(s, unsafeCharactersRfc1738);&#010;-    }&#010;-&#010;-    public static String encodeHttpURI(String s) {&#010;-        return encode(s, unsafeCharactersHttp);&#010;-    }&#010;-&#010;-    public static String encode(String s, BitSet unsafeCharacters) {&#010;-        return encode(s, unsafeCharacters, false);&#010;-    }&#010;-&#010;-    public static String encode(String s, boolean checkRaw) {&#010;-        return encode(s, unsafeCharactersRfc1738, checkRaw);&#010;-    }&#010;-&#010;-    public static String encodeHttpURI(String s, boolean checkRaw) {&#010;-        return encode(s, unsafeCharactersHttp, checkRaw);&#010;-    }&#010;-&#010;-    private static List&lt;Pair&gt; checkRAW(String s) {&#010;-        Matcher matcher = RAW_PATTERN.matcher(s);&#010;-        List&lt;Pair&gt; answer = new ArrayList&lt;Pair&gt;();&#010;-        // Check all occurrences&#010;-        while (matcher.find()) {&#010;-            answer.add(new Pair(matcher.start(), matcher.end()));&#010;-        }&#010;-        return answer;&#010;-    }&#010;-&#010;-    private static boolean isRaw(int index, List&lt;Pair&gt; pairs) {&#010;-        for (Pair pair : pairs) {&#010;-            if (index &lt; pair.left) {&#010;-                return false;&#010;-            } else {&#010;-                if (index &gt;= pair.left) {&#010;-                    if (index &lt;= pair.right) {&#010;-                        return true;&#010;-                    } else {&#010;-                        continue;&#010;-                    }&#010;-                }&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    private static class Pair {&#010;-        int left;&#010;-        int right;&#010;-&#010;-        Pair(int left, int right) {&#010;-            this.left = left;&#010;-            this.right = right;&#010;-        }&#010;-    }&#010;-&#010;-    // Just skip the encode for isRAW part&#010;-    public static String encode(String s, BitSet unsafeCharacters, boolean checkRaw) {&#010;-        List&lt;Pair&gt; rawPairs;&#010;-        if (checkRaw) {&#010;-            rawPairs = checkRAW(s);&#010;-        } else {&#010;-            rawPairs = new ArrayList&lt;Pair&gt;();&#010;-        }&#010;-&#010;-        int n = s == null ? 0 : s.length();&#010;-        if (n == 0) {&#010;-            return s;&#010;-        }&#010;-&#010;-        // First check whether we actually need to encode&#010;-        char chars[] = s.toCharArray();&#010;-        for (int i = 0;;) {&#010;-            // just deal with the ascii character&#010;-            if (chars[i] &gt; 0 &amp;&amp; chars[i] &lt; 128) {&#010;-                if (unsafeCharacters.get(chars[i])) {&#010;-                    break;&#010;-                }&#010;-            }&#010;-            if (++i &gt;= chars.length) {&#010;-                return s;&#010;-            }&#010;-        }&#010;-&#010;-        // okay there are some unsafe characters so we do need to encode&#010;-        // see details at: http://en.wikipedia.org/wiki/Url_encode&#010;-        StringBuilder sb = new StringBuilder();&#010;-        for (int i = 0; i &lt; chars.length; i++) {&#010;-            char ch = chars[i];&#010;-            if (ch &gt; 0 &amp;&amp; ch &lt; 128 &amp;&amp; unsafeCharacters.get(ch)) {&#010;-                // special for % sign as it may be a decimal encoded value&#010;-                if (ch == '%') {&#010;-                    char next = i + 1 &lt; chars.length ? chars[i + 1] : ' ';&#010;-                    char next2 = i + 2 &lt; chars.length ? chars[i + 2] : ' ';&#010;-&#010;-                    if (isHexDigit(next) &amp;&amp; isHexDigit(next2) &amp;&amp; !isRaw(i, rawPairs)) {&#010;-                        // its already encoded (decimal encoded) so just append as is&#010;-                        sb.append(ch);&#010;-                    } else {&#010;-                        // must escape then, as its an unsafe character&#010;-                        appendEscape(sb, (byte) ch);&#010;-                    }&#010;-                } else {&#010;-                    // must escape then, as its an unsafe character&#010;-                    appendEscape(sb, (byte) ch);&#010;-                }&#010;-            } else {&#010;-                sb.append(ch);&#010;-            }&#010;-        }&#010;-        return sb.toString();&#010;-    }&#010;-&#010;-    private static void appendEscape(StringBuilder sb, byte b) {&#010;-        sb.append('%');&#010;-        sb.append(HEX_DIGITS[(b &gt;&gt; 4) &amp; 0x0f]);&#010;-        sb.append(HEX_DIGITS[(b &gt;&gt; 0) &amp; 0x0f]);&#010;-    }&#010;-&#010;-    private static boolean isHexDigit(char ch) {&#010;-        for (char hex : HEX_DIGITS) {&#010;-            if (hex == ch) {&#010;-                return true;&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/package.html&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/package.html b/camel-core/src/main/java/org/apache/camel/catalog/package.html&#010;deleted file mode 100644&#010;index 98786d1..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/package.html&#010;+++ /dev/null&#010;@@ -1,25 +0,0 @@&#010;-&lt;!--&#010;-    Licensed to the Apache Software Foundation (ASF) under one or more&#010;-    contributor license agreements.  See the NOTICE file distributed with&#010;-    this work for additional information regarding copyright ownership.&#010;-    The ASF licenses this file to You under the Apache License, Version 2.0&#010;-    (the ""License""); you may not use this file except in compliance with&#010;-    the License.  You may obtain a copy of the License at&#010;-&#010;-    http://www.apache.org/licenses/LICENSE-2.0&#010;-&#010;-    Unless required by applicable law or agreed to in writing, software&#010;-    distributed under the License is distributed on an ""AS IS"" BASIS,&#010;-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;-    See the License for the specific language governing permissions and&#010;-    limitations under the License.&#010;---&gt;&#010;-&lt;html&gt;&#010;-&lt;head&gt;&#010;-&lt;/head&gt;&#010;-&lt;body&gt;&#010;-&#010;-Camel Catalog&#010;-&#010;-&lt;/body&gt;&#010;-&lt;/html&gt;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java b/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;index 5d19e0d..4013e5f 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;@@ -22,12 +22,12 @@ import java.util.Map;&#010; import org.apache.camel.Component;&#010; import org.apache.camel.ComponentVerifier;&#010; import org.apache.camel.VerifiableComponent;&#010;-import org.apache.camel.catalog.JSonSchemaHelper;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010; import org.apache.camel.impl.verifier.CatalogVerifierCustomizer;&#010; import org.apache.camel.impl.verifier.DefaultComponentVerifier;&#010; import org.apache.camel.impl.verifier.ResultBuilder;&#010; import org.apache.camel.impl.verifier.ResultErrorBuilder;&#010;+import org.apache.camel.runtimecatalog.JSonSchemaHelper;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.RestConsumerFactory;&#010; import org.apache.camel.spi.RestProducerFactory;&#010; import org.apache.camel.util.ObjectHelper;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;index c85ce8c..b53efc8 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;@@ -26,7 +26,6 @@ import java.util.Collections;&#010; import java.util.Comparator;&#010; import java.util.Date;&#010; import java.util.HashMap;&#010;-import java.util.HashSet;&#010; import java.util.Iterator;&#010; import java.util.LinkedHashMap;&#010; import java.util.LinkedHashSet;&#010;@@ -87,8 +86,6 @@ import org.apache.camel.api.management.mbean.ManagedRouteMBean;&#010; import org.apache.camel.builder.DefaultFluentProducerTemplate;&#010; import org.apache.camel.builder.ErrorHandlerBuilder;&#010; import org.apache.camel.builder.ErrorHandlerBuilderSupport;&#010;-import org.apache.camel.catalog.DefaultRuntimeCamelCatalog;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010; import org.apache.camel.component.properties.PropertiesComponent;&#010; import org.apache.camel.impl.converter.BaseTypeConverterRegistry;&#010; import org.apache.camel.impl.converter.DefaultTypeConverter;&#010;@@ -121,6 +118,8 @@ import org.apache.camel.processor.interceptor.Delayer;&#010; import org.apache.camel.processor.interceptor.HandleFault;&#010; import org.apache.camel.processor.interceptor.StreamCaching;&#010; import org.apache.camel.processor.interceptor.Tracer;&#010;+import org.apache.camel.runtimecatalog.DefaultRuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.AsyncProcessorAwaitManager;&#010; import org.apache.camel.spi.CamelContextNameStrategy;&#010; import org.apache.camel.spi.ClassResolver;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java b/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;index b9d9998..f05cdb1 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;@@ -25,8 +25,8 @@ import org.apache.camel.CamelContext;&#010; import org.apache.camel.ComponentVerifier;&#010; import org.apache.camel.NoSuchOptionException;&#010; import org.apache.camel.TypeConverter;&#010;-import org.apache.camel.catalog.EndpointValidationResult;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.EndpointValidationResult;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.util.CamelContextHelper;&#010; import org.apache.camel.util.EndpointHelper;&#010; import org.apache.camel.util.IntrospectionSupport;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;index a09ff7d..9a70390 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;@@ -46,12 +46,9 @@ import org.apache.camel.StartupListener;&#010; import org.apache.camel.TimerListener;&#010; import org.apache.camel.VetoCamelContextStartException;&#010; import org.apache.camel.api.management.PerformanceCounter;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010; import org.apache.camel.impl.ConsumerCache;&#010; import org.apache.camel.impl.DefaultCamelContext;&#010; import org.apache.camel.impl.DefaultEndpointRegistry;&#010;-import org.apache.camel.impl.DefaultTransformerRegistry;&#010;-import org.apache.camel.impl.DefaultValidatorRegistry;&#010; import org.apache.camel.impl.EventDrivenConsumerRoute;&#010; import org.apache.camel.impl.ProducerCache;&#010; import org.apache.camel.impl.ThrottlingExceptionRoutePolicy;&#010;@@ -89,6 +86,7 @@ import org.apache.camel.processor.CamelInternalProcessor;&#010; import org.apache.camel.processor.interceptor.BacklogDebugger;&#010; import org.apache.camel.processor.interceptor.BacklogTracer;&#010; import org.apache.camel.processor.interceptor.Tracer;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.AsyncProcessorAwaitManager;&#010; import org.apache.camel.spi.DataFormat;&#010; import org.apache.camel.spi.EventNotifier;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;index 20d3f28..6a99656 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;@@ -19,7 +19,7 @@ package org.apache.camel.management.mbean;&#010; import org.apache.camel.CamelContext;&#010; import org.apache.camel.api.management.ManagedResource;&#010; import org.apache.camel.api.management.mbean.ManagedRuntimeCamelCatalogMBean;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.ManagementStrategy;&#010; &#010; /**&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C6a3e7fae5cba4f918aede10c3ae6ef26%40git.apache.org%3E,2017-04-14 10:52,commits,4.0,326.0,  [5/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
16,322.0,davscl...@apache.org,"Repository: camel&#010;Updated Branches:&#010;  refs/heads/master d72696455 -&gt; 6b42a3534&#010;&#010;&#010;Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/6b42a353&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/6b42a353&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/6b42a353&#010;&#010;Branch: refs/heads/master&#010;Commit: 6b42a3534120f58180e6194e6bf4f1a284707abc&#010;Parents: c66be7a&#010;Author: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Authored: Fri Apr 14 12:17:14 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:52:40 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; platforms/camel-catalog/pom.xml | 40 ++++++++++++++++++++++++++++++++++--&#010; 1 file changed, 38 insertions(+), 2 deletions(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/6b42a353/platforms/camel-catalog/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/platforms/camel-catalog/pom.xml b/platforms/camel-catalog/pom.xml&#010;index 2be82e0..6c71fcb 100644&#010;--- a/platforms/camel-catalog/pom.xml&#010;+++ b/platforms/camel-catalog/pom.xml&#010;@@ -92,7 +92,7 @@&#010;         &lt;executions&gt;&#010;           &lt;execution&gt;&#010;             &lt;id&gt;copy-resources&lt;/id&gt;&#010;-            &lt;phase&gt;process-sources&lt;/phase&gt;&#010;+            &lt;phase&gt;generate-sources&lt;/phase&gt;&#010;             &lt;goals&gt;&#010;               &lt;goal&gt;copy-resources&lt;/goal&gt;&#010;             &lt;/goals&gt;&#010;@@ -101,7 +101,7 @@&#010;               &lt;overwrite&gt;true&lt;/overwrite&gt;&#010;               &lt;resources&gt;&#010;                 &lt;resource&gt;&#010;-                  &lt;directory&gt;../../camel-core/src/main/java/org/apache/camel/catalog&lt;/directory&gt;&#010;+                  &lt;directory&gt;../../camel-core/src/main/java/org/apache/camel/runtimecatalog&lt;/directory&gt;&#010;                   &lt;!-- the following files are maintained in camel-core and not here,&#010;so they are copied over --&gt;&#010;                   &lt;includes&gt;&#010;                     &lt;include&gt;AbstractCamelCatalog.java&lt;/include&gt;&#010;@@ -123,6 +123,42 @@&#010;           &lt;/execution&gt;&#010;         &lt;/executions&gt;&#010;       &lt;/plugin&gt;&#010;+      &lt;!-- rename runtimecatalog to catalog which is the package name we use here --&gt;&#010;+      &lt;plugin&gt;&#010;+        &lt;groupId&gt;com.google.code.maven-replacer-plugin&lt;/groupId&gt;&#010;+        &lt;artifactId&gt;replacer&lt;/artifactId&gt;&#010;+        &lt;version&gt;1.5.3&lt;/version&gt;&#010;+        &lt;executions&gt;&#010;+          &lt;execution&gt;&#010;+            &lt;phase&gt;process-sources&lt;/phase&gt;&#010;+            &lt;goals&gt;&#010;+              &lt;goal&gt;replace&lt;/goal&gt;&#010;+            &lt;/goals&gt;&#010;+          &lt;/execution&gt;&#010;+        &lt;/executions&gt;&#010;+        &lt;configuration&gt;&#010;+          &lt;includes&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/AbstractCamelCatalog.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/CatalogHelper.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/CollectionStringBuffer.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/URISupport.java&lt;/include&gt;&#010;+          &lt;/includes&gt;&#010;+          &lt;replacements&gt;&#010;+            &lt;replacement&gt;&#010;+              &lt;token&gt;org.apache.camel.runtimecatalog&lt;/token&gt;&#010;+              &lt;value&gt;org.apache.camel.catalog&lt;/value&gt;&#010;+            &lt;/replacement&gt;&#010;+          &lt;/replacements&gt;&#010;+        &lt;/configuration&gt;&#010;+      &lt;/plugin&gt;&#010; &#010;       &lt;!-- generate and include all components in the catalog --&gt;&#010;       &lt;plugin&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cde5de0a2e2ca40e6bcaa03835723a40e%40git.apache.org%3E,2017-04-14 10:52,commits,5.0,322.0,[1/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
17,323.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;b/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;new file mode 100644&#010;index 0000000..309fb8e&#010;--- /dev/null&#010;+++ b/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;@@ -0,0 +1,104 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.net.URISyntaxException;&#010;+import java.util.HashMap;&#010;+import java.util.Map;&#010;+&#010;+import org.junit.Before;&#010;+import org.junit.Test;&#010;+&#010;+import static org.easymock.EasyMock.expect;&#010;+import static org.easymock.EasyMock.mock;&#010;+import static org.easymock.EasyMock.replay;&#010;+import static org.junit.Assert.assertEquals;&#010;+&#010;+public class AbstractCamelCatalogTest {&#010;+&#010;+    AbstractCamelCatalog catalog = new AbstractCamelCatalog() {&#010;+    };&#010;+&#010;+    JSonSchemaResolver resolver;&#010;+&#010;+    @Before&#010;+    public void setupMockCatalog() {&#010;+        resolver = mock(JSonSchemaResolver.class);&#010;+&#010;+        catalog.setJSonSchemaResolver(resolver);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void shouldConstructEndpointUris() throws URISyntaxException {&#010;+        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;+            + ""  \""component\"": {\n""//&#010;+            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;+            + ""  }\n""//&#010;+            + ""}"");&#010;+&#010;+        replay(resolver);&#010;+&#010;+        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;+        properties.put(""param1"", ""value1"");&#010;+        properties.put(""param2"", ""value2"");&#010;+        properties.put(""param3"", ""value3"");&#010;+&#010;+        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;+&#010;+        assertEquals(""comp:value1:value2?param3=value3"", endpointUri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void shouldConstructEndpointUrisWithPropertyPlaceholders() throws URISyntaxException&#010;{&#010;+        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;+            + ""  \""component\"": {\n""//&#010;+            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;+            + ""  }\n""//&#010;+            + ""}"");&#010;+&#010;+        replay(resolver);&#010;+&#010;+        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;+        properties.put(""param1"", ""{{prop1}}"");&#010;+        properties.put(""param2"", ""{{prop2}}"");&#010;+        properties.put(""param3"", ""{{prop3}}"");&#010;+&#010;+        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;+&#010;+        assertEquals(""comp:{{prop1}}:{{prop2}}?param3={{prop3}}"", endpointUri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void shouldConstructEndpointUrisWhenValuesContainTokens() throws URISyntaxException&#010;{&#010;+        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;+            + ""  \""component\"": {\n""//&#010;+            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;+            + ""  }\n""//&#010;+            + ""}"");&#010;+&#010;+        replay(resolver);&#010;+&#010;+        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;+        properties.put(""param1"", ""{value1}"");&#010;+        properties.put(""param2"", ""/value2/"");&#010;+        properties.put(""param3"", ""/value3/{param}"");&#010;+&#010;+        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;+&#010;+        assertEquals(""comp:{value1}:/value2/?param3=/value3/{param}"", endpointUri);&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;b/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;new file mode 100644&#010;index 0000000..dfdd5c5&#010;--- /dev/null&#010;+++ b/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;@@ -0,0 +1,393 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.HashMap;&#010;+import java.util.Map;&#010;+&#010;+import org.apache.camel.impl.DefaultCamelContext;&#010;+import org.junit.BeforeClass;&#010;+import org.junit.Test;&#010;+import org.slf4j.Logger;&#010;+import org.slf4j.LoggerFactory;&#010;+&#010;+import static org.junit.Assert.assertEquals;&#010;+import static org.junit.Assert.assertFalse;&#010;+import static org.junit.Assert.assertNotNull;&#010;+import static org.junit.Assert.assertTrue;&#010;+&#010;+public class RuntimeCamelCatalogTest {&#010;+&#010;+    static RuntimeCamelCatalog catalog;&#010;+&#010;+    private static final Logger LOG = LoggerFactory.getLogger(RuntimeCamelCatalogTest.class);&#010;+&#010;+    @BeforeClass&#010;+    public static void createCamelCatalog() {&#010;+        catalog = new DefaultRuntimeCamelCatalog(new DefaultCamelContext());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testFromCamelContext() throws Exception {&#010;+        String schema = new DefaultCamelContext().getRuntimeCamelCatalog().modelJSonSchema(""choice"");&#010;+        assertNotNull(schema);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testJsonSchema() throws Exception {&#010;+        String schema = catalog.modelJSonSchema(""aggregate"");&#010;+        assertNotNull(schema);&#010;+&#010;+        // lets make it possible to find bean/method using both names&#010;+        schema = catalog.modelJSonSchema(""method"");&#010;+        assertNotNull(schema);&#010;+        schema = catalog.modelJSonSchema(""bean"");&#010;+        assertNotNull(schema);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriMapFile() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""directoryName"", ""src/data/inbox"");&#010;+        map.put(""noop"", ""true"");&#010;+        map.put(""delay"", ""5000"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""file"", map, true);&#010;+        assertEquals(""file:src/data/inbox?delay=5000&amp;noop=true"", uri);&#010;+&#010;+        String uri2 = catalog.asEndpointUriXml(""file"", map, true);&#010;+        assertEquals(""file:src/data/inbox?delay=5000&amp;amp;noop=true"", uri2);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriTimer() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""timerName"", ""foo"");&#010;+        map.put(""period"", ""5000"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;+        assertEquals(""timer:foo?period=5000"", uri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriPropertiesPlaceholders() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""timerName"", ""foo"");&#010;+        map.put(""period"", ""{{howoften}}"");&#010;+        map.put(""repeatCount"", ""5"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;+        assertEquals(""timer:foo?period=%7B%7Bhowoften%7D%7D&amp;repeatCount=5"", uri);&#010;+&#010;+        uri = catalog.asEndpointUri(""timer"", map, false);&#010;+        assertEquals(""timer:foo?period={{howoften}}&amp;repeatCount=5"", uri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriBeanLookup() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""resourceUri"", ""foo.xslt"");&#010;+        map.put(""converter"", ""#myConverter"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""xslt"", map, true);&#010;+        assertEquals(""xslt:foo.xslt?converter=%23myConverter"", uri);&#010;+&#010;+        uri = catalog.asEndpointUri(""xslt"", map, false);&#010;+        assertEquals(""xslt:foo.xslt?converter=#myConverter"", uri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testEndpointPropertiesPlaceholders() throws Exception {&#010;+        Map&lt;String, String&gt; map = catalog.endpointProperties(""timer:foo?period={{howoften}}&amp;repeatCount=5"");&#010;+        assertNotNull(map);&#010;+        assertEquals(3, map.size());&#010;+&#010;+        assertEquals(""foo"", map.get(""timerName""));&#010;+        assertEquals(""{{howoften}}"", map.get(""period""));&#010;+        assertEquals(""5"", map.get(""repeatCount""));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriLog() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""loggerName"", ""foo"");&#010;+        map.put(""loggerLevel"", ""WARN"");&#010;+        map.put(""multiline"", ""true"");&#010;+        map.put(""showAll"", ""true"");&#010;+        map.put(""showBody"", ""false"");&#010;+        map.put(""showBodyType"", ""false"");&#010;+        map.put(""showExchangePattern"", ""false"");&#010;+        map.put(""style"", ""Tab"");&#010;+&#010;+        assertEquals(""log:foo?loggerLevel=WARN&amp;multiline=true&amp;showAll=true&amp;style=Tab"",&#010;catalog.asEndpointUri(""log"", map, false));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriLogShort() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""loggerName"", ""foo"");&#010;+        map.put(""loggerLevel"", ""DEBUG"");&#010;+&#010;+        assertEquals(""log:foo?loggerLevel=DEBUG"", catalog.asEndpointUri(""log"", map, false));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriWithplaceholder() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""name"", ""foo"");&#010;+        map.put(""blockWhenFull"", ""{{block}}"");&#010;+        assertEquals(""seda:foo?blockWhenFull={{block}}"", catalog.asEndpointUri(""seda"", map,&#010;false));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testEndpointPropertiesSedaRequired() throws Exception {&#010;+        Map&lt;String, String&gt; map = catalog.endpointProperties(""seda:foo"");&#010;+        assertNotNull(map);&#010;+        assertEquals(1, map.size());&#010;+&#010;+        assertEquals(""foo"", map.get(""name""));&#010;+&#010;+        map = catalog.endpointProperties(""seda:foo?blockWhenFull=true"");&#010;+        assertNotNull(map);&#010;+        assertEquals(2, map.size());&#010;+&#010;+        assertEquals(""foo"", map.get(""name""));&#010;+        assertEquals(""true"", map.get(""blockWhenFull""));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void validateProperties() throws Exception {&#010;+        // valid&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(""log:mylog"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // unknown&#010;+        result = catalog.validateEndpointProperties(""log:mylog?level=WARN&amp;foo=bar"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getUnknown().contains(""foo""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // enum&#010;+        result = catalog.validateEndpointProperties(""seda:foo?waitForTaskToComplete=blah"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""blah"", result.getInvalidEnum().get(""waitForTaskToComplete""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // reference okay&#010;+        result = catalog.validateEndpointProperties(""seda:foo?queue=#queue"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(0, result.getNumberOfErrors());&#010;+&#010;+        // unknown component&#010;+        result = catalog.validateEndpointProperties(""foo:bar?me=you"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getUnknownComponent().equals(""foo""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // invalid boolean but default value&#010;+        result = catalog.validateEndpointProperties(""log:output?showAll=ggg"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""ggg"", result.getInvalidBoolean().get(""showAll""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // dataset&#010;+        result = catalog.validateEndpointProperties(""dataset:foo?minRate=50"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // time pattern&#010;+        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=true&amp;delay=0&amp;period=2s"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // reference lookup&#010;+        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=#fixed&amp;delay=#myDelay"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // optional consumer. prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?consumer.delay=5000&amp;consumer.greedy=true"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // optional without consumer. prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;greedy=true"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // mixed optional without consumer. prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;consumer.greedy=true"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;scheduler.foo=123&amp;scheduler.bar=456"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // stub&#010;+        result = catalog.validateEndpointProperties(""stub:foo?me=123&amp;you=456"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // lenient on&#010;+        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // lenient off&#010;+        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"",&#010;true);&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getUnknown().contains(""foo""));&#010;+&#010;+        // data format&#010;+        result = catalog.validateEndpointProperties(""dataformat:string:marshal?charset=utf-8"",&#010;true);&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // incapable to parse&#010;+        result = catalog.validateEndpointProperties(""{{getFtpUrl}}?recursive=true"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getIncapable() != null);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void validatePropertiesSummary() throws Exception {&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(""yammer:MESSAGES?blah=yada&amp;accessToken=aaa&amp;consumerKey=&amp;useJson=no&amp;initialDelay=five&amp;pollStrategy=myStrategy"");&#010;+        assertFalse(result.isSuccess());&#010;+        String reason = result.summaryErrorMessage(true);&#010;+        LOG.info(reason);&#010;+&#010;+        result = catalog.validateEndpointProperties(""jms:unknown:myqueue"");&#010;+        assertFalse(result.isSuccess());&#010;+        reason = result.summaryErrorMessage(false);&#010;+        LOG.info(reason);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void validateTimePattern() throws Exception {&#010;+        assertTrue(catalog.validateTimePattern(""0""));&#010;+        assertTrue(catalog.validateTimePattern(""500""));&#010;+        assertTrue(catalog.validateTimePattern(""10000""));&#010;+        assertTrue(catalog.validateTimePattern(""5s""));&#010;+        assertTrue(catalog.validateTimePattern(""5sec""));&#010;+        assertTrue(catalog.validateTimePattern(""5secs""));&#010;+        assertTrue(catalog.validateTimePattern(""3m""));&#010;+        assertTrue(catalog.validateTimePattern(""3min""));&#010;+        assertTrue(catalog.validateTimePattern(""3minutes""));&#010;+        assertTrue(catalog.validateTimePattern(""5m15s""));&#010;+        assertTrue(catalog.validateTimePattern(""1h""));&#010;+        assertTrue(catalog.validateTimePattern(""1hour""));&#010;+        assertTrue(catalog.validateTimePattern(""2hours""));&#010;+&#010;+        assertFalse(catalog.validateTimePattern(""bla""));&#010;+        assertFalse(catalog.validateTimePattern(""2year""));&#010;+        assertFalse(catalog.validateTimePattern(""60darn""));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testEndpointComponentName() throws Exception {&#010;+        String name = catalog.endpointComponentName(""jms:queue:foo"");&#010;+        assertEquals(""jms"", name);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testSimpleExpression() throws Exception {&#010;+        SimpleValidationResult result = catalog.validateSimpleExpression(null, ""${body}"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body}"", result.getSimple());&#010;+&#010;+        result = catalog.validateSimpleExpression(null, ""${body"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""${body"", result.getSimple());&#010;+        LOG.info(result.getError());&#010;+        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol&#010;at location 5""));&#010;+        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;+        assertEquals(5, result.getIndex());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testSimplePredicate() throws Exception {&#010;+        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} ==&#010;'abc'"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body} == 'abc'"", result.getSimple());&#010;+&#010;+        result = catalog.validateSimplePredicate(null, ""${body} &gt; ${header.size"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""${body} &gt; ${header.size"", result.getSimple());&#010;+        LOG.info(result.getError());&#010;+        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol&#010;at location 22""));&#010;+        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;+        assertEquals(22, result.getIndex());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testSimplePredicatePlaceholder() throws Exception {&#010;+        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} contains&#010;'{{danger}}'"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body} contains '{{danger}}'"", result.getSimple());&#010;+&#010;+        result = catalog.validateSimplePredicate(null, ""${bdy} contains '{{danger}}'"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""${bdy} contains '{{danger}}'"", result.getSimple());&#010;+        LOG.info(result.getError());&#010;+        assertTrue(result.getError().startsWith(""Unknown function: bdy at location 0""));&#010;+        assertTrue(result.getError().contains(""'{{danger}}'""));&#010;+        assertEquals(""Unknown function: bdy"", result.getShortError());&#010;+        assertEquals(0, result.getIndex());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testValidateLanguage() throws Exception {&#010;+        LanguageValidationResult result = catalog.validateLanguageExpression(null, ""simple"",&#010;""${body}"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body}"", result.getText());&#010;+&#010;+        result = catalog.validateLanguageExpression(null, ""header"", ""foo"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""foo"", result.getText());&#010;+&#010;+        result = catalog.validateLanguagePredicate(null, ""simple"", ""${body} &gt; 10"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body} &gt; 10"", result.getText());&#010;+&#010;+        result = catalog.validateLanguagePredicate(null, ""header"", ""bar"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""bar"", result.getText());&#010;+&#010;+        result = catalog.validateLanguagePredicate(null, ""foobar"", ""bar"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""Unknown language foobar"", result.getError());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testValidateEndpointConsumerOnly() throws Exception {&#010;+        String uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true"";&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false,&#010;true, false);&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true&amp;fileExist=Append"";&#010;+        result = catalog.validateEndpointProperties(uri, false, true, false);&#010;+        assertFalse(result.isSuccess());&#010;+&#010;+        assertEquals(""fileExist"", result.getNotConsumerOnly().iterator().next());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testValidateEndpointProducerOnly() throws Exception {&#010;+        String uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append"";&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false,&#010;false, true);&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append&amp;delete=true"";&#010;+        result = catalog.validateEndpointProperties(uri, false, false, true);&#010;+        assertFalse(result.isSuccess());&#010;+&#010;+        assertEquals(""delete"", result.getNotProducerOnly().iterator().next());&#010;+    }&#010;+&#010;+}&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C9e3f964e77d045cf840b002cc3565efe%40git.apache.org%3E,2017-04-14 10:52,commits,5.0,323.0,  [2/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
18,324.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java&#010;new file mode 100644&#010;index 0000000..1e69269&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java&#010;@@ -0,0 +1,424 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.ArrayList;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.LinkedHashSet;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+import java.util.Set;&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+public final class JSonSchemaHelper {&#010;+&#010;+    // 0 = text, 1 = enum, 2 = boolean, 3 = integer or number&#010;+    private static final Pattern PATTERN = Pattern.compile(""\""(.+?)\""|\\[(.+)\\]|(true|false)|(-?\\d+\\.?\\d*)"");&#010;+    private static final String QUOT = ""&amp;quot;"";&#010;+&#010;+    private JSonSchemaHelper() {&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the json schema to split it into a list or rows, where each row contains key value pairs with the metadata&#010;+     *&#010;+     * @param group the group to parse from such as &lt;tt&gt;component&lt;/tt&gt;, &lt;tt&gt;componentProperties&lt;/tt&gt;, or &lt;tt&gt;properties&lt;/tt&gt;.&#010;+     * @param json the json&#010;+     * @return a list of all the rows, where each row is a set of key value pairs with metadata&#010;+     */&#010;+    public static List&lt;Map&lt;String, String&gt;&gt; parseJsonSchema(String group, String json, boolean parseProperties) {&#010;+        List&lt;Map&lt;String, String&gt;&gt; answer = new ArrayList&lt;Map&lt;String, String&gt;&gt;();&#010;+        if (json == null) {&#010;+            return answer;&#010;+        }&#010;+&#010;+        boolean found = false;&#010;+&#010;+        // parse line by line&#010;+        String[] lines = json.split(""\n"");&#010;+        for (String line : lines) {&#010;+            // we need to find the group first&#010;+            if (!found) {&#010;+                String s = line.trim();&#010;+                found = s.startsWith(""\"""" + group + ""\"":"") &amp;&amp; s.endsWith(""{"");&#010;+                continue;&#010;+            }&#010;+&#010;+            // we should stop when we end the group&#010;+            if (line.equals(""  },"") || line.equals(""  }"")) {&#010;+                break;&#010;+            }&#010;+&#010;+            // need to safe encode \"" so we can parse the line&#010;+            line = line.replaceAll(""\""\\\\\""\"""", '""' + QUOT + '""');&#010;+&#010;+            Map&lt;String, String&gt; row = new LinkedHashMap&lt;String, String&gt;();&#010;+            Matcher matcher = PATTERN.matcher(line);&#010;+&#010;+            String key;&#010;+            if (parseProperties) {&#010;+                // when parsing properties the first key is given as name, so the first parsed token is the value of the name&#010;+                key = ""name"";&#010;+            } else {&#010;+                key = null;&#010;+            }&#010;+            while (matcher.find()) {&#010;+                if (key == null) {&#010;+                    key = matcher.group(1);&#010;+                } else {&#010;+                    String value = matcher.group(1);&#010;+                    if (value != null) {&#010;+                        // its text based&#010;+                        value = value.trim();&#010;+                        // decode&#010;+                        value = value.replaceAll(QUOT, ""\"""");&#010;+                        value = decodeJson(value);&#010;+                    }&#010;+                    if (value == null) {&#010;+                        // not text then its maybe an enum?&#010;+                        value = matcher.group(2);&#010;+                        if (value != null) {&#010;+                            // its an enum so strip out "" and trim spaces after comma&#010;+                            value = value.replaceAll(""\"""", """");&#010;+                            value = value.replaceAll("", "", "","");&#010;+                            value = value.trim();&#010;+                        }&#010;+                    }&#010;+                    if (value == null) {&#010;+                        // not text then its maybe a boolean?&#010;+                        value = matcher.group(3);&#010;+                    }&#010;+                    if (value == null) {&#010;+                        // not text then its maybe a integer?&#010;+                        value = matcher.group(4);&#010;+                    }&#010;+                    if (value != null) {&#010;+                        row.put(key, value);&#010;+                    }&#010;+                    // reset&#010;+                    key = null;&#010;+                }&#010;+            }&#010;+            if (!row.isEmpty()) {&#010;+                answer.add(row);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    private static String decodeJson(String value) {&#010;+        // json encodes a \ as \\ so we need to decode from \\ back to \&#010;+        if (""\\\\"".equals(value)) {&#010;+            value = ""\\"";&#010;+        }&#010;+        return value;&#010;+    }&#010;+&#010;+    public static boolean isComponentLenientProperties(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""lenientProperties"")) {&#010;+                return ""true"".equals(row.get(""lenientProperties""));&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isComponentConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""consumerOnly"")) {&#010;+                return ""true"".equals(row.get(""consumerOnly""));&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isComponentProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""producerOnly"")) {&#010;+                return ""true"".equals(row.get(""producerOnly""));&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String labels = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""label"")) {&#010;+                labels = row.get(""label"");&#010;+            }&#010;+            if (found) {&#010;+                return labels != null &amp;&amp; labels.contains(""consumer"");&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String labels = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""label"")) {&#010;+                labels = row.get(""label"");&#010;+            }&#010;+            if (found) {&#010;+                return labels != null &amp;&amp; labels.contains(""producer"");&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyRequired(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            boolean required = false;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""required"")) {&#010;+                required = ""true"".equals(row.get(""required""));&#010;+            }&#010;+            if (found) {&#010;+                return required;&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static String getPropertyKind(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String kind = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""kind"")) {&#010;+                kind = row.get(""kind"");&#010;+            }&#010;+            if (found) {&#010;+                return kind;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static boolean isPropertyBoolean(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""boolean"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyInteger(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""integer"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyNumber(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""number"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyObject(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""object"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static String getPropertyDefaultValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String defaultValue = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""defaultValue"")) {&#010;+                defaultValue = row.get(""defaultValue"");&#010;+            }&#010;+            if (found) {&#010;+                return defaultValue;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static String stripOptionalPrefixFromName(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String optionalPrefix = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""optionalPrefix"")) {&#010;+                optionalPrefix = row.get(""optionalPrefix"");&#010;+            }&#010;+            if (row.containsKey(""name"")) {&#010;+                if (optionalPrefix != null &amp;&amp; name.startsWith(optionalPrefix)) {&#010;+                    name = name.substring(optionalPrefix.length());&#010;+                    // try again&#010;+                    return stripOptionalPrefixFromName(rows, name);&#010;+                } else {&#010;+                    found = name.equals(row.get(""name""));&#010;+                }&#010;+            }&#010;+            if (found) {&#010;+                return name;&#010;+            }&#010;+        }&#010;+        return name;&#010;+    }&#010;+&#010;+    public static String getPropertyEnum(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String enums = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""enum"")) {&#010;+                enums = row.get(""enum"");&#010;+            }&#010;+            if (found) {&#010;+                return enums;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static String getPropertyPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String prefix = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""prefix"")) {&#010;+                prefix = row.get(""prefix"");&#010;+            }&#010;+            if (found) {&#010;+                return prefix;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static boolean isPropertyMultiValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            boolean multiValue = false;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""multiValue"")) {&#010;+                multiValue = ""true"".equals(row.get(""multiValue""));&#010;+            }&#010;+            if (found) {&#010;+                return multiValue;&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static String getPropertyNameFromNameWithPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String propertyName = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                propertyName = row.get(""name"");&#010;+            }&#010;+            if (row.containsKey(""prefix"")) {&#010;+                String preifx = row.get(""prefix"");&#010;+                found = name.startsWith(preifx);&#010;+            }&#010;+            if (found) {&#010;+                return propertyName;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static Map&lt;String, String&gt; getRow(List&lt;Map&lt;String, String&gt;&gt; rows, String key) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (key.equals(row.get(""name""))) {&#010;+                return row;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static Set&lt;String&gt; getNames(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        Set&lt;String&gt; answer = new LinkedHashSet&lt;String&gt;();&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""name"")) {&#010;+                answer.add(row.get(""name""));&#010;+            }&#010;+        }&#010;+        return answer;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java&#010;new file mode 100644&#010;index 0000000..dbd6f45&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java&#010;@@ -0,0 +1,64 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+/**&#010;+ * Pluggable resolver to load JSon schema files for components, data formats, languages etc.&#010;+ */&#010;+public interface JSonSchemaResolver {&#010;+&#010;+    /**&#010;+     * Returns the component information as JSon format.&#010;+     *&#010;+     * @param name the component name&#010;+     * @return component details in JSon&#010;+     */&#010;+    String getComponentJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the data format information as JSon format.&#010;+     *&#010;+     * @param name the data format name&#010;+     * @return data format details in JSon&#010;+     */&#010;+    String getDataFormatJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the language information as JSon format.&#010;+     *&#010;+     * @param name the language name&#010;+     * @return language details in JSon&#010;+     */&#010;+    String getLanguageJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the other (miscellaneous) information as JSon format.&#010;+     *&#010;+     * @param name the other (miscellaneous) name&#010;+     * @return other (miscellaneous) details in JSon&#010;+     */&#010;+    String getOtherJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the model information as JSon format.&#010;+     *&#010;+     * @param name the model name&#010;+     * @return model details in JSon&#010;+     */&#010;+    String getModelJSonSchema(String name);&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java&#010;new file mode 100644&#010;index 0000000..dbb5525&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java&#010;@@ -0,0 +1,65 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.Serializable;&#010;+&#010;+/**&#010;+ * Validation result of parsing a language expression or predicate&#010;+ */&#010;+public class LanguageValidationResult implements Serializable {&#010;+    private final String text;&#010;+    private String error;&#010;+    private String shortError;&#010;+    private int index;&#010;+&#010;+    public LanguageValidationResult(String text) {&#010;+        this.text = text;&#010;+    }&#010;+&#010;+    public String getText() {&#010;+        return text;&#010;+    }&#010;+&#010;+    public boolean isSuccess() {&#010;+        return error == null;&#010;+    }&#010;+&#010;+    public void setError(String error) {&#010;+        this.error = error;&#010;+    }&#010;+&#010;+    public String getError() {&#010;+        return error;&#010;+    }&#010;+&#010;+    public String getShortError() {&#010;+        return shortError;&#010;+    }&#010;+&#010;+    public void setShortError(String shortError) {&#010;+        this.shortError = shortError;&#010;+    }&#010;+&#010;+    public int getIndex() {&#010;+        return index;&#010;+    }&#010;+&#010;+    public void setIndex(int index) {&#010;+        this.index = index;&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java&#010;new file mode 100644&#010;index 0000000..86c4b53&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java&#010;@@ -0,0 +1,234 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.net.URISyntaxException;&#010;+import java.util.Map;&#010;+&#010;+import org.apache.camel.StaticService;&#010;+&#010;+/**&#010;+ * Runtime based CamelCatalog which are included in camel-core that can provided limit CamelCatalog capabilities&#010;+ */&#010;+public interface RuntimeCamelCatalog extends StaticService {&#010;+&#010;+    /**&#010;+     * Returns the component information as JSon format.&#010;+     *&#010;+     * @param name the component name&#010;+     * @return component details in JSon&#010;+     */&#010;+    String componentJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the data format information as JSon format.&#010;+     *&#010;+     * @param name the data format name&#010;+     * @return data format details in JSon&#010;+     */&#010;+    String dataFormatJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the language information as JSon format.&#010;+     *&#010;+     * @param name the language name&#010;+     * @return language details in JSon&#010;+     */&#010;+    String languageJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the model information as JSon format.&#010;+     *&#010;+     * @param name the model name&#010;+     * @return model details in JSon&#010;+     */&#010;+    String modelJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Parses the endpoint uri and constructs a key/value properties of each option&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return properties as key value pairs of each endpoint option&#010;+     */&#010;+    Map&lt;String, String&gt; endpointProperties(String uri) throws URISyntaxException;&#010;+&#010;+    /**&#010;+     * Parses the endpoint uri and constructs a key/value properties of only the lenient properties (eg custom options)&#010;+     * &lt;p/&gt;&#010;+     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return properties as key value pairs of each lenient properties&#010;+     */&#010;+    Map&lt;String, String&gt; endpointLenientProperties(String uri) throws URISyntaxException;&#010;+&#010;+    /**&#010;+     * Validates the pattern whether its a valid time pattern.&#010;+     *&#010;+     * @param pattern  the pattern such as 5000, 5s, 5sec, 4min, 4m30s, 1h, etc.&#010;+     * @return &lt;tt&gt;true&lt;/tt&gt; if valid, &lt;tt&gt;false&lt;/tt&gt; if invalid&#010;+     */&#010;+    boolean validateTimePattern(String pattern);&#010;+&#010;+    /**&#010;+     * Validates the properties for the given scheme against component and endpoint&#010;+     *&#010;+     * @param scheme  the endpoint scheme&#010;+     * @param properties  the endpoint properties&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateProperties(String scheme, Map&lt;String, String&gt; properties);&#010;+&#010;+    /**&#010;+     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateEndpointProperties(String uri);&#010;+&#010;+    /**&#010;+     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;+     * &lt;p/&gt;&#010;+     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;+     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;+     * but in the uri because of using lenient properties.&#010;+     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties);&#010;+&#010;+    /**&#010;+     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;+     * &lt;p/&gt;&#010;+     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;+     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;+     * but in the uri because of using lenient properties.&#010;+     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;+     * @param consumerOnly whether the endpoint is only used as a consumer&#010;+     * @param producerOnly whether the endpoint is only used as a producer&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties, boolean consumerOnly, boolean producerOnly);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple expression.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param simple  the simple expression&#010;+     * @return validation result&#010;+     * @deprecated use {@link #validateSimpleExpression(ClassLoader, String)}&#010;+     */&#010;+    @Deprecated&#010;+    SimpleValidationResult validateSimpleExpression(String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple expression.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param simple  the simple expression&#010;+     * @return validation result&#010;+     */&#010;+    SimpleValidationResult validateSimpleExpression(ClassLoader classLoader, String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple predicate&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param simple  the simple predicate&#010;+     * @return validation result&#010;+     * @deprecated use {@link #validateSimplePredicate(ClassLoader, String)}&#010;+     */&#010;+    @Deprecated&#010;+    SimpleValidationResult validateSimplePredicate(String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple predicate&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param simple  the simple predicate&#010;+     * @return validation result&#010;+     */&#010;+    SimpleValidationResult validateSimplePredicate(ClassLoader classLoader, String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the language as a predicate&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param language the name of the language&#010;+     * @param text  the predicate text&#010;+     * @return validation result&#010;+     */&#010;+    LanguageValidationResult validateLanguagePredicate(ClassLoader classLoader, String language, String text);&#010;+&#010;+    /**&#010;+     * Parses and validates the language as an expression&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param language the name of the language&#010;+     * @param text  the expression text&#010;+     * @return validation result&#010;+     */&#010;+    LanguageValidationResult validateLanguageExpression(ClassLoader classLoader, String language, String text);&#010;+&#010;+    /**&#010;+     * Returns the component name from the given endpoint uri&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return the component name (aka scheme), or &lt;tt&gt;null&lt;/tt&gt; if not possible to determine&#010;+     */&#010;+    String endpointComponentName(String uri);&#010;+&#010;+    /**&#010;+     * Creates an endpoint uri in Java style from the information from the properties&#010;+     *&#010;+     * @param scheme the endpoint schema&#010;+     * @param properties the properties as key value pairs&#010;+     * @param encode whether to URL encode the returned uri or not&#010;+     * @return the constructed endpoint uri&#010;+     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;+     */&#010;+    String asEndpointUri(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;+&#010;+    /**&#010;+     * Creates an endpoint uri in XML style (eg escape &amp; as &amp;ampl;) from the information from the properties&#010;+     *&#010;+     * @param scheme the endpoint schema&#010;+     * @param properties the properties as key value pairs&#010;+     * @param encode whether to URL encode the returned uri or not&#010;+     * @return the constructed endpoint uri&#010;+     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;+     */&#010;+    String asEndpointUriXml(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java&#010;new file mode 100644&#010;index 0000000..1b8dd0e&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java&#010;@@ -0,0 +1,32 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+/**&#010;+ * To be backwards compatible, but favor using {@link LanguageValidationResult} instead.&#010;+ */&#010;+public class SimpleValidationResult extends LanguageValidationResult {&#010;+&#010;+    public SimpleValidationResult(String text) {&#010;+        super(text);&#010;+    }&#010;+&#010;+    public String getSimple() {&#010;+        return getText();&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java&#010;new file mode 100644&#010;index 0000000..e29afc6&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java&#010;@@ -0,0 +1,34 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.Set;&#010;+&#010;+/**&#010;+ * Strategy to provide suggestions for unknown endpoint options&#010;+ */&#010;+public interface SuggestionStrategy {&#010;+&#010;+    /**&#010;+     * Provides a list of valid option names for a did you mean function.&#010;+     *&#010;+     * @param names         valid names&#010;+     * @param unknownOption unknown option name&#010;+     * @return a list of suggested names (did you mean)&#010;+     */&#010;+    String[] suggestEndpointOptions(Set&lt;String&gt; names, String unknownOption);&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java&#010;new file mode 100644&#010;index 0000000..ed5585c&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java&#010;@@ -0,0 +1,120 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+/**&#010;+ * This class is a copy from camel-core so we can use it independent to validate uris with time patterns&#010;+ */&#010;+public final class TimePatternConverter {&#010;+    private static final Pattern NUMBERS_ONLY_STRING_PATTERN = Pattern.compile(""^[-]?(\\d)+$"", Pattern.CASE_INSENSITIVE);&#010;+    private static final Pattern HOUR_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))h(our(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;+    private static final Pattern MINUTES_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))m(in(ute(s)?)?)?"", Pattern.CASE_INSENSITIVE);&#010;+    private static final Pattern SECONDS_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))s(ec(ond)?(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;+&#010;+    /**&#010;+     * Utility classes should not have a public constructor.&#010;+     */&#010;+    private TimePatternConverter() {&#010;+    }&#010;+&#010;+    public static long toMilliSeconds(String source) throws IllegalArgumentException {&#010;+        long milliseconds = 0;&#010;+        boolean foundFlag = false;&#010;+&#010;+        checkCorrectnessOfPattern(source);&#010;+        Matcher matcher;&#010;+&#010;+        matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;+        if (matcher.find()) {&#010;+            // Note: This will also be used for regular numeric strings.&#010;+            //       This String -&gt; long converter will be used for all strings.&#010;+            milliseconds = Long.valueOf(source);&#010;+        } else {&#010;+            matcher = createMatcher(HOUR_REGEX_PATTERN, source);&#010;+            if (matcher.find()) {&#010;+                milliseconds = milliseconds + (3600000 * Long.valueOf(matcher.group(1)));&#010;+                foundFlag = true;&#010;+            }&#010;+&#010;+            matcher = createMatcher(MINUTES_REGEX_PATTERN, source);&#010;+            if (matcher.find()) {&#010;+                long minutes = Long.valueOf(matcher.group(1));&#010;+                if ((minutes &gt; 59) &amp;&amp; foundFlag) {&#010;+                    throw new IllegalArgumentException(""Minutes should contain a valid value between 0 and 59: "" + source);&#010;+                }&#010;+                foundFlag = true;&#010;+                milliseconds = milliseconds + (60000 * minutes);&#010;+            }&#010;+&#010;+            matcher = createMatcher(SECONDS_REGEX_PATTERN, source);&#010;+            if (matcher.find()) {&#010;+                long seconds = Long.valueOf(matcher.group(1));&#010;+                if ((seconds &gt; 59) &amp;&amp; foundFlag) {&#010;+                    throw new IllegalArgumentException(""Seconds should contain a valid value between 0 and 59: "" + source);&#010;+                }&#010;+                foundFlag = true;&#010;+                milliseconds = milliseconds + (1000 * seconds);&#010;+            }&#010;+&#010;+            // No pattern matched... initiating fallback check and conversion (if required).&#010;+            // The source at this point may contain illegal values or special characters&#010;+            if (!foundFlag) {&#010;+                milliseconds = Long.valueOf(source);&#010;+            }&#010;+        }&#010;+&#010;+        return milliseconds;&#010;+    }&#010;+&#010;+    private static void checkCorrectnessOfPattern(String source) {&#010;+        //replace only numbers once&#010;+        Matcher matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;+        String replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        //replace hour string once&#010;+        matcher = createMatcher(HOUR_REGEX_PATTERN, replaceSource);&#010;+        if (matcher.find() &amp;&amp; matcher.find()) {&#010;+            throw new IllegalArgumentException(""Hours should not be specified more then once: "" + source);&#010;+        }&#010;+        replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        //replace minutes once&#010;+        matcher = createMatcher(MINUTES_REGEX_PATTERN, replaceSource);&#010;+        if (matcher.find() &amp;&amp; matcher.find()) {&#010;+            throw new IllegalArgumentException(""Minutes should not be specified more then once: "" + source);&#010;+        }&#010;+        replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        //replace seconds once&#010;+        matcher = createMatcher(SECONDS_REGEX_PATTERN, replaceSource);&#010;+        if (matcher.find() &amp;&amp; matcher.find()) {&#010;+            throw new IllegalArgumentException(""Seconds should not be specified more then once: "" + source);&#010;+        }&#010;+        replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        if (replaceSource.length() &gt; 0) {&#010;+            throw new IllegalArgumentException(""Illegal characters: "" + source);&#010;+        }&#010;+    }&#010;+&#010;+    private static Matcher createMatcher(Pattern pattern, String source) {&#010;+        return pattern.matcher(source);&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java&#010;new file mode 100644&#010;index 0000000..8389590&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java&#010;@@ -0,0 +1,392 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.UnsupportedEncodingException;&#010;+import java.net.URI;&#010;+import java.net.URISyntaxException;&#010;+import java.net.URLDecoder;&#010;+import java.net.URLEncoder;&#010;+import java.util.ArrayList;&#010;+import java.util.Iterator;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+&#010;+/**&#010;+ * Copied from org.apache.camel.util.URISupport&#010;+ */&#010;+public final class URISupport {&#010;+&#010;+    public static final String RAW_TOKEN_START = ""RAW("";&#010;+    public static final String RAW_TOKEN_END = "")"";&#010;+&#010;+    private static final String CHARSET = ""UTF-8"";&#010;+&#010;+    private URISupport() {&#010;+        // Helper class&#010;+    }&#010;+&#010;+    /**&#010;+     * Normalizes the URI so unsafe characters is encoded&#010;+     *&#010;+     * @param uri the input uri&#010;+     * @return as URI instance&#010;+     * @throws URISyntaxException is thrown if syntax error in the input uri&#010;+     */&#010;+    public static URI normalizeUri(String uri) throws URISyntaxException {&#010;+        return new URI(UnsafeUriCharactersEncoder.encode(uri, true));&#010;+    }&#010;+&#010;+    public static Map&lt;String, Object&gt; extractProperties(Map&lt;String, Object&gt; properties, String optionPrefix) {&#010;+        Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;(properties.size());&#010;+&#010;+        for (Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; it = properties.entrySet().iterator(); it.hasNext();) {&#010;+            Map.Entry&lt;String, Object&gt; entry = it.next();&#010;+            String name = entry.getKey();&#010;+            if (name.startsWith(optionPrefix)) {&#010;+                Object value = properties.get(name);&#010;+                name = name.substring(optionPrefix.length());&#010;+                rc.put(name, value);&#010;+                it.remove();&#010;+            }&#010;+        }&#010;+&#010;+        return rc;&#010;+    }&#010;+&#010;+    /**&#010;+     * Strips the query parameters from the uri&#010;+     *&#010;+     * @param uri  the uri&#010;+     * @return the uri without the query parameter&#010;+     */&#010;+    public static String stripQuery(String uri) {&#010;+        int idx = uri.indexOf('?');&#010;+        if (idx &gt; -1) {&#010;+            uri = uri.substring(0, idx);&#010;+        }&#010;+        return uri;&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the query parameters of the uri (eg the query part).&#010;+     *&#010;+     * @param uri the uri&#010;+     * @return the parameters, or an empty map if no parameters (eg never null)&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     */&#010;+    public static Map&lt;String, Object&gt; parseParameters(URI uri) throws URISyntaxException {&#010;+        String query = uri.getQuery();&#010;+        if (query == null) {&#010;+            String schemeSpecificPart = uri.getSchemeSpecificPart();&#010;+            int idx = schemeSpecificPart.indexOf('?');&#010;+            if (idx &lt; 0) {&#010;+                // return an empty map&#010;+                return new LinkedHashMap&lt;String, Object&gt;(0);&#010;+            } else {&#010;+                query = schemeSpecificPart.substring(idx + 1);&#010;+            }&#010;+        } else {&#010;+            query = stripPrefix(query, ""?"");&#010;+        }&#010;+        return parseQuery(query);&#010;+    }&#010;+&#010;+    /**&#010;+     * Strips the prefix from the value.&#010;+     * &lt;p/&gt;&#010;+     * Returns the value as-is if not starting with the prefix.&#010;+     *&#010;+     * @param value  the value&#010;+     * @param prefix the prefix to remove from value&#010;+     * @return the value without the prefix&#010;+     */&#010;+    public static String stripPrefix(String value, String prefix) {&#010;+        if (value != null &amp;&amp; value.startsWith(prefix)) {&#010;+            return value.substring(prefix.length());&#010;+        }&#010;+        return value;&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the query part of the uri (eg the parameters).&#010;+     * &lt;p/&gt;&#010;+     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;+     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;+     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;+     *&#010;+     * @param uri the uri&#010;+     * @return the parameters, or an empty map if no parameters (eg never null)&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     * @see #RAW_TOKEN_START&#010;+     * @see #RAW_TOKEN_END&#010;+     */&#010;+    public static Map&lt;String, Object&gt; parseQuery(String uri) throws URISyntaxException {&#010;+        return parseQuery(uri, false);&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the query part of the uri (eg the parameters).&#010;+     * &lt;p/&gt;&#010;+     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;+     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;+     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;+     *&#010;+     * @param uri the uri&#010;+     * @param useRaw whether to force using raw values&#010;+     * @return the parameters, or an empty map if no parameters (eg never null)&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     * @see #RAW_TOKEN_START&#010;+     * @see #RAW_TOKEN_END&#010;+     */&#010;+    public static Map&lt;String, Object&gt; parseQuery(String uri, boolean useRaw) throws URISyntaxException {&#010;+        // must check for trailing &amp; as the uri.split(""&amp;"") will ignore those&#010;+        if (uri != null &amp;&amp; uri.endsWith(""&amp;"")) {&#010;+            throw new URISyntaxException(uri, ""Invalid uri syntax: Trailing &amp; marker found. ""&#010;+                    + ""Check the uri and remove the trailing &amp; marker."");&#010;+        }&#010;+&#010;+        if (isEmpty(uri)) {&#010;+            // return an empty map&#010;+            return new LinkedHashMap&lt;String, Object&gt;(0);&#010;+        }&#010;+&#010;+        // need to parse the uri query parameters manually as we cannot rely on splitting by &amp;,&#010;+        // as &amp; can be used in a parameter value as well.&#010;+&#010;+        try {&#010;+            // use a linked map so the parameters is in the same order&#010;+            Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;();&#010;+&#010;+            boolean isKey = true;&#010;+            boolean isValue = false;&#010;+            boolean isRaw = false;&#010;+            StringBuilder key = new StringBuilder();&#010;+            StringBuilder value = new StringBuilder();&#010;+&#010;+            // parse the uri parameters char by char&#010;+            for (int i = 0; i &lt; uri.length(); i++) {&#010;+                // current char&#010;+                char ch = uri.charAt(i);&#010;+                // look ahead of the next char&#010;+                char next;&#010;+                if (i &lt;= uri.length() - 2) {&#010;+                    next = uri.charAt(i + 1);&#010;+                } else {&#010;+                    next = '\u0000';&#010;+                }&#010;+&#010;+                // are we a raw value&#010;+                isRaw = value.toString().startsWith(RAW_TOKEN_START);&#010;+&#010;+                // if we are in raw mode, then we keep adding until we hit the end marker&#010;+                if (isRaw) {&#010;+                    if (isKey) {&#010;+                        key.append(ch);&#010;+                    } else if (isValue) {&#010;+                        value.append(ch);&#010;+                    }&#010;+&#010;+                    // we only end the raw marker if its )&amp; or at the end of the value&#010;+&#010;+                    boolean end = ch == RAW_TOKEN_END.charAt(0) &amp;&amp; (next == '&amp;' || next == '\u0000');&#010;+                    if (end) {&#010;+                        // raw value end, so add that as a parameter, and reset flags&#010;+                        addParameter(key.toString(), value.toString(), rc, useRaw || isRaw);&#010;+                        key.setLength(0);&#010;+                        value.setLength(0);&#010;+                        isKey = true;&#010;+                        isValue = false;&#010;+                        isRaw = false;&#010;+                        // skip to next as we are in raw mode and have already added the value&#010;+                        i++;&#010;+                    }&#010;+                    continue;&#010;+                }&#010;+&#010;+                // if its a key and there is a = sign then the key ends and we are in value mode&#010;+                if (isKey &amp;&amp; ch == '=') {&#010;+                    isKey = false;&#010;+                    isValue = true;&#010;+                    isRaw = false;&#010;+                    continue;&#010;+                }&#010;+&#010;+                // the &amp; denote parameter is ended&#010;+                if (ch == '&amp;') {&#010;+                    // parameter is ended, as we hit &amp; separator&#010;+                    String aKey = key.toString();&#010;+                    // the key may be a placeholder of options which we then do not know what is&#010;+                    boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;+                    if (validKey) {&#010;+                        addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;+                    }&#010;+                    key.setLength(0);&#010;+                    value.setLength(0);&#010;+                    isKey = true;&#010;+                    isValue = false;&#010;+                    isRaw = false;&#010;+                    continue;&#010;+                }&#010;+&#010;+                // regular char so add it to the key or value&#010;+                if (isKey) {&#010;+                    key.append(ch);&#010;+                } else if (isValue) {&#010;+                    value.append(ch);&#010;+                }&#010;+            }&#010;+&#010;+            // any left over parameters, then add that&#010;+            if (key.length() &gt; 0) {&#010;+                String aKey = key.toString();&#010;+                // the key may be a placeholder of options which we then do not know what is&#010;+                boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;+                if (validKey) {&#010;+                    addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;+                }&#010;+            }&#010;+&#010;+            return rc;&#010;+&#010;+        } catch (UnsupportedEncodingException e) {&#010;+            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;+            se.initCause(e);&#010;+            throw se;&#010;+        }&#010;+    }&#010;+&#010;+    @SuppressWarnings(""unchecked"")&#010;+    private static void addParameter(String name, String value, Map&lt;String, Object&gt; map, boolean isRaw) throws UnsupportedEncodingException {&#010;+        name = URLDecoder.decode(name, CHARSET);&#010;+        if (!isRaw) {&#010;+            // need to replace % with %25&#010;+            value = URLDecoder.decode(value.replaceAll(""%"", ""%25""), CHARSET);&#010;+        }&#010;+&#010;+        // does the key already exist?&#010;+        if (map.containsKey(name)) {&#010;+            // yes it does, so make sure we can support multiple values, but using a list&#010;+            // to hold the multiple values&#010;+            Object existing = map.get(name);&#010;+            List&lt;String&gt; list;&#010;+            if (existing instanceof List) {&#010;+                list = (List&lt;String&gt;) existing;&#010;+            } else {&#010;+                // create a new list to hold the multiple values&#010;+                list = new ArrayList&lt;String&gt;();&#010;+                String s = existing != null ? existing.toString() : null;&#010;+                if (s != null) {&#010;+                    list.add(s);&#010;+                }&#010;+            }&#010;+            list.add(value);&#010;+            map.put(name, list);&#010;+        } else {&#010;+            map.put(name, value);&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Assembles a query from the given map.&#010;+     *&#010;+     * @param options  the map with the options (eg key/value pairs)&#010;+     * @param ampersand to use &amp; for Java code, and &amp;amp; for XML&#010;+     * @return a query string with &lt;tt&gt;key1=value&amp;key2=value2&amp;...&lt;/tt&gt;, or an empty string if there is no options.&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     */&#010;+    public static String createQueryString(Map&lt;String, String&gt; options, String ampersand, boolean encode) throws URISyntaxException {&#010;+        try {&#010;+            if (options.size() &gt; 0) {&#010;+                StringBuilder rc = new StringBuilder();&#010;+                boolean first = true;&#010;+                for (Object o : options.keySet()) {&#010;+                    if (first) {&#010;+                        first = false;&#010;+                    } else {&#010;+                        rc.append(ampersand);&#010;+                    }&#010;+&#010;+                    String key = (String) o;&#010;+                    Object value = options.get(key);&#010;+&#010;+                    // use the value as a String&#010;+                    String s = value != null ? value.toString() : null;&#010;+                    appendQueryStringParameter(key, s, rc, encode);&#010;+                }&#010;+                return rc.toString();&#010;+            } else {&#010;+                return """";&#010;+            }&#010;+        } catch (UnsupportedEncodingException e) {&#010;+            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;+            se.initCause(e);&#010;+            throw se;&#010;+        }&#010;+    }&#010;+&#010;+    private static void appendQueryStringParameter(String key, String value, StringBuilder rc, boolean encode) throws UnsupportedEncodingException {&#010;+        if (encode) {&#010;+            rc.append(URLEncoder.encode(key, CHARSET));&#010;+        } else {&#010;+            rc.append(key);&#010;+        }&#010;+        // only append if value is not null&#010;+        if (value != null) {&#010;+            rc.append(""="");&#010;+            if (value.startsWith(RAW_TOKEN_START) &amp;&amp; value.endsWith(RAW_TOKEN_END)) {&#010;+                // do not encode RAW parameters&#010;+                rc.append(value);&#010;+            } else {&#010;+                if (encode) {&#010;+                    rc.append(URLEncoder.encode(value, CHARSET));&#010;+                } else {&#010;+                    rc.append(value);&#010;+                }&#010;+            }&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if empty&#010;+     */&#010;+    public static boolean isEmpty(Object value) {&#010;+        return !isNotEmpty(value);&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;b&gt;not&lt;/b&gt; &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if &lt;b&gt;not&lt;/b&gt; empty&#010;+     */&#010;+    public static boolean isNotEmpty(Object value) {&#010;+        if (value == null) {&#010;+            return false;&#010;+        } else if (value instanceof String) {&#010;+            String text = (String) value;&#010;+            return text.trim().length() &gt; 0;&#010;+        } else {&#010;+            return true;&#010;+        }&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java&#010;new file mode 100644&#010;index 0000000..a11c810&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java&#010;@@ -0,0 +1,206 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.ArrayList;&#010;+import java.util.BitSet;&#010;+import java.util.List;&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+/**&#010;+ * Encoder for unsafe URI characters.&#010;+ * &lt;p/&gt;&#010;+ * A good source for details is &lt;a href=""http://en.wikipedia.org/wiki/Url_encode""&gt;wikipedia url encode&lt;/a&gt; article.&#010;+ */&#010;+public final class UnsafeUriCharactersEncoder {&#010;+    private static BitSet unsafeCharactersRfc1738;&#010;+    private static BitSet unsafeCharactersHttp;&#010;+    private static final char[] HEX_DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C',&#010;+        'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'};&#010;+    private static final Pattern RAW_PATTERN = Pattern.compile(""RAW\\([^\\)]+\\)"");&#010;+&#010;+    static {&#010;+        unsafeCharactersRfc1738 = new BitSet(256);&#010;+        unsafeCharactersRfc1738.set(' ');&#010;+        unsafeCharactersRfc1738.set('""');&#010;+        unsafeCharactersRfc1738.set('&lt;');&#010;+        unsafeCharactersRfc1738.set('&gt;');&#010;+        unsafeCharactersRfc1738.set('#');&#010;+        unsafeCharactersRfc1738.set('%');&#010;+        unsafeCharactersRfc1738.set('{');&#010;+        unsafeCharactersRfc1738.set('}');&#010;+        unsafeCharactersRfc1738.set('|');&#010;+        unsafeCharactersRfc1738.set('\\');&#010;+        unsafeCharactersRfc1738.set('^');&#010;+        unsafeCharactersRfc1738.set('~');&#010;+        unsafeCharactersRfc1738.set('[');&#010;+        unsafeCharactersRfc1738.set(']');&#010;+        unsafeCharactersRfc1738.set('`');&#010;+    }&#010;+&#010;+    static {&#010;+        unsafeCharactersHttp = new BitSet(256);&#010;+        unsafeCharactersHttp.set(' ');&#010;+        unsafeCharactersHttp.set('""');&#010;+        unsafeCharactersHttp.set('&lt;');&#010;+        unsafeCharactersHttp.set('&gt;');&#010;+        unsafeCharactersHttp.set('#');&#010;+        unsafeCharactersHttp.set('%');&#010;+        unsafeCharactersHttp.set('{');&#010;+        unsafeCharactersHttp.set('}');&#010;+        unsafeCharactersHttp.set('|');&#010;+        unsafeCharactersHttp.set('\\');&#010;+        unsafeCharactersHttp.set('^');&#010;+        unsafeCharactersHttp.set('~');&#010;+        unsafeCharactersHttp.set('`');&#010;+    }&#010;+&#010;+    private UnsafeUriCharactersEncoder() {&#010;+        // util class&#010;+    }&#010;+&#010;+    public static String encode(String s) {&#010;+        return encode(s, unsafeCharactersRfc1738);&#010;+    }&#010;+&#010;+    public static String encodeHttpURI(String s) {&#010;+        return encode(s, unsafeCharactersHttp);&#010;+    }&#010;+&#010;+    public static String encode(String s, BitSet unsafeCharacters) {&#010;+        return encode(s, unsafeCharacters, false);&#010;+    }&#010;+&#010;+    public static String encode(String s, boolean checkRaw) {&#010;+        return encode(s, unsafeCharactersRfc1738, checkRaw);&#010;+    }&#010;+&#010;+    public static String encodeHttpURI(String s, boolean checkRaw) {&#010;+        return encode(s, unsafeCharactersHttp, checkRaw);&#010;+    }&#010;+&#010;+    private static List&lt;Pair&gt; checkRAW(String s) {&#010;+        Matcher matcher = RAW_PATTERN.matcher(s);&#010;+        List&lt;Pair&gt; answer = new ArrayList&lt;Pair&gt;();&#010;+        // Check all occurrences&#010;+        while (matcher.find()) {&#010;+            answer.add(new Pair(matcher.start(), matcher.end()));&#010;+        }&#010;+        return answer;&#010;+    }&#010;+&#010;+    private static boolean isRaw(int index, List&lt;Pair&gt; pairs) {&#010;+        for (Pair pair : pairs) {&#010;+            if (index &lt; pair.left) {&#010;+                return false;&#010;+            } else {&#010;+                if (index &gt;= pair.left) {&#010;+                    if (index &lt;= pair.right) {&#010;+                        return true;&#010;+                    } else {&#010;+                        continue;&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    private static class Pair {&#010;+        int left;&#010;+        int right;&#010;+&#010;+        Pair(int left, int right) {&#010;+            this.left = left;&#010;+            this.right = right;&#010;+        }&#010;+    }&#010;+&#010;+    // Just skip the encode for isRAW part&#010;+    public static String encode(String s, BitSet unsafeCharacters, boolean checkRaw) {&#010;+        List&lt;Pair&gt; rawPairs;&#010;+        if (checkRaw) {&#010;+            rawPairs = checkRAW(s);&#010;+        } else {&#010;+            rawPairs = new ArrayList&lt;Pair&gt;();&#010;+        }&#010;+&#010;+        int n = s == null ? 0 : s.length();&#010;+        if (n == 0) {&#010;+            return s;&#010;+        }&#010;+&#010;+        // First check whether we actually need to encode&#010;+        char chars[] = s.toCharArray();&#010;+        for (int i = 0;;) {&#010;+            // just deal with the ascii character&#010;+            if (chars[i] &gt; 0 &amp;&amp; chars[i] &lt; 128) {&#010;+                if (unsafeCharacters.get(chars[i])) {&#010;+                    break;&#010;+                }&#010;+            }&#010;+            if (++i &gt;= chars.length) {&#010;+                return s;&#010;+            }&#010;+        }&#010;+&#010;+        // okay there are some unsafe characters so we do need to encode&#010;+        // see details at: http://en.wikipedia.org/wiki/Url_encode&#010;+        StringBuilder sb = new StringBuilder();&#010;+        for (int i = 0; i &lt; chars.length; i++) {&#010;+            char ch = chars[i];&#010;+            if (ch &gt; 0 &amp;&amp; ch &lt; 128 &amp;&amp; unsafeCharacters.get(ch)) {&#010;+                // special for % sign as it may be a decimal encoded value&#010;+                if (ch == '%') {&#010;+                    char next = i + 1 &lt; chars.length ? chars[i + 1] : ' ';&#010;+                    char next2 = i + 2 &lt; chars.length ? chars[i + 2] : ' ';&#010;+&#010;+                    if (isHexDigit(next) &amp;&amp; isHexDigit(next2) &amp;&amp; !isRaw(i, rawPairs)) {&#010;+                        // its already encoded (decimal encoded) so just append as is&#010;+                        sb.append(ch);&#010;+                    } else {&#010;+                        // must escape then, as its an unsafe character&#010;+                        appendEscape(sb, (byte) ch);&#010;+                    }&#010;+                } else {&#010;+                    // must escape then, as its an unsafe character&#010;+                    appendEscape(sb, (byte) ch);&#010;+                }&#010;+            } else {&#010;+                sb.append(ch);&#010;+            }&#010;+        }&#010;+        return sb.toString();&#010;+    }&#010;+&#010;+    private static void appendEscape(StringBuilder sb, byte b) {&#010;+        sb.append('%');&#010;+        sb.append(HEX_DIGITS[(b &gt;&gt; 4) &amp; 0x0f]);&#010;+        sb.append(HEX_DIGITS[(b &gt;&gt; 0) &amp; 0x0f]);&#010;+    }&#010;+&#010;+    private static boolean isHexDigit(char ch) {&#010;+        for (char hex : HEX_DIGITS) {&#010;+            if (hex == ch) {&#010;+                return true;&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html b/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html&#010;new file mode 100644&#010;index 0000000..2f15a04&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html&#010;@@ -0,0 +1,25 @@&#010;+&lt;!--&#010;+    Licensed to the Apache Software Foundation (ASF) under one or more&#010;+    contributor license agreements.  See the NOTICE file distributed with&#010;+    this work for additional information regarding copyright ownership.&#010;+    The ASF licenses this file to You under the Apache License, Version 2.0&#010;+    (the ""License""); you may not use this file except in compliance with&#010;+    the License.  You may obtain a copy of the License at&#010;+&#010;+    http://www.apache.org/licenses/LICENSE-2.0&#010;+&#010;+    Unless required by applicable law or agreed to in writing, software&#010;+    distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+    See the License for the specific language governing permissions and&#010;+    limitations under the License.&#010;+--&gt;&#010;+&lt;html&gt;&#010;+&lt;head&gt;&#010;+&lt;/head&gt;&#010;+&lt;body&gt;&#010;+&#010;+Runtime Camel Catalog&#010;+&#010;+&lt;/body&gt;&#010;+&lt;/html&gt;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java b/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;index fd22f55..a32c109 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;@@ -37,8 +37,8 @@ import org.apache.camel.PollingConsumer;&#010; import org.apache.camel.Processor;&#010; import org.apache.camel.ResolveEndpointFailedException;&#010; import org.apache.camel.Route;&#010;-import org.apache.camel.catalog.DefaultRuntimeCamelCatalog;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.DefaultRuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.BrowsableEndpoint;&#010; import org.slf4j.Logger;&#010; import org.slf4j.LoggerFactory;&#010;@@ -523,7 +523,7 @@ public final class EndpointHelper {&#010;      * @param uri          the endpoint uri&#010;      * @return a map for each option in the uri with the corresponding information from the json&#010;      * @throws Exception is thrown in case of error&#010;-     * @deprecated use {@link org.apache.camel.catalog.RuntimeCamelCatalog#endpointProperties(String)}&#010;+     * @deprecated use {@link org.apache.camel.runtimecatalog.RuntimeCamelCatalog#endpointProperties(String)}&#010;      */&#010;     @Deprecated&#010;     public static Map&lt;String, Object&gt; endpointProperties(CamelContext camelContext, String uri) throws Exception {&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java b/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java&#010;deleted file mode 100644&#010;index ed7e997..0000000&#010;--- a/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java&#010;+++ /dev/null&#010;@@ -1,104 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.net.URISyntaxException;&#010;-import java.util.HashMap;&#010;-import java.util.Map;&#010;-&#010;-import org.junit.Before;&#010;-import org.junit.Test;&#010;-&#010;-import static org.easymock.EasyMock.expect;&#010;-import static org.easymock.EasyMock.mock;&#010;-import static org.easymock.EasyMock.replay;&#010;-import static org.junit.Assert.assertEquals;&#010;-&#010;-public class AbstractCamelCatalogTest {&#010;-&#010;-    AbstractCamelCatalog catalog = new AbstractCamelCatalog() {&#010;-    };&#010;-&#010;-    JSonSchemaResolver resolver;&#010;-&#010;-    @Before&#010;-    public void setupMockCatalog() {&#010;-        resolver = mock(JSonSchemaResolver.class);&#010;-&#010;-        catalog.setJSonSchemaResolver(resolver);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void shouldConstructEndpointUris() throws URISyntaxException {&#010;-        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;-            + ""  \""component\"": {\n""//&#010;-            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;-            + ""  }\n""//&#010;-            + ""}"");&#010;-&#010;-        replay(resolver);&#010;-&#010;-        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;-        properties.put(""param1"", ""value1"");&#010;-        properties.put(""param2"", ""value2"");&#010;-        properties.put(""param3"", ""value3"");&#010;-&#010;-        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;-&#010;-        assertEquals(""comp:value1:value2?param3=value3"", endpointUri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void shouldConstructEndpointUrisWithPropertyPlaceholders() throws URISyntaxException {&#010;-        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;-            + ""  \""component\"": {\n""//&#010;-            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;-            + ""  }\n""//&#010;-            + ""}"");&#010;-&#010;-        replay(resolver);&#010;-&#010;-        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;-        properties.put(""param1"", ""{{prop1}}"");&#010;-        properties.put(""param2"", ""{{prop2}}"");&#010;-        properties.put(""param3"", ""{{prop3}}"");&#010;-&#010;-        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;-&#010;-        assertEquals(""comp:{{prop1}}:{{prop2}}?param3={{prop3}}"", endpointUri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void shouldConstructEndpointUrisWhenValuesContainTokens() throws URISyntaxException {&#010;-        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;-            + ""  \""component\"": {\n""//&#010;-            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;-            + ""  }\n""//&#010;-            + ""}"");&#010;-&#010;-        replay(resolver);&#010;-&#010;-        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;-        properties.put(""param1"", ""{value1}"");&#010;-        properties.put(""param2"", ""/value2/"");&#010;-        properties.put(""param3"", ""/value3/{param}"");&#010;-&#010;-        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;-&#010;-        assertEquals(""comp:{value1}:/value2/?param3=/value3/{param}"", endpointUri);&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java b/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java&#010;deleted file mode 100644&#010;index 78e51a2..0000000&#010;--- a/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java&#010;+++ /dev/null&#010;@@ -1,393 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.HashMap;&#010;-import java.util.Map;&#010;-&#010;-import org.apache.camel.impl.DefaultCamelContext;&#010;-import org.junit.BeforeClass;&#010;-import org.junit.Test;&#010;-import org.slf4j.Logger;&#010;-import org.slf4j.LoggerFactory;&#010;-&#010;-import static org.junit.Assert.assertEquals;&#010;-import static org.junit.Assert.assertFalse;&#010;-import static org.junit.Assert.assertNotNull;&#010;-import static org.junit.Assert.assertTrue;&#010;-&#010;-public class RuntimeCamelCatalogTest {&#010;-&#010;-    static RuntimeCamelCatalog catalog;&#010;-&#010;-    private static final Logger LOG = LoggerFactory.getLogger(RuntimeCamelCatalogTest.class);&#010;-&#010;-    @BeforeClass&#010;-    public static void createCamelCatalog() {&#010;-        catalog = new DefaultRuntimeCamelCatalog(new DefaultCamelContext());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testFromCamelContext() throws Exception {&#010;-        String schema = new DefaultCamelContext().getRuntimeCamelCatalog().modelJSonSchema(""choice"");&#010;-        assertNotNull(schema);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testJsonSchema() throws Exception {&#010;-        String schema = catalog.modelJSonSchema(""aggregate"");&#010;-        assertNotNull(schema);&#010;-&#010;-        // lets make it possible to find bean/method using both names&#010;-        schema = catalog.modelJSonSchema(""method"");&#010;-        assertNotNull(schema);&#010;-        schema = catalog.modelJSonSchema(""bean"");&#010;-        assertNotNull(schema);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriMapFile() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""directoryName"", ""src/data/inbox"");&#010;-        map.put(""noop"", ""true"");&#010;-        map.put(""delay"", ""5000"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""file"", map, true);&#010;-        assertEquals(""file:src/data/inbox?delay=5000&amp;noop=true"", uri);&#010;-&#010;-        String uri2 = catalog.asEndpointUriXml(""file"", map, true);&#010;-        assertEquals(""file:src/data/inbox?delay=5000&amp;amp;noop=true"", uri2);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriTimer() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""timerName"", ""foo"");&#010;-        map.put(""period"", ""5000"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;-        assertEquals(""timer:foo?period=5000"", uri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriPropertiesPlaceholders() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""timerName"", ""foo"");&#010;-        map.put(""period"", ""{{howoften}}"");&#010;-        map.put(""repeatCount"", ""5"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;-        assertEquals(""timer:foo?period=%7B%7Bhowoften%7D%7D&amp;repeatCount=5"", uri);&#010;-&#010;-        uri = catalog.asEndpointUri(""timer"", map, false);&#010;-        assertEquals(""timer:foo?period={{howoften}}&amp;repeatCount=5"", uri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriBeanLookup() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""resourceUri"", ""foo.xslt"");&#010;-        map.put(""converter"", ""#myConverter"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""xslt"", map, true);&#010;-        assertEquals(""xslt:foo.xslt?converter=%23myConverter"", uri);&#010;-&#010;-        uri = catalog.asEndpointUri(""xslt"", map, false);&#010;-        assertEquals(""xslt:foo.xslt?converter=#myConverter"", uri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testEndpointPropertiesPlaceholders() throws Exception {&#010;-        Map&lt;String, String&gt; map = catalog.endpointProperties(""timer:foo?period={{howoften}}&amp;repeatCount=5"");&#010;-        assertNotNull(map);&#010;-        assertEquals(3, map.size());&#010;-&#010;-        assertEquals(""foo"", map.get(""timerName""));&#010;-        assertEquals(""{{howoften}}"", map.get(""period""));&#010;-        assertEquals(""5"", map.get(""repeatCount""));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriLog() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""loggerName"", ""foo"");&#010;-        map.put(""loggerLevel"", ""WARN"");&#010;-        map.put(""multiline"", ""true"");&#010;-        map.put(""showAll"", ""true"");&#010;-        map.put(""showBody"", ""false"");&#010;-        map.put(""showBodyType"", ""false"");&#010;-        map.put(""showExchangePattern"", ""false"");&#010;-        map.put(""style"", ""Tab"");&#010;-&#010;-        assertEquals(""log:foo?loggerLevel=WARN&amp;multiline=true&amp;showAll=true&amp;style=Tab"", catalog.asEndpointUri(""log"", map, false));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriLogShort() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""loggerName"", ""foo"");&#010;-        map.put(""loggerLevel"", ""DEBUG"");&#010;-&#010;-        assertEquals(""log:foo?loggerLevel=DEBUG"", catalog.asEndpointUri(""log"", map, false));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriWithplaceholder() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""name"", ""foo"");&#010;-        map.put(""blockWhenFull"", ""{{block}}"");&#010;-        assertEquals(""seda:foo?blockWhenFull={{block}}"", catalog.asEndpointUri(""seda"", map, false));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testEndpointPropertiesSedaRequired() throws Exception {&#010;-        Map&lt;String, String&gt; map = catalog.endpointProperties(""seda:foo"");&#010;-        assertNotNull(map);&#010;-        assertEquals(1, map.size());&#010;-&#010;-        assertEquals(""foo"", map.get(""name""));&#010;-&#010;-        map = catalog.endpointProperties(""seda:foo?blockWhenFull=true"");&#010;-        assertNotNull(map);&#010;-        assertEquals(2, map.size());&#010;-&#010;-        assertEquals(""foo"", map.get(""name""));&#010;-        assertEquals(""true"", map.get(""blockWhenFull""));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void validateProperties() throws Exception {&#010;-        // valid&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(""log:mylog"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // unknown&#010;-        result = catalog.validateEndpointProperties(""log:mylog?level=WARN&amp;foo=bar"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getUnknown().contains(""foo""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // enum&#010;-        result = catalog.validateEndpointProperties(""seda:foo?waitForTaskToComplete=blah"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""blah"", result.getInvalidEnum().get(""waitForTaskToComplete""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // reference okay&#010;-        result = catalog.validateEndpointProperties(""seda:foo?queue=#queue"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(0, result.getNumberOfErrors());&#010;-&#010;-        // unknown component&#010;-        result = catalog.validateEndpointProperties(""foo:bar?me=you"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getUnknownComponent().equals(""foo""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // invalid boolean but default value&#010;-        result = catalog.validateEndpointProperties(""log:output?showAll=ggg"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""ggg"", result.getInvalidBoolean().get(""showAll""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // dataset&#010;-        result = catalog.validateEndpointProperties(""dataset:foo?minRate=50"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // time pattern&#010;-        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=true&amp;delay=0&amp;period=2s"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // reference lookup&#010;-        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=#fixed&amp;delay=#myDelay"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // optional consumer. prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?consumer.delay=5000&amp;consumer.greedy=true"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // optional without consumer. prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;greedy=true"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // mixed optional without consumer. prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;consumer.greedy=true"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;scheduler.foo=123&amp;scheduler.bar=456"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // stub&#010;-        result = catalog.validateEndpointProperties(""stub:foo?me=123&amp;you=456"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // lenient on&#010;-        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // lenient off&#010;-        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"", true);&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getUnknown().contains(""foo""));&#010;-&#010;-        // data format&#010;-        result = catalog.validateEndpointProperties(""dataformat:string:marshal?charset=utf-8"", true);&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // incapable to parse&#010;-        result = catalog.validateEndpointProperties(""{{getFtpUrl}}?recursive=true"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getIncapable() != null);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void validatePropertiesSummary() throws Exception {&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(""yammer:MESSAGES?blah=yada&amp;accessToken=aaa&amp;consumerKey=&amp;useJson=no&amp;initialDelay=five&amp;pollStrategy=myStrategy"");&#010;-        assertFalse(result.isSuccess());&#010;-        String reason = result.summaryErrorMessage(true);&#010;-        LOG.info(reason);&#010;-&#010;-        result = catalog.validateEndpointProperties(""jms:unknown:myqueue"");&#010;-        assertFalse(result.isSuccess());&#010;-        reason = result.summaryErrorMessage(false);&#010;-        LOG.info(reason);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void validateTimePattern() throws Exception {&#010;-        assertTrue(catalog.validateTimePattern(""0""));&#010;-        assertTrue(catalog.validateTimePattern(""500""));&#010;-        assertTrue(catalog.validateTimePattern(""10000""));&#010;-        assertTrue(catalog.validateTimePattern(""5s""));&#010;-        assertTrue(catalog.validateTimePattern(""5sec""));&#010;-        assertTrue(catalog.validateTimePattern(""5secs""));&#010;-        assertTrue(catalog.validateTimePattern(""3m""));&#010;-        assertTrue(catalog.validateTimePattern(""3min""));&#010;-        assertTrue(catalog.validateTimePattern(""3minutes""));&#010;-        assertTrue(catalog.validateTimePattern(""5m15s""));&#010;-        assertTrue(catalog.validateTimePattern(""1h""));&#010;-        assertTrue(catalog.validateTimePattern(""1hour""));&#010;-        assertTrue(catalog.validateTimePattern(""2hours""));&#010;-&#010;-        assertFalse(catalog.validateTimePattern(""bla""));&#010;-        assertFalse(catalog.validateTimePattern(""2year""));&#010;-        assertFalse(catalog.validateTimePattern(""60darn""));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testEndpointComponentName() throws Exception {&#010;-        String name = catalog.endpointComponentName(""jms:queue:foo"");&#010;-        assertEquals(""jms"", name);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testSimpleExpression() throws Exception {&#010;-        SimpleValidationResult result = catalog.validateSimpleExpression(null, ""${body}"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body}"", result.getSimple());&#010;-&#010;-        result = catalog.validateSimpleExpression(null, ""${body"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""${body"", result.getSimple());&#010;-        LOG.info(result.getError());&#010;-        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol at location 5""));&#010;-        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;-        assertEquals(5, result.getIndex());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testSimplePredicate() throws Exception {&#010;-        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} == 'abc'"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body} == 'abc'"", result.getSimple());&#010;-&#010;-        result = catalog.validateSimplePredicate(null, ""${body} &gt; ${header.size"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""${body} &gt; ${header.size"", result.getSimple());&#010;-        LOG.info(result.getError());&#010;-        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol at location 22""));&#010;-        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;-        assertEquals(22, result.getIndex());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testSimplePredicatePlaceholder() throws Exception {&#010;-        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} contains '{{danger}}'"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body} contains '{{danger}}'"", result.getSimple());&#010;-&#010;-        result = catalog.validateSimplePredicate(null, ""${bdy} contains '{{danger}}'"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""${bdy} contains '{{danger}}'"", result.getSimple());&#010;-        LOG.info(result.getError());&#010;-        assertTrue(result.getError().startsWith(""Unknown function: bdy at location 0""));&#010;-        assertTrue(result.getError().contains(""'{{danger}}'""));&#010;-        assertEquals(""Unknown function: bdy"", result.getShortError());&#010;-        assertEquals(0, result.getIndex());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testValidateLanguage() throws Exception {&#010;-        LanguageValidationResult result = catalog.validateLanguageExpression(null, ""simple"", ""${body}"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body}"", result.getText());&#010;-&#010;-        result = catalog.validateLanguageExpression(null, ""header"", ""foo"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""foo"", result.getText());&#010;-&#010;-        result = catalog.validateLanguagePredicate(null, ""simple"", ""${body} &gt; 10"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body} &gt; 10"", result.getText());&#010;-&#010;-        result = catalog.validateLanguagePredicate(null, ""header"", ""bar"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""bar"", result.getText());&#010;-&#010;-        result = catalog.validateLanguagePredicate(null, ""foobar"", ""bar"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""Unknown language foobar"", result.getError());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testValidateEndpointConsumerOnly() throws Exception {&#010;-        String uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true"";&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false, true, false);&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true&amp;fileExist=Append"";&#010;-        result = catalog.validateEndpointProperties(uri, false, true, false);&#010;-        assertFalse(result.isSuccess());&#010;-&#010;-        assertEquals(""fileExist"", result.getNotConsumerOnly().iterator().next());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testValidateEndpointProducerOnly() throws Exception {&#010;-        String uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append"";&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false, false, true);&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append&amp;delete=true"";&#010;-        result = catalog.validateEndpointProperties(uri, false, false, true);&#010;-        assertFalse(result.isSuccess());&#010;-&#010;-        assertEquals(""delete"", result.getNotProducerOnly().iterator().next());&#010;-    }&#010;-&#010;-}&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C392ff0b6a5e9466c9cdb499eabbaf550%40git.apache.org%3E,2017-04-14 10:52,commits,5.0,324.0,  [3/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
19,325.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java&#010;new file mode 100644&#010;index 0000000..0420708&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java&#010;@@ -0,0 +1,1294 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.lang.reflect.InvocationTargetException;&#010;+import java.lang.reflect.Method;&#010;+import java.net.URI;&#010;+import java.net.URISyntaxException;&#010;+import java.util.ArrayList;&#010;+import java.util.Arrays;&#010;+import java.util.HashMap;&#010;+import java.util.Iterator;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.LinkedHashSet;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+import java.util.Objects;&#010;+import java.util.Set;&#010;+import java.util.TreeMap;&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+import static org.apache.camel.runtimecatalog.CatalogHelper.after;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getNames;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyDefaultValue;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyEnum;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyKind;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyNameFromNameWithPrefix;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyPrefix;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getRow;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isComponentConsumerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isComponentLenientProperties;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isComponentProducerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyBoolean;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyConsumerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyInteger;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyMultiValue;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyNumber;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyObject;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyProducerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyRequired;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.stripOptionalPrefixFromName;&#010;+import static org.apache.camel.runtimecatalog.URISupport.createQueryString;&#010;+import static org.apache.camel.runtimecatalog.URISupport.isEmpty;&#010;+import static org.apache.camel.runtimecatalog.URISupport.normalizeUri;&#010;+import static org.apache.camel.runtimecatalog.URISupport.stripQuery;&#010;+&#010;+/**&#010;+ * Base class for both the runtime RuntimeCamelCatalog from camel-core and the complete CamelCatalog from camel-catalog.&#010;+ */&#010;+public abstract class AbstractCamelCatalog {&#010;+&#010;+    // CHECKSTYLE:OFF&#010;+&#010;+    private static final Pattern SYNTAX_PATTERN = Pattern.compile(""(\\w+)"");&#010;+&#010;+    private SuggestionStrategy suggestionStrategy;&#010;+    private JSonSchemaResolver jsonSchemaResolver;&#010;+&#010;+    public SuggestionStrategy getSuggestionStrategy() {&#010;+        return suggestionStrategy;&#010;+    }&#010;+&#010;+    public void setSuggestionStrategy(SuggestionStrategy suggestionStrategy) {&#010;+        this.suggestionStrategy = suggestionStrategy;&#010;+    }&#010;+&#010;+    public JSonSchemaResolver getJSonSchemaResolver() {&#010;+        return jsonSchemaResolver;&#010;+    }&#010;+&#010;+    public void setJSonSchemaResolver(JSonSchemaResolver resolver) {&#010;+        this.jsonSchemaResolver = resolver;&#010;+    }&#010;+&#010;+    public boolean validateTimePattern(String pattern) {&#010;+        return validateInteger(pattern);&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateEndpointProperties(String uri) {&#010;+        return validateEndpointProperties(uri, false, false, false);&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties) {&#010;+        return validateEndpointProperties(uri, ignoreLenientProperties, false, false);&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateProperties(String scheme, Map&lt;String, String&gt; properties) {&#010;+        EndpointValidationResult result = new EndpointValidationResult(scheme);&#010;+&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+        List&lt;Map&lt;String, String&gt;&gt; componentProps = JSonSchemaHelper.parseJsonSchema(""componentProperties"", json, true);&#010;+&#010;+        // endpoint options have higher priority so remove those from component&#010;+        // that may clash&#010;+        componentProps.stream()&#010;+            .filter(c -&gt; rows.stream().noneMatch(e -&gt; Objects.equals(e.get(""name""), c.get(""name""))))&#010;+            .forEach(rows::add);&#010;+&#010;+        boolean lenient = Boolean.getBoolean(properties.getOrDefault(""lenient"", ""false""));&#010;+&#010;+        // the dataformat component refers to a data format so lets add the properties for the selected&#010;+        // data format to the list of rows&#010;+        if (""dataformat"".equals(scheme)) {&#010;+            String dfName = properties.get(""name"");&#010;+            if (dfName != null) {&#010;+                String dfJson = jsonSchemaResolver.getDataFormatJSonSchema(dfName);&#010;+                List&lt;Map&lt;String, String&gt;&gt; dfRows = JSonSchemaHelper.parseJsonSchema(""properties"", dfJson, true);&#010;+                if (dfRows != null &amp;&amp; !dfRows.isEmpty()) {&#010;+                    rows.addAll(dfRows);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        for (Map.Entry&lt;String, String&gt; property : properties.entrySet()) {&#010;+            String value = property.getValue();&#010;+            String originalName = property.getKey();&#010;+            String name = property.getKey();&#010;+            // the name may be using an optional prefix, so lets strip that because the options&#010;+            // in the schema are listed without the prefix&#010;+            name = stripOptionalPrefixFromName(rows, name);&#010;+            // the name may be using a prefix, so lets see if we can find the real property name&#010;+            String propertyName = getPropertyNameFromNameWithPrefix(rows, name);&#010;+            if (propertyName != null) {&#010;+                name = propertyName;&#010;+            }&#010;+&#010;+            String prefix = getPropertyPrefix(rows, name);&#010;+            String kind = getPropertyKind(rows, name);&#010;+            boolean namePlaceholder = name.startsWith(""{{"") &amp;&amp; name.endsWith(""}}"");&#010;+            boolean valuePlaceholder = value.startsWith(""{{"") || value.startsWith(""${"") || value.startsWith(""$simple{"");&#010;+            boolean lookup = value.startsWith(""#"") &amp;&amp; value.length() &gt; 1;&#010;+            // we cannot evaluate multi values as strict as the others, as we don't know their expected types&#010;+            boolean multiValue = prefix != null &amp;&amp; originalName.startsWith(prefix) &amp;&amp; isPropertyMultiValue(rows, name);&#010;+&#010;+            Map&lt;String, String&gt; row = getRow(rows, name);&#010;+            if (row == null) {&#010;+                // unknown option&#010;+&#010;+                // only add as error if the component is not lenient properties, or not stub component&#010;+                // and the name is not a property placeholder for one or more values&#010;+                if (!namePlaceholder &amp;&amp; !""stub"".equals(scheme)) {&#010;+                    if (lenient) {&#010;+                        // as if we are lenient then the option is a dynamic extra option which we cannot validate&#010;+                        result.addLenient(name);&#010;+                    } else {&#010;+                        // its unknown&#010;+                        result.addUnknown(name);&#010;+                        if (suggestionStrategy != null) {&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(getNames(rows), name);&#010;+                            if (suggestions != null) {&#010;+                                result.addUnknownSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+                    }&#010;+                }&#010;+            } else {&#010;+                /* TODO: we may need to add something in the properties to know if they are related to a producer or consumer&#010;+                if (""parameter"".equals(kind)) {&#010;+                    // consumer only or producer only mode for parameters&#010;+                    if (consumerOnly) {&#010;+                        boolean producer = isPropertyProducerOnly(rows, name);&#010;+                        if (producer) {&#010;+                            // the option is only for producer so you cannot use it in consumer mode&#010;+                            result.addNotConsumerOnly(name);&#010;+                        }&#010;+                    } else if (producerOnly) {&#010;+                        boolean consumer = isPropertyConsumerOnly(rows, name);&#010;+                        if (consumer) {&#010;+                            // the option is only for consumer so you cannot use it in producer mode&#010;+                            result.addNotProducerOnly(name);&#010;+                        }&#010;+                    }&#010;+                }&#010;+                */&#010;+&#010;+                // default value&#010;+                String defaultValue = getPropertyDefaultValue(rows, name);&#010;+                if (defaultValue != null) {&#010;+                    result.addDefaultValue(name, defaultValue);&#010;+                }&#010;+&#010;+                // is required but the value is empty&#010;+                boolean required = isPropertyRequired(rows, name);&#010;+                if (required &amp;&amp; isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+&#010;+                // is enum but the value is not within the enum range&#010;+                // but we can only check if the value is not a placeholder&#010;+                String enums = getPropertyEnum(rows, name);&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; enums != null) {&#010;+                    String[] choices = enums.split("","");&#010;+                    boolean found = false;&#010;+                    for (String s : choices) {&#010;+                        if (value.equalsIgnoreCase(s)) {&#010;+                            found = true;&#010;+                            break;&#010;+                        }&#010;+                    }&#010;+                    if (!found) {&#010;+                        result.addInvalidEnum(name, value);&#010;+                        result.addInvalidEnumChoices(name, choices);&#010;+                        if (suggestionStrategy != null) {&#010;+                            Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;();&#010;+                            names.addAll(Arrays.asList(choices));&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(names, value);&#010;+                            if (suggestions != null) {&#010;+                                result.addInvalidEnumSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+&#010;+                    }&#010;+                }&#010;+&#010;+                // is reference lookup of bean (not applicable for @UriPath, enums, or multi-valued)&#010;+                if (!multiValue &amp;&amp; enums == null &amp;&amp; !""path"".equals(kind) &amp;&amp; isPropertyObject(rows, name)) {&#010;+                    // must start with # and be at least 2 characters&#010;+                    if (!value.startsWith(""#"") || value.length() &lt;= 1) {&#010;+                        result.addInvalidReference(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is boolean&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyBoolean(rows, name)) {&#010;+                    // value must be a boolean&#010;+                    boolean bool = ""true"".equalsIgnoreCase(value) || ""false"".equalsIgnoreCase(value);&#010;+                    if (!bool) {&#010;+                        result.addInvalidBoolean(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is integer&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyInteger(rows, name)) {&#010;+                    // value must be an integer&#010;+                    boolean valid = validateInteger(value);&#010;+                    if (!valid) {&#010;+                        result.addInvalidInteger(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is number&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyNumber(rows, name)) {&#010;+                    // value must be an number&#010;+                    boolean valid = false;&#010;+                    try {&#010;+                        valid = !Double.valueOf(value).isNaN() || !Float.valueOf(value).isNaN();&#010;+                    } catch (Exception e) {&#010;+                        // ignore&#010;+                    }&#010;+                    if (!valid) {&#010;+                        result.addInvalidNumber(name, value);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // now check if all required values are there, and that a default value does not exists&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String name = row.get(""name"");&#010;+            boolean required = isPropertyRequired(rows, name);&#010;+            if (required) {&#010;+                String value = properties.get(name);&#010;+                if (isEmpty(value)) {&#010;+                    value = getPropertyDefaultValue(rows, name);&#010;+                }&#010;+                if (isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        return result;&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties, boolean consumerOnly, boolean producerOnly) {&#010;+        EndpointValidationResult result = new EndpointValidationResult(uri);&#010;+&#010;+        Map&lt;String, String&gt; properties;&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows;&#010;+        boolean lenientProperties;&#010;+        String scheme;&#010;+&#010;+        try {&#010;+            String json = null;&#010;+&#010;+            // parse the uri&#010;+            URI u = normalizeUri(uri);&#010;+            scheme = u.getScheme();&#010;+&#010;+            if (scheme != null) {&#010;+                json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+            }&#010;+            if (json == null) {&#010;+                // if the uri starts with a placeholder then we are also incapable of parsing it as we wasn't able to resolve the component name&#010;+                if (uri.startsWith(""{{"")) {&#010;+                    result.addIncapable(uri);&#010;+                } else if (scheme != null) {&#010;+                    result.addUnknownComponent(scheme);&#010;+                } else {&#010;+                    result.addUnknownComponent(uri);&#010;+                }&#010;+                return result;&#010;+            }&#010;+&#010;+            rows = JSonSchemaHelper.parseJsonSchema(""component"", json, false);&#010;+&#010;+            // is the component capable of both consumer and producer?&#010;+            boolean canConsumeAndProduce = false;&#010;+            if (!isComponentConsumerOnly(rows) &amp;&amp; !isComponentProducerOnly(rows)) {&#010;+                canConsumeAndProduce = true;&#010;+            }&#010;+&#010;+            if (canConsumeAndProduce &amp;&amp; consumerOnly) {&#010;+                // lenient properties is not support in consumer only mode if the component can do both of them&#010;+                lenientProperties = false;&#010;+            } else {&#010;+                // only enable lenient properties if we should not ignore&#010;+                lenientProperties = !ignoreLenientProperties &amp;&amp; isComponentLenientProperties(rows);&#010;+            }&#010;+            rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+            properties = endpointProperties(uri);&#010;+        } catch (URISyntaxException e) {&#010;+            if (uri.startsWith(""{{"")) {&#010;+                // if the uri starts with a placeholder then we are also incapable of parsing it as we wasn't able to resolve the component name&#010;+                result.addIncapable(uri);&#010;+            } else {&#010;+                result.addSyntaxError(e.getMessage());&#010;+            }&#010;+&#010;+            return result;&#010;+        }&#010;+&#010;+        // the dataformat component refers to a data format so lets add the properties for the selected&#010;+        // data format to the list of rows&#010;+        if (""dataformat"".equals(scheme)) {&#010;+            String dfName = properties.get(""name"");&#010;+            if (dfName != null) {&#010;+                String dfJson = jsonSchemaResolver.getDataFormatJSonSchema(dfName);&#010;+                List&lt;Map&lt;String, String&gt;&gt; dfRows = JSonSchemaHelper.parseJsonSchema(""properties"", dfJson, true);&#010;+                if (dfRows != null &amp;&amp; !dfRows.isEmpty()) {&#010;+                    rows.addAll(dfRows);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        for (Map.Entry&lt;String, String&gt; property : properties.entrySet()) {&#010;+            String value = property.getValue();&#010;+            String originalName = property.getKey();&#010;+            String name = property.getKey();&#010;+            // the name may be using an optional prefix, so lets strip that because the options&#010;+            // in the schema are listed without the prefix&#010;+            name = stripOptionalPrefixFromName(rows, name);&#010;+            // the name may be using a prefix, so lets see if we can find the real property name&#010;+            String propertyName = getPropertyNameFromNameWithPrefix(rows, name);&#010;+            if (propertyName != null) {&#010;+                name = propertyName;&#010;+            }&#010;+&#010;+            String prefix = getPropertyPrefix(rows, name);&#010;+            String kind = getPropertyKind(rows, name);&#010;+            boolean namePlaceholder = name.startsWith(""{{"") &amp;&amp; name.endsWith(""}}"");&#010;+            boolean valuePlaceholder = value.startsWith(""{{"") || value.startsWith(""${"") || value.startsWith(""$simple{"");&#010;+            boolean lookup = value.startsWith(""#"") &amp;&amp; value.length() &gt; 1;&#010;+            // we cannot evaluate multi values as strict as the others, as we don't know their expected types&#010;+            boolean mulitValue = prefix != null &amp;&amp; originalName.startsWith(prefix) &amp;&amp; isPropertyMultiValue(rows, name);&#010;+&#010;+            Map&lt;String, String&gt; row = getRow(rows, name);&#010;+            if (row == null) {&#010;+                // unknown option&#010;+&#010;+                // only add as error if the component is not lenient properties, or not stub component&#010;+                // and the name is not a property placeholder for one or more values&#010;+                if (!namePlaceholder &amp;&amp; !""stub"".equals(scheme)) {&#010;+                    if (lenientProperties) {&#010;+                        // as if we are lenient then the option is a dynamic extra option which we cannot validate&#010;+                        result.addLenient(name);&#010;+                    } else {&#010;+                        // its unknown&#010;+                        result.addUnknown(name);&#010;+                        if (suggestionStrategy != null) {&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(getNames(rows), name);&#010;+                            if (suggestions != null) {&#010;+                                result.addUnknownSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+                    }&#010;+                }&#010;+            } else {&#010;+                if (""parameter"".equals(kind)) {&#010;+                    // consumer only or producer only mode for parameters&#010;+                    if (consumerOnly) {&#010;+                        boolean producer = isPropertyProducerOnly(rows, name);&#010;+                        if (producer) {&#010;+                            // the option is only for producer so you cannot use it in consumer mode&#010;+                            result.addNotConsumerOnly(name);&#010;+                        }&#010;+                    } else if (producerOnly) {&#010;+                        boolean consumer = isPropertyConsumerOnly(rows, name);&#010;+                        if (consumer) {&#010;+                            // the option is only for consumer so you cannot use it in producer mode&#010;+                            result.addNotProducerOnly(name);&#010;+                        }&#010;+                    }&#010;+                }&#010;+&#010;+                // default value&#010;+                String defaultValue = getPropertyDefaultValue(rows, name);&#010;+                if (defaultValue != null) {&#010;+                    result.addDefaultValue(name, defaultValue);&#010;+                }&#010;+&#010;+                // is required but the value is empty&#010;+                boolean required = isPropertyRequired(rows, name);&#010;+                if (required &amp;&amp; isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+&#010;+                // is enum but the value is not within the enum range&#010;+                // but we can only check if the value is not a placeholder&#010;+                String enums = getPropertyEnum(rows, name);&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; enums != null) {&#010;+                    String[] choices = enums.split("","");&#010;+                    boolean found = false;&#010;+                    for (String s : choices) {&#010;+                        if (value.equalsIgnoreCase(s)) {&#010;+                            found = true;&#010;+                            break;&#010;+                        }&#010;+                    }&#010;+                    if (!found) {&#010;+                        result.addInvalidEnum(name, value);&#010;+                        result.addInvalidEnumChoices(name, choices);&#010;+                        if (suggestionStrategy != null) {&#010;+                            Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;();&#010;+                            names.addAll(Arrays.asList(choices));&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(names, value);&#010;+                            if (suggestions != null) {&#010;+                                result.addInvalidEnumSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+&#010;+                    }&#010;+                }&#010;+&#010;+                // is reference lookup of bean (not applicable for @UriPath, enums, or multi-valued)&#010;+                if (!mulitValue &amp;&amp; enums == null &amp;&amp; !""path"".equals(kind) &amp;&amp; isPropertyObject(rows, name)) {&#010;+                    // must start with # and be at least 2 characters&#010;+                    if (!value.startsWith(""#"") || value.length() &lt;= 1) {&#010;+                        result.addInvalidReference(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is boolean&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyBoolean(rows, name)) {&#010;+                    // value must be a boolean&#010;+                    boolean bool = ""true"".equalsIgnoreCase(value) || ""false"".equalsIgnoreCase(value);&#010;+                    if (!bool) {&#010;+                        result.addInvalidBoolean(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is integer&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyInteger(rows, name)) {&#010;+                    // value must be an integer&#010;+                    boolean valid = validateInteger(value);&#010;+                    if (!valid) {&#010;+                        result.addInvalidInteger(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is number&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyNumber(rows, name)) {&#010;+                    // value must be an number&#010;+                    boolean valid = false;&#010;+                    try {&#010;+                        valid = !Double.valueOf(value).isNaN() || !Float.valueOf(value).isNaN();&#010;+                    } catch (Exception e) {&#010;+                        // ignore&#010;+                    }&#010;+                    if (!valid) {&#010;+                        result.addInvalidNumber(name, value);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // now check if all required values are there, and that a default value does not exists&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String name = row.get(""name"");&#010;+            boolean required = isPropertyRequired(rows, name);&#010;+            if (required) {&#010;+                String value = properties.get(name);&#010;+                if (isEmpty(value)) {&#010;+                    value = getPropertyDefaultValue(rows, name);&#010;+                }&#010;+                if (isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        return result;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; endpointProperties(String uri) throws URISyntaxException {&#010;+        // need to normalize uri first&#010;+        URI u = normalizeUri(uri);&#010;+        String scheme = u.getScheme();&#010;+&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        if (json == null) {&#010;+            throw new IllegalArgumentException(""Cannot find endpoint with scheme "" + scheme);&#010;+        }&#010;+&#010;+        // grab the syntax&#010;+        String syntax = null;&#010;+        String alternativeSyntax = null;&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""component"", json, false);&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""syntax"")) {&#010;+                syntax = row.get(""syntax"");&#010;+            }&#010;+            if (row.containsKey(""alternativeSyntax"")) {&#010;+                alternativeSyntax = row.get(""alternativeSyntax"");&#010;+            }&#010;+        }&#010;+        if (syntax == null) {&#010;+            throw new IllegalArgumentException(""Endpoint with scheme "" + scheme + "" has no syntax defined in the json schema"");&#010;+        }&#010;+&#010;+        // only if we support alternative syntax, and the uri contains the username and password in the authority&#010;+        // part of the uri, then we would need some special logic to capture that information and strip those&#010;+        // details from the uri, so we can continue parsing the uri using the normal syntax&#010;+        Map&lt;String, String&gt; userInfoOptions = new LinkedHashMap&lt;String, String&gt;();&#010;+        if (alternativeSyntax != null &amp;&amp; alternativeSyntax.contains(""@"")) {&#010;+            // clip the scheme from the syntax&#010;+            alternativeSyntax = after(alternativeSyntax, "":"");&#010;+            // trim so only userinfo&#010;+            int idx = alternativeSyntax.indexOf(""@"");&#010;+            String fields = alternativeSyntax.substring(0, idx);&#010;+            String[] names = fields.split("":"");&#010;+&#010;+            // grab authority part and grab username and/or password&#010;+            String authority = u.getAuthority();&#010;+            if (authority != null &amp;&amp; authority.contains(""@"")) {&#010;+                String username = null;&#010;+                String password = null;&#010;+&#010;+                // grab unserinfo part before @&#010;+                String userInfo = authority.substring(0, authority.indexOf(""@""));&#010;+                String[] parts = userInfo.split("":"");&#010;+                if (parts.length == 2) {&#010;+                    username = parts[0];&#010;+                    password = parts[1];&#010;+                } else {&#010;+                    // only username&#010;+                    username = userInfo;&#010;+                }&#010;+&#010;+                // remember the username and/or password which we add later to the options&#010;+                if (names.length == 2) {&#010;+                    userInfoOptions.put(names[0], username);&#010;+                    if (password != null) {&#010;+                        // password is optional&#010;+                        userInfoOptions.put(names[1], password);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // clip the scheme from the syntax&#010;+        syntax = after(syntax, "":"");&#010;+        // clip the scheme from the uri&#010;+        uri = after(uri, "":"");&#010;+        String uriPath = stripQuery(uri);&#010;+&#010;+        // strip user info from uri path&#010;+        if (!userInfoOptions.isEmpty()) {&#010;+            int idx = uriPath.indexOf('@');&#010;+            if (idx &gt; -1) {&#010;+                uriPath = uriPath.substring(idx + 1);&#010;+            }&#010;+        }&#010;+&#010;+        // strip double slash in the start&#010;+        if (uriPath != null &amp;&amp; uriPath.startsWith(""//"")) {&#010;+            uriPath = uriPath.substring(2);&#010;+        }&#010;+&#010;+        // parse the syntax and find the names of each option&#010;+        Matcher matcher = SYNTAX_PATTERN.matcher(syntax);&#010;+        List&lt;String&gt; word = new ArrayList&lt;String&gt;();&#010;+        while (matcher.find()) {&#010;+            String s = matcher.group(1);&#010;+            if (!scheme.equals(s)) {&#010;+                word.add(s);&#010;+            }&#010;+        }&#010;+        // parse the syntax and find each token between each option&#010;+        String[] tokens = SYNTAX_PATTERN.split(syntax);&#010;+&#010;+        // find the position where each option start/end&#010;+        List&lt;String&gt; word2 = new ArrayList&lt;String&gt;();&#010;+        int prev = 0;&#010;+        int prevPath = 0;&#010;+&#010;+        // special for activemq/jms where the enum for destinationType causes a token issue as it includes a colon&#010;+        // for 'temp:queue' and 'temp:topic' values&#010;+        if (""activemq"".equals(scheme) || ""jms"".equals(scheme)) {&#010;+            if (uriPath.startsWith(""temp:"")) {&#010;+                prevPath = 5;&#010;+            }&#010;+        }&#010;+&#010;+        for (String token : tokens) {&#010;+            if (token.isEmpty()) {&#010;+                continue;&#010;+            }&#010;+&#010;+            // special for some tokens where :// can be used also, eg http://foo&#010;+            int idx = -1;&#010;+            int len = 0;&#010;+            if ("":"".equals(token)) {&#010;+                idx = uriPath.indexOf(""://"", prevPath);&#010;+                len = 3;&#010;+            }&#010;+            if (idx == -1) {&#010;+                idx = uriPath.indexOf(token, prevPath);&#010;+                len = token.length();&#010;+            }&#010;+&#010;+            if (idx &gt; 0) {&#010;+                String option = uriPath.substring(prev, idx);&#010;+                word2.add(option);&#010;+                prev = idx + len;&#010;+                prevPath = prev;&#010;+            }&#010;+        }&#010;+        // special for last or if we did not add anyone&#010;+        if (prev &gt; 0 || word2.isEmpty()) {&#010;+            String option = uriPath.substring(prev);&#010;+            word2.add(option);&#010;+        }&#010;+&#010;+        rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        boolean defaultValueAdded = false;&#010;+&#010;+        // now parse the uri to know which part isw what&#010;+        Map&lt;String, String&gt; options = new LinkedHashMap&lt;String, String&gt;();&#010;+&#010;+        // include the username and password from the userinfo section&#010;+        if (!userInfoOptions.isEmpty()) {&#010;+            options.putAll(userInfoOptions);&#010;+        }&#010;+&#010;+        // word contains the syntax path elements&#010;+        Iterator&lt;String&gt; it = word2.iterator();&#010;+        for (int i = 0; i &lt; word.size(); i++) {&#010;+            String key = word.get(i);&#010;+&#010;+            boolean allOptions = word.size() == word2.size();&#010;+            boolean required = isPropertyRequired(rows, key);&#010;+            String defaultValue = getPropertyDefaultValue(rows, key);&#010;+&#010;+            // we have all options so no problem&#010;+            if (allOptions) {&#010;+                String value = it.next();&#010;+                options.put(key, value);&#010;+            } else {&#010;+                // we have a little problem as we do not not have all options&#010;+                if (!required) {&#010;+                    String value = null;&#010;+&#010;+                    boolean last = i == word.size() - 1;&#010;+                    if (last) {&#010;+                        // if its the last value then use it instead of the default value&#010;+                        value = it.hasNext() ? it.next() : null;&#010;+                        if (value != null) {&#010;+                            options.put(key, value);&#010;+                        } else {&#010;+                            value = defaultValue;&#010;+                        }&#010;+                    }&#010;+                    if (value != null) {&#010;+                        options.put(key, value);&#010;+                        defaultValueAdded = true;&#010;+                    }&#010;+                } else {&#010;+                    String value = it.hasNext() ? it.next() : null;&#010;+                    if (value != null) {&#010;+                        options.put(key, value);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        Map&lt;String, String&gt; answer = new LinkedHashMap&lt;String, String&gt;();&#010;+&#010;+        // remove all options which are using default values and are not required&#010;+        for (Map.Entry&lt;String, String&gt; entry : options.entrySet()) {&#010;+            String key = entry.getKey();&#010;+            String value = entry.getValue();&#010;+&#010;+            if (defaultValueAdded) {&#010;+                boolean required = isPropertyRequired(rows, key);&#010;+                String defaultValue = getPropertyDefaultValue(rows, key);&#010;+&#010;+                if (!required &amp;&amp; defaultValue != null) {&#010;+                    if (defaultValue.equals(value)) {&#010;+                        continue;&#010;+                    }&#010;+                }&#010;+            }&#010;+&#010;+            // we should keep this in the answer&#010;+            answer.put(key, value);&#010;+        }&#010;+&#010;+        // now parse the uri parameters&#010;+        Map&lt;String, Object&gt; parameters = URISupport.parseParameters(u);&#010;+&#010;+        // and covert the values to String so its JMX friendly&#010;+        while (!parameters.isEmpty()) {&#010;+            Map.Entry&lt;String, Object&gt; entry = parameters.entrySet().iterator().next();&#010;+            String key = entry.getKey();&#010;+            String value = entry.getValue() != null ? entry.getValue().toString() : """";&#010;+&#010;+            boolean multiValued = isPropertyMultiValue(rows, key);&#010;+            if (multiValued) {&#010;+                String prefix = getPropertyPrefix(rows, key);&#010;+                // extra all the multi valued options&#010;+                Map&lt;String, Object&gt; values = URISupport.extractProperties(parameters, prefix);&#010;+                // build a string with the extra multi valued options with the prefix and &amp; as separator&#010;+                CollectionStringBuffer csb = new CollectionStringBuffer(""&amp;"");&#010;+                for (Map.Entry&lt;String, Object&gt; multi : values.entrySet()) {&#010;+                    String line = prefix + multi.getKey() + ""="" + (multi.getValue() != null ? multi.getValue().toString() : """");&#010;+                    csb.append(line);&#010;+                }&#010;+                // append the extra multi-values to the existing (which contains the first multi value)&#010;+                if (!csb.isEmpty()) {&#010;+                    value = value + ""&amp;"" + csb.toString();&#010;+                }&#010;+            }&#010;+&#010;+            answer.put(key, value);&#010;+            // remove the parameter as we run in a while loop until no more parameters&#010;+            parameters.remove(key);&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; endpointLenientProperties(String uri) throws URISyntaxException {&#010;+        // need to normalize uri first&#010;+&#010;+        // parse the uri&#010;+        URI u = normalizeUri(uri);&#010;+        String scheme = u.getScheme();&#010;+&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        if (json == null) {&#010;+            throw new IllegalArgumentException(""Cannot find endpoint with scheme "" + scheme);&#010;+        }&#010;+&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        // now parse the uri parameters&#010;+        Map&lt;String, Object&gt; parameters = URISupport.parseParameters(u);&#010;+&#010;+        // all the known options&#010;+        Set&lt;String&gt; names = getNames(rows);&#010;+&#010;+        Map&lt;String, String&gt; answer = new LinkedHashMap&lt;&gt;();&#010;+&#010;+        // and covert the values to String so its JMX friendly&#010;+        parameters.forEach((k, v) -&gt; {&#010;+            String key = k;&#010;+            String value = v != null ? v.toString() : """";&#010;+&#010;+            // is the key a prefix property&#010;+            int dot = key.indexOf('.');&#010;+            if (dot != -1) {&#010;+                String prefix = key.substring(0, dot + 1); // include dot in prefix&#010;+                String option = getPropertyNameFromNameWithPrefix(rows, prefix);&#010;+                if (option == null || !isPropertyMultiValue(rows, option)) {&#010;+                    answer.put(key, value);&#010;+                }&#010;+            } else if (!names.contains(key)) {&#010;+                answer.put(key, value);&#010;+            }&#010;+        });&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    public String endpointComponentName(String uri) {&#010;+        if (uri != null) {&#010;+            int idx = uri.indexOf("":"");&#010;+            if (idx &gt; 0) {&#010;+                return uri.substring(0, idx);&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public String asEndpointUri(String scheme, String json, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, json, ""&amp;"", encode);&#010;+    }&#010;+&#010;+    public String asEndpointUriXml(String scheme, String json, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, json, ""&amp;amp;"", encode);&#010;+    }&#010;+&#010;+    private String doAsEndpointUri(String scheme, String json, String ampersand, boolean encode) throws URISyntaxException {&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        Map&lt;String, String&gt; copy = new HashMap&lt;String, String&gt;();&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String name = row.get(""name"");&#010;+            String required = row.get(""required"");&#010;+            String value = row.get(""value"");&#010;+            String defaultValue = row.get(""defaultValue"");&#010;+&#010;+            // only add if either required, or the value is != default value&#010;+            String valueToAdd = null;&#010;+            if (""true"".equals(required)) {&#010;+                valueToAdd = value != null ? value : defaultValue;&#010;+                if (valueToAdd == null) {&#010;+                    valueToAdd = """";&#010;+                }&#010;+            } else {&#010;+                // if we have a value and no default then add it&#010;+                if (value != null &amp;&amp; defaultValue == null) {&#010;+                    valueToAdd = value;&#010;+                }&#010;+                // otherwise only add if the value is != default value&#010;+                if (value != null &amp;&amp; defaultValue != null &amp;&amp; !value.equals(defaultValue)) {&#010;+                    valueToAdd = value;&#010;+                }&#010;+            }&#010;+&#010;+            if (valueToAdd != null) {&#010;+                copy.put(name, valueToAdd);&#010;+            }&#010;+        }&#010;+&#010;+        return doAsEndpointUri(scheme, copy, ampersand, encode);&#010;+    }&#010;+&#010;+    public String asEndpointUri(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, properties, ""&amp;"", encode);&#010;+    }&#010;+&#010;+    public String asEndpointUriXml(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, properties, ""&amp;amp;"", encode);&#010;+    }&#010;+&#010;+    String doAsEndpointUri(String scheme, Map&lt;String, String&gt; properties, String ampersand, boolean encode) throws URISyntaxException {&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        if (json == null) {&#010;+            throw new IllegalArgumentException(""Cannot find endpoint with scheme "" + scheme);&#010;+        }&#010;+&#010;+        // grab the syntax&#010;+        String syntax = null;&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""component"", json, false);&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""syntax"")) {&#010;+                syntax = row.get(""syntax"");&#010;+                break;&#010;+            }&#010;+        }&#010;+        if (syntax == null) {&#010;+            throw new IllegalArgumentException(""Endpoint with scheme "" + scheme + "" has no syntax defined in the json schema"");&#010;+        }&#010;+&#010;+        // do any properties filtering which can be needed for some special components&#010;+        properties = filterProperties(scheme, properties);&#010;+&#010;+        rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        // clip the scheme from the syntax&#010;+        syntax = after(syntax, "":"");&#010;+&#010;+        String originalSyntax = syntax;&#010;+&#010;+        // build at first according to syntax (use a tree map as we want the uri options sorted)&#010;+        Map&lt;String, String&gt; copy = new TreeMap&lt;String, String&gt;();&#010;+        for (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) {&#010;+            String key = entry.getKey();&#010;+            String value = entry.getValue() != null ? entry.getValue() : """";&#010;+            if (syntax != null &amp;&amp; syntax.contains(key)) {&#010;+                syntax = syntax.replace(key, value);&#010;+            } else {&#010;+                copy.put(key, value);&#010;+            }&#010;+        }&#010;+&#010;+        // do we have all the options the original syntax needs (easy way)&#010;+        String[] keys = syntaxKeys(originalSyntax);&#010;+        boolean hasAllKeys = properties.keySet().containsAll(Arrays.asList(keys));&#010;+&#010;+        // build endpoint uri&#010;+        StringBuilder sb = new StringBuilder();&#010;+        sb.append(scheme);&#010;+        sb.append("":"");&#010;+&#010;+        if (hasAllKeys) {&#010;+            // we have all the keys for the syntax so we can build the uri the easy way&#010;+            sb.append(syntax);&#010;+&#010;+            if (!copy.isEmpty()) {&#010;+                boolean hasQuestionmark = sb.toString().contains(""?"");&#010;+                // the last option may already contain a ? char, if so we should use &amp; instead of ?&#010;+                sb.append(hasQuestionmark ? ampersand : '?');&#010;+                String query = createQueryString(copy, ampersand, encode);&#010;+                sb.append(query);&#010;+            }&#010;+        } else {&#010;+            // TODO: revisit this and see if we can do this in another way&#010;+            // oh darn some options is missing, so we need a complex way of building the uri&#010;+&#010;+            // the tokens between the options in the path&#010;+            String[] tokens = syntax.split(""\\w+"");&#010;+&#010;+            // parse the syntax into each options&#010;+            Matcher matcher = SYNTAX_PATTERN.matcher(originalSyntax);&#010;+            List&lt;String&gt; options = new ArrayList&lt;String&gt;();&#010;+            while (matcher.find()) {&#010;+                String s = matcher.group(1);&#010;+                options.add(s);&#010;+            }&#010;+&#010;+            // need to preserve {{ and }} from the syntax&#010;+            // (we need to use words only as its provisional placeholders)&#010;+            syntax = syntax.replaceAll(""\\{\\{"", ""BEGINCAMELPLACEHOLDER"");&#010;+            syntax = syntax.replaceAll(""\\}\\}"", ""ENDCAMELPLACEHOLDER"");&#010;+&#010;+            // parse the syntax into each options&#010;+            Matcher matcher2 = SYNTAX_PATTERN.matcher(syntax);&#010;+            List&lt;String&gt; options2 = new ArrayList&lt;String&gt;();&#010;+            while (matcher2.find()) {&#010;+                String s = matcher2.group(1);&#010;+                s = s.replaceAll(""BEGINCAMELPLACEHOLDER"", ""\\{\\{"");&#010;+                s = s.replaceAll(""ENDCAMELPLACEHOLDER"", ""\\}\\}"");&#010;+                options2.add(s);&#010;+            }&#010;+&#010;+            // build the endpoint&#010;+            int range = 0;&#010;+            boolean first = true;&#010;+            boolean hasQuestionmark = false;&#010;+            for (int i = 0; i &lt; options.size(); i++) {&#010;+                String key = options.get(i);&#010;+                String key2 = options2.get(i);&#010;+                String token = null;&#010;+                if (tokens.length &gt; i) {&#010;+                    token = tokens[i];&#010;+                }&#010;+&#010;+                boolean contains = properties.containsKey(key);&#010;+                if (!contains) {&#010;+                    // if the key are similar we have no explicit value and can try to find a default value if the option is required&#010;+                    if (isPropertyRequired(rows, key)) {&#010;+                        String value = getPropertyDefaultValue(rows, key);&#010;+                        if (value != null) {&#010;+                            properties.put(key, value);&#010;+                            key2 = value;&#010;+                        }&#010;+                    }&#010;+                }&#010;+&#010;+                // was the option provided?&#010;+                if (properties.containsKey(key)) {&#010;+                    if (!first &amp;&amp; token != null) {&#010;+                        sb.append(token);&#010;+                    }&#010;+                    hasQuestionmark |= key.contains(""?"") || (token != null &amp;&amp; token.contains(""?""));&#010;+                    sb.append(key2);&#010;+                    first = false;&#010;+                }&#010;+                range++;&#010;+            }&#010;+            // append any extra options that was in surplus for the last&#010;+            while (range &lt; options2.size()) {&#010;+                String token = null;&#010;+                if (tokens.length &gt; range) {&#010;+                    token = tokens[range];&#010;+                }&#010;+                String key2 = options2.get(range);&#010;+                sb.append(token);&#010;+                sb.append(key2);&#010;+                hasQuestionmark |= key2.contains(""?"") || (token != null &amp;&amp; token.contains(""?""));&#010;+                range++;&#010;+            }&#010;+&#010;+&#010;+            if (!copy.isEmpty()) {&#010;+                // the last option may already contain a ? char, if so we should use &amp; instead of ?&#010;+                sb.append(hasQuestionmark ? ampersand : '?');&#010;+                String query = createQueryString(copy, ampersand, encode);&#010;+                sb.append(query);&#010;+            }&#010;+        }&#010;+&#010;+        return sb.toString();&#010;+    }&#010;+&#010;+    @Deprecated&#010;+    private static String[] syntaxTokens(String syntax) {&#010;+        // build tokens between the words&#010;+        List&lt;String&gt; tokens = new ArrayList&lt;&gt;();&#010;+        // preserve backwards behavior which had an empty token first&#010;+        tokens.add("""");&#010;+&#010;+        String current = """";&#010;+        for (int i = 0; i &lt; syntax.length(); i++) {&#010;+            char ch = syntax.charAt(i);&#010;+            if (Character.isLetterOrDigit(ch)) {&#010;+                // reset for new current tokens&#010;+                if (current.length() &gt; 0) {&#010;+                    tokens.add(current);&#010;+                    current = """";&#010;+                }&#010;+            } else {&#010;+                current += ch;&#010;+            }&#010;+        }&#010;+        // anything left over?&#010;+        if (current.length() &gt; 0) {&#010;+            tokens.add(current);&#010;+        }&#010;+&#010;+        return tokens.toArray(new String[tokens.size()]);&#010;+    }&#010;+&#010;+    private static String[] syntaxKeys(String syntax) {&#010;+        // build tokens between the separators&#010;+        List&lt;String&gt; tokens = new ArrayList&lt;&gt;();&#010;+&#010;+        String current = """";&#010;+        for (int i = 0; i &lt; syntax.length(); i++) {&#010;+            char ch = syntax.charAt(i);&#010;+            if (Character.isLetterOrDigit(ch)) {&#010;+                current += ch;&#010;+            } else {&#010;+                // reset for new current tokens&#010;+                if (current.length() &gt; 0) {&#010;+                    tokens.add(current);&#010;+                    current = """";&#010;+                }&#010;+            }&#010;+        }&#010;+        // anything left over?&#010;+        if (current.length() &gt; 0) {&#010;+            tokens.add(current);&#010;+        }&#010;+&#010;+        return tokens.toArray(new String[tokens.size()]);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimpleExpression(String simple) {&#010;+        return doValidateSimple(null, simple, false);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimpleExpression(ClassLoader classLoader, String simple) {&#010;+        return doValidateSimple(classLoader, simple, false);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimplePredicate(String simple) {&#010;+        return doValidateSimple(null, simple, true);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimplePredicate(ClassLoader classLoader, String simple) {&#010;+        return doValidateSimple(classLoader, simple, true);&#010;+    }&#010;+&#010;+    private SimpleValidationResult doValidateSimple(ClassLoader classLoader, String simple, boolean predicate) {&#010;+        if (classLoader == null) {&#010;+            classLoader = getClass().getClassLoader();&#010;+        }&#010;+&#010;+        // if there are {{ }}} property placeholders then we need to resolve them to something else&#010;+        // as the simple parse cannot resolve them before parsing as we dont run the actual Camel application&#010;+        // with property placeholders setup so we need to dummy this by replace the {{ }} to something else&#010;+        // therefore we use an more unlikely character: {{XXX}} to ~^XXX^~&#010;+        String resolved = simple.replaceAll(""\\{\\{(.+)\\}\\}"", ""~^$1^~"");&#010;+&#010;+        SimpleValidationResult answer = new SimpleValidationResult(simple);&#010;+&#010;+        Object instance = null;&#010;+        Class clazz = null;&#010;+        try {&#010;+            clazz = classLoader.loadClass(""org.apache.camel.language.simple.SimpleLanguage"");&#010;+            instance = clazz.newInstance();&#010;+        } catch (Exception e) {&#010;+            // ignore&#010;+        }&#010;+&#010;+        if (clazz != null &amp;&amp; instance != null) {&#010;+            Throwable cause = null;&#010;+            try {&#010;+                if (predicate) {&#010;+                    instance.getClass().getMethod(""createPredicate"", String.class).invoke(instance, resolved);&#010;+                } else {&#010;+                    instance.getClass().getMethod(""createExpression"", String.class).invoke(instance, resolved);&#010;+                }&#010;+            } catch (InvocationTargetException e) {&#010;+                cause = e.getTargetException();&#010;+            } catch (Exception e) {&#010;+                cause = e;&#010;+            }&#010;+&#010;+            if (cause != null) {&#010;+&#010;+                // reverse ~^XXX^~ back to {{XXX}}&#010;+                String errMsg = cause.getMessage();&#010;+                errMsg = errMsg.replaceAll(""\\~\\^(.+)\\^\\~"", ""{{$1}}"");&#010;+&#010;+                answer.setError(errMsg);&#010;+&#010;+                // is it simple parser exception then we can grab the index where the problem is&#010;+                if (cause.getClass().getName().equals(""org.apache.camel.language.simple.types.SimpleIllegalSyntaxException"")&#010;+                    || cause.getClass().getName().equals(""org.apache.camel.language.simple.types.SimpleParserException"")) {&#010;+                    try {&#010;+                        // we need to grab the index field from those simple parser exceptions&#010;+                        Method method = cause.getClass().getMethod(""getIndex"");&#010;+                        Object result = method.invoke(cause);&#010;+                        if (result != null) {&#010;+                            int index = (int) result;&#010;+                            answer.setIndex(index);&#010;+                        }&#010;+                    } catch (Throwable i) {&#010;+                        // ignore&#010;+                    }&#010;+                }&#010;+&#010;+                // we need to grab the short message field from this simple syntax exception&#010;+                if (cause.getClass().getName().equals(""org.apache.camel.language.simple.types.SimpleIllegalSyntaxException"")) {&#010;+                    try {&#010;+                        Method method = cause.getClass().getMethod(""getShortMessage"");&#010;+                        Object result = method.invoke(cause);&#010;+                        if (result != null) {&#010;+                            String msg = (String) result;&#010;+                            answer.setShortError(msg);&#010;+                        }&#010;+                    } catch (Throwable i) {&#010;+                        // ignore&#010;+                    }&#010;+&#010;+                    if (answer.getShortError() == null) {&#010;+                        // fallback and try to make existing message short instead&#010;+                        String msg = answer.getError();&#010;+                        // grab everything before "" at location "" which would be regarded as the short message&#010;+                        int idx = msg.indexOf("" at location "");&#010;+                        if (idx &gt; 0) {&#010;+                            msg = msg.substring(0, idx);&#010;+                            answer.setShortError(msg);&#010;+                        }&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    public LanguageValidationResult validateLanguagePredicate(ClassLoader classLoader, String language, String text) {&#010;+        return doValidateLanguage(classLoader, language, text, true);&#010;+    }&#010;+&#010;+    public LanguageValidationResult validateLanguageExpression(ClassLoader classLoader, String language, String text) {&#010;+        return doValidateLanguage(classLoader, language, text, false);&#010;+    }&#010;+&#010;+    private LanguageValidationResult doValidateLanguage(ClassLoader classLoader, String language, String text, boolean predicate) {&#010;+        if (classLoader == null) {&#010;+            classLoader = getClass().getClassLoader();&#010;+        }&#010;+&#010;+        SimpleValidationResult answer = new SimpleValidationResult(text);&#010;+&#010;+        String json = jsonSchemaResolver.getLanguageJSonSchema(language);&#010;+        if (json == null) {&#010;+            answer.setError(""Unknown language "" + language);&#010;+            return answer;&#010;+        }&#010;+&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""language"", json, false);&#010;+        String className = null;&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""javaType"")) {&#010;+                className = row.get(""javaType"");&#010;+            }&#010;+        }&#010;+&#010;+        if (className == null) {&#010;+            answer.setError(""Cannot find javaType for language "" + language);&#010;+            return answer;&#010;+        }&#010;+&#010;+        Object instance = null;&#010;+        Class clazz = null;&#010;+        try {&#010;+            clazz = classLoader.loadClass(className);&#010;+            instance = clazz.newInstance();&#010;+        } catch (Exception e) {&#010;+            // ignore&#010;+        }&#010;+&#010;+        if (clazz != null &amp;&amp; instance != null) {&#010;+            Throwable cause = null;&#010;+            try {&#010;+                if (predicate) {&#010;+                    instance.getClass().getMethod(""createPredicate"", String.class).invoke(instance, text);&#010;+                } else {&#010;+                    instance.getClass().getMethod(""createExpression"", String.class).invoke(instance, text);&#010;+                }&#010;+            } catch (InvocationTargetException e) {&#010;+                cause = e.getTargetException();&#010;+            } catch (Exception e) {&#010;+                cause = e;&#010;+            }&#010;+&#010;+            if (cause != null) {&#010;+                answer.setError(cause.getMessage());&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    /**&#010;+     * Special logic for log endpoints to deal when showAll=true&#010;+     */&#010;+    private Map&lt;String, String&gt; filterProperties(String scheme, Map&lt;String, String&gt; options) {&#010;+        if (""log"".equals(scheme)) {&#010;+            String showAll = options.get(""showAll"");&#010;+            if (""true"".equals(showAll)) {&#010;+                Map&lt;String, String&gt; filtered = new LinkedHashMap&lt;String, String&gt;();&#010;+                // remove all the other showXXX options when showAll=true&#010;+                for (Map.Entry&lt;String, String&gt; entry : options.entrySet()) {&#010;+                    String key = entry.getKey();&#010;+                    boolean skip = key.startsWith(""show"") &amp;&amp; !key.equals(""showAll"");&#010;+                    if (!skip) {&#010;+                        filtered.put(key, entry.getValue());&#010;+                    }&#010;+                }&#010;+                return filtered;&#010;+            }&#010;+        }&#010;+        // use as-is&#010;+        return options;&#010;+    }&#010;+&#010;+    private static boolean validateInteger(String value) {&#010;+        boolean valid = false;&#010;+        try {&#010;+            valid = Integer.valueOf(value) != null;&#010;+        } catch (Exception e) {&#010;+            // ignore&#010;+        }&#010;+        if (!valid) {&#010;+            // it may be a time pattern, such as 5s for 5 seconds = 5000&#010;+            try {&#010;+                TimePatternConverter.toMilliSeconds(value);&#010;+                valid = true;&#010;+            } catch (Exception e) {&#010;+                // ignore&#010;+            }&#010;+        }&#010;+        return valid;&#010;+    }&#010;+&#010;+    // CHECKSTYLE:ON&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java&#010;new file mode 100644&#010;index 0000000..d3a448c&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java&#010;@@ -0,0 +1,80 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.IOException;&#010;+&#010;+import org.apache.camel.CamelContext;&#010;+&#010;+/**&#010;+ * Uses runtime {@link CamelContext} to resolve the JSon schema files.&#010;+ */&#010;+public class CamelContextJSonSchemaResolver implements JSonSchemaResolver {&#010;+&#010;+    private final CamelContext camelContext;&#010;+&#010;+    public CamelContextJSonSchemaResolver(CamelContext camelContext) {&#010;+        this.camelContext = camelContext;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getComponentJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getComponentParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getDataFormatJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getDataFormatParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getLanguageJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getLanguageParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getOtherJSonSchema(String name) {&#010;+        // not supported&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getModelJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getEipParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java&#010;new file mode 100644&#010;index 0000000..1b224df&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java&#010;@@ -0,0 +1,179 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.BufferedReader;&#010;+import java.io.IOException;&#010;+import java.io.InputStream;&#010;+import java.io.InputStreamReader;&#010;+import java.io.LineNumberReader;&#010;+import java.util.List;&#010;+&#010;+public final class CatalogHelper {&#010;+&#010;+    private CatalogHelper() {&#010;+    }&#010;+&#010;+    /**&#010;+     * Loads the entire stream into memory as a String and returns it.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Notice:&lt;/b&gt; This implementation appends a &lt;tt&gt;\n&lt;/tt&gt; as line&#010;+     * terminator at the of the text.&#010;+     * &lt;p/&gt;&#010;+     * Warning, don't use for crazy big streams :)&#010;+     */&#010;+    public static void loadLines(InputStream in, List&lt;String&gt; lines) throws IOException {&#010;+        try (final InputStreamReader isr = new InputStreamReader(in);&#010;+            final BufferedReader reader = new LineNumberReader(isr)) {&#010;+            String line;&#010;+            while ((line = reader.readLine()) != null) {&#010;+                lines.add(line);&#010;+            }&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Loads the entire stream into memory as a String and returns it.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Notice:&lt;/b&gt; This implementation appends a &lt;tt&gt;\n&lt;/tt&gt; as line&#010;+     * terminator at the of the text.&#010;+     * &lt;p/&gt;&#010;+     * Warning, don't use for crazy big streams :)&#010;+     */&#010;+    public static String loadText(InputStream in) throws IOException {&#010;+        StringBuilder builder = new StringBuilder();&#010;+        try (final InputStreamReader isr = new InputStreamReader(in);&#010;+            final BufferedReader reader = new LineNumberReader(isr)) {&#010;+            String line;&#010;+            while ((line = reader.readLine()) != null) {&#010;+                builder.append(line);&#010;+                builder.append(""\n"");&#010;+            }&#010;+            return builder.toString();&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Matches the name with the pattern.&#010;+     *&#010;+     * @param name  the name&#010;+     * @param pattern the pattern&#010;+     * @return &lt;tt&gt;true&lt;/tt&gt; if matched, or &lt;tt&gt;false&lt;/tt&gt; if not&#010;+     */&#010;+    public static boolean matchWildcard(String name, String pattern) {&#010;+        // we have wildcard support in that hence you can match with: file* to match any file endpoints&#010;+        if (pattern.endsWith(""*"") &amp;&amp; name.startsWith(pattern.substring(0, pattern.length() - 1))) {&#010;+            return true;&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    /**&#010;+     * Returns the string after the given token&#010;+     *&#010;+     * @param text  the text&#010;+     * @param after the token&#010;+     * @return the text after the token, or &lt;tt&gt;null&lt;/tt&gt; if text does not contain the token&#010;+     */&#010;+    public static String after(String text, String after) {&#010;+        if (!text.contains(after)) {&#010;+            return null;&#010;+        }&#010;+        return text.substring(text.indexOf(after) + after.length());&#010;+    }&#010;+&#010;+    /**&#010;+     * Returns the string before the given token&#010;+     *&#010;+     * @param text  the text&#010;+     * @param before the token&#010;+     * @return the text before the token, or &lt;tt&gt;null&lt;/tt&gt; if text does not contain the token&#010;+     */&#010;+    public static String before(String text, String before) {&#010;+        if (!text.contains(before)) {&#010;+            return null;&#010;+        }&#010;+        return text.substring(0, text.indexOf(before));&#010;+    }&#010;+&#010;+    /**&#010;+     * Returns the string between the given tokens&#010;+     *&#010;+     * @param text  the text&#010;+     * @param after the before token&#010;+     * @param before the after token&#010;+     * @return the text between the tokens, or &lt;tt&gt;null&lt;/tt&gt; if text does not contain the tokens&#010;+     */&#010;+    public static String between(String text, String after, String before) {&#010;+        text = after(text, after);&#010;+        if (text == null) {&#010;+            return null;&#010;+        }&#010;+        return before(text, before);&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if empty&#010;+     */&#010;+    public static boolean isEmpty(Object value) {&#010;+        return !isNotEmpty(value);&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;b&gt;not&lt;/b&gt; &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if &lt;b&gt;not&lt;/b&gt; empty&#010;+     */&#010;+    public static boolean isNotEmpty(Object value) {&#010;+        if (value == null) {&#010;+            return false;&#010;+        } else if (value instanceof String) {&#010;+            String text = (String) value;&#010;+            return text.trim().length() &gt; 0;&#010;+        } else {&#010;+            return true;&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Removes all leading and ending quotes (single and double) from the string&#010;+     *&#010;+     * @param s  the string&#010;+     * @return the string without leading and ending quotes (single and double)&#010;+     */&#010;+    public static String removeLeadingAndEndingQuotes(String s) {&#010;+        if (isEmpty(s)) {&#010;+            return s;&#010;+        }&#010;+&#010;+        String copy = s.trim();&#010;+        if (copy.startsWith(""'"") &amp;&amp; copy.endsWith(""'"")) {&#010;+            return copy.substring(1, copy.length() - 1);&#010;+        }&#010;+        if (copy.startsWith(""\"""") &amp;&amp; copy.endsWith(""\"""")) {&#010;+            return copy.substring(1, copy.length() - 1);&#010;+        }&#010;+&#010;+        // no quotes, so return as-is&#010;+        return s;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java&#010;new file mode 100644&#010;index 0000000..f6484b8&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java&#010;@@ -0,0 +1,57 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+public class CollectionStringBuffer {&#010;+    private final StringBuilder buffer = new StringBuilder();&#010;+    private String separator;&#010;+    private boolean first = true;&#010;+&#010;+    public CollectionStringBuffer() {&#010;+        this("", "");&#010;+    }&#010;+&#010;+    public CollectionStringBuffer(String separator) {&#010;+        this.separator = separator;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String toString() {&#010;+        return buffer.toString();&#010;+    }&#010;+&#010;+    public void append(Object value) {&#010;+        if (first) {&#010;+            first = false;&#010;+        } else {&#010;+            buffer.append(separator);&#010;+        }&#010;+        buffer.append(value);&#010;+    }&#010;+&#010;+    public String getSeparator() {&#010;+        return separator;&#010;+    }&#010;+&#010;+    public void setSeparator(String separator) {&#010;+        this.separator = separator;&#010;+    }&#010;+&#010;+    public boolean isEmpty() {&#010;+        return first;&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java&#010;new file mode 100644&#010;index 0000000..7648e64&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java&#010;@@ -0,0 +1,136 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.HashMap;&#010;+import java.util.Map;&#010;+&#010;+import org.apache.camel.CamelContext;&#010;+&#010;+/**&#010;+ * Default {@link RuntimeCamelCatalog}.&#010;+ */&#010;+public class DefaultRuntimeCamelCatalog extends AbstractCamelCatalog implements RuntimeCamelCatalog {&#010;+&#010;+    // cache of operation -&gt; result&#010;+    private final Map&lt;String, Object&gt; cache = new HashMap&lt;String, Object&gt;();&#010;+    private boolean caching;&#010;+&#010;+    /**&#010;+     * Creates the {@link RuntimeCamelCatalog} without caching enabled.&#010;+     *&#010;+     * @param camelContext  the camel context&#010;+     */&#010;+    public DefaultRuntimeCamelCatalog(CamelContext camelContext) {&#010;+        this(camelContext, false);&#010;+    }&#010;+&#010;+    /**&#010;+     * Creates the {@link RuntimeCamelCatalog}&#010;+     *&#010;+     * @param camelContext  the camel context&#010;+     * @param caching  whether to use cache&#010;+     */&#010;+    public DefaultRuntimeCamelCatalog(CamelContext camelContext, boolean caching) {&#010;+        this.caching = caching;&#010;+        setJSonSchemaResolver(new CamelContextJSonSchemaResolver(camelContext));&#010;+    }&#010;+&#010;+    @Override&#010;+    public void start() throws Exception {&#010;+        // noop&#010;+    }&#010;+&#010;+    @Override&#010;+    public void stop() throws Exception {&#010;+        cache.clear();&#010;+    }&#010;+&#010;+    @Override&#010;+    public String modelJSonSchema(String name) {&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""model-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getModelJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""model-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String componentJSonSchema(String name) {&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""component-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getComponentJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""component-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String dataFormatJSonSchema(String name) {&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""dataformat-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getDataFormatJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""dataformat-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String languageJSonSchema(String name) {&#010;+        // if we try to look method then its in the bean.json file&#010;+        if (""method"".equals(name)) {&#010;+            name = ""bean"";&#010;+        }&#010;+&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""language-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getLanguageJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""language-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java&#010;new file mode 100644&#010;index 0000000..7d1c657&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java&#010;@@ -0,0 +1,451 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.Serializable;&#010;+import java.util.Arrays;&#010;+import java.util.Collections;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.LinkedHashSet;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+import java.util.Set;&#010;+&#010;+import static org.apache.camel.runtimecatalog.URISupport.isEmpty;&#010;+&#010;+/**&#010;+ * Details result of validating endpoint uri.&#010;+ */&#010;+public class EndpointValidationResult implements Serializable {&#010;+&#010;+    private final String uri;&#010;+    private int errors;&#010;+&#010;+    // general&#010;+    private String syntaxError;&#010;+    private String unknownComponent;&#010;+    private String incapable;&#010;+&#010;+    // options&#010;+    private Set&lt;String&gt; unknown;&#010;+    private Map&lt;String, String[]&gt; unknownSuggestions;&#010;+    private Set&lt;String&gt; lenient;&#010;+    private Set&lt;String&gt; notConsumerOnly;&#010;+    private Set&lt;String&gt; notProducerOnly;&#010;+    private Set&lt;String&gt; required;&#010;+    private Map&lt;String, String&gt; invalidEnum;&#010;+    private Map&lt;String, String[]&gt; invalidEnumChoices;&#010;+    private Map&lt;String, String[]&gt; invalidEnumSuggestions;&#010;+    private Map&lt;String, String&gt; invalidReference;&#010;+    private Map&lt;String, String&gt; invalidBoolean;&#010;+    private Map&lt;String, String&gt; invalidInteger;&#010;+    private Map&lt;String, String&gt; invalidNumber;&#010;+    private Map&lt;String, String&gt; defaultValues;&#010;+&#010;+    public EndpointValidationResult() {&#010;+        this(null);&#010;+    }&#010;+&#010;+    public EndpointValidationResult(String uri) {&#010;+        this.uri = uri;&#010;+    }&#010;+&#010;+    public String getUri() {&#010;+        return uri;&#010;+    }&#010;+&#010;+    public boolean hasErrors() {&#010;+        return errors &gt; 0;&#010;+    }&#010;+&#010;+    public int getNumberOfErrors() {&#010;+        return errors;&#010;+    }&#010;+&#010;+    public boolean isSuccess() {&#010;+        boolean ok = syntaxError == null &amp;&amp; unknownComponent == null &amp;&amp; incapable == null&#010;+                &amp;&amp; unknown == null &amp;&amp; required == null;&#010;+        if (ok) {&#010;+            ok = notConsumerOnly == null &amp;&amp; notProducerOnly == null;&#010;+        }&#010;+        if (ok) {&#010;+            ok = invalidEnum == null &amp;&amp; invalidEnumChoices == null &amp;&amp; invalidReference == null&#010;+                &amp;&amp; invalidBoolean == null &amp;&amp; invalidInteger == null &amp;&amp; invalidNumber == null;&#010;+        }&#010;+        return ok;&#010;+    }&#010;+&#010;+    public void addSyntaxError(String syntaxError) {&#010;+        this.syntaxError = syntaxError;&#010;+        errors++;&#010;+    }&#010;+&#010;+    public void addIncapable(String uri) {&#010;+        this.incapable = uri;&#010;+        errors++;&#010;+    }&#010;+&#010;+    public void addUnknownComponent(String name) {&#010;+        this.unknownComponent = name;&#010;+        errors++;&#010;+    }&#010;+&#010;+    public void addUnknown(String name) {&#010;+        if (unknown == null) {&#010;+            unknown = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!unknown.contains(name)) {&#010;+            unknown.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addUnknownSuggestions(String name, String[] suggestions) {&#010;+        if (unknownSuggestions == null) {&#010;+            unknownSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;+        }&#010;+        unknownSuggestions.put(name, suggestions);&#010;+    }&#010;+&#010;+    public void addLenient(String name) {&#010;+        if (lenient == null) {&#010;+            lenient = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!lenient.contains(name)) {&#010;+            lenient.add(name);&#010;+        }&#010;+    }&#010;+&#010;+    public void addRequired(String name) {&#010;+        if (required == null) {&#010;+            required = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!required.contains(name)) {&#010;+            required.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidEnum(String name, String value) {&#010;+        if (invalidEnum == null) {&#010;+            invalidEnum = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidEnum.containsKey(name)) {&#010;+            invalidEnum.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidEnumChoices(String name, String[] choices) {&#010;+        if (invalidEnumChoices == null) {&#010;+            invalidEnumChoices = new LinkedHashMap&lt;String, String[]&gt;();&#010;+        }&#010;+        invalidEnumChoices.put(name, choices);&#010;+    }&#010;+&#010;+    public void addInvalidEnumSuggestions(String name, String[] suggestions) {&#010;+        if (invalidEnumSuggestions == null) {&#010;+            invalidEnumSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;+        }&#010;+        invalidEnumSuggestions.put(name, suggestions);&#010;+    }&#010;+&#010;+    public void addInvalidReference(String name, String value) {&#010;+        if (invalidReference == null) {&#010;+            invalidReference = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidReference.containsKey(name)) {&#010;+            invalidReference.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidBoolean(String name, String value) {&#010;+        if (invalidBoolean == null) {&#010;+            invalidBoolean = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidBoolean.containsKey(name)) {&#010;+            invalidBoolean.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidInteger(String name, String value) {&#010;+        if (invalidInteger == null) {&#010;+            invalidInteger = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidInteger.containsKey(name)) {&#010;+            invalidInteger.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidNumber(String name, String value) {&#010;+        if (invalidNumber == null) {&#010;+            invalidNumber = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidNumber.containsKey(name)) {&#010;+            invalidNumber.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addDefaultValue(String name, String value)  {&#010;+        if (defaultValues == null) {&#010;+            defaultValues = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        defaultValues.put(name, value);&#010;+    }&#010;+&#010;+    public void addNotConsumerOnly(String name) {&#010;+        if (notConsumerOnly == null) {&#010;+            notConsumerOnly = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!notConsumerOnly.contains(name)) {&#010;+            notConsumerOnly.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addNotProducerOnly(String name) {&#010;+        if (notProducerOnly == null) {&#010;+            notProducerOnly = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!notProducerOnly.contains(name)) {&#010;+            notProducerOnly.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public String getSyntaxError() {&#010;+        return syntaxError;&#010;+    }&#010;+&#010;+    public String getIncapable() {&#010;+        return incapable;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getUnknown() {&#010;+        return unknown;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getLenient() {&#010;+        return lenient;&#010;+    }&#010;+&#010;+    public Map&lt;String, String[]&gt; getUnknownSuggestions() {&#010;+        return unknownSuggestions;&#010;+    }&#010;+&#010;+    public String getUnknownComponent() {&#010;+        return unknownComponent;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getRequired() {&#010;+        return required;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidEnum() {&#010;+        return invalidEnum;&#010;+    }&#010;+&#010;+    public Map&lt;String, String[]&gt; getInvalidEnumChoices() {&#010;+        return invalidEnumChoices;&#010;+    }&#010;+&#010;+    public List&lt;String&gt; getEnumChoices(String optionName) {&#010;+        if (invalidEnumChoices != null) {&#010;+            String[] enums = invalidEnumChoices.get(optionName);&#010;+            if (enums != null) {&#010;+                return Arrays.asList(enums);&#010;+            }&#010;+        }&#010;+&#010;+        return Collections.emptyList();&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidReference() {&#010;+        return invalidReference;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidBoolean() {&#010;+        return invalidBoolean;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidInteger() {&#010;+        return invalidInteger;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidNumber() {&#010;+        return invalidNumber;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getDefaultValues() {&#010;+        return defaultValues;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getNotConsumerOnly() {&#010;+        return notConsumerOnly;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getNotProducerOnly() {&#010;+        return notProducerOnly;&#010;+    }&#010;+&#010;+    /**&#010;+     * A human readable summary of the validation errors.&#010;+     *&#010;+     * @param includeHeader whether to include a header&#010;+     * @return the summary, or &lt;tt&gt;null&lt;/tt&gt; if no validation errors&#010;+     */&#010;+    public String summaryErrorMessage(boolean includeHeader) {&#010;+        if (isSuccess()) {&#010;+            return null;&#010;+        }&#010;+&#010;+        if (incapable != null) {&#010;+            return ""\tIncapable of parsing uri: "" + incapable;&#010;+        } else if (syntaxError != null) {&#010;+            return ""\tSyntax error: "" + syntaxError;&#010;+        } else if (unknownComponent != null) {&#010;+            return ""\tUnknown component: "" + unknownComponent;&#010;+        }&#010;+&#010;+        // for each invalid option build a reason message&#010;+        Map&lt;String, String&gt; options = new LinkedHashMap&lt;String, String&gt;();&#010;+        if (unknown != null) {&#010;+            for (String name : unknown) {&#010;+                if (unknownSuggestions != null &amp;&amp; unknownSuggestions.containsKey(name)) {&#010;+                    String[] suggestions = unknownSuggestions.get(name);&#010;+                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;+                        String str = Arrays.asList(suggestions).toString();&#010;+                        options.put(name, ""Unknown option. Did you mean: "" + str);&#010;+                    } else {&#010;+                        options.put(name, ""Unknown option"");&#010;+                    }&#010;+                } else {&#010;+                    options.put(name, ""Unknown option"");&#010;+                }&#010;+            }&#010;+        }&#010;+        if (notConsumerOnly != null) {&#010;+            for (String name : notConsumerOnly) {&#010;+                options.put(name, ""Option not applicable in consumer only mode"");&#010;+            }&#010;+        }&#010;+        if (notProducerOnly != null) {&#010;+            for (String name : notProducerOnly) {&#010;+                options.put(name, ""Option not applicable in producer only mode"");&#010;+            }&#010;+        }&#010;+        if (required != null) {&#010;+            for (String name : required) {&#010;+                options.put(name, ""Missing required option"");&#010;+            }&#010;+        }&#010;+        if (invalidEnum != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidEnum.entrySet()) {&#010;+                String name = entry.getKey();&#010;+                String[] choices = invalidEnumChoices.get(name);&#010;+                String defaultValue = defaultValues != null ? defaultValues.get(entry.getKey()) : null;&#010;+                String str = Arrays.asList(choices).toString();&#010;+                String msg = ""Invalid enum value: "" + entry.getValue() + "". Possible values: "" + str;&#010;+                if (invalidEnumSuggestions != null) {&#010;+                    String[] suggestions = invalidEnumSuggestions.get(name);&#010;+                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;+                        str = Arrays.asList(suggestions).toString();&#010;+                        msg += "". Did you mean: "" + str;&#010;+                    }&#010;+                }&#010;+                if (defaultValue != null) {&#010;+                    msg += "". Default value: "" + defaultValue;&#010;+                }&#010;+&#010;+                options.put(entry.getKey(), msg);&#010;+            }&#010;+        }&#010;+        if (invalidReference != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidReference.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty reference value"");&#010;+                } else if (!entry.getValue().startsWith(""#"")) {&#010;+                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue() + "" must start with #"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+        if (invalidBoolean != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidBoolean.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty boolean value"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid boolean value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+        if (invalidInteger != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidInteger.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty integer value"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid integer value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+        if (invalidNumber != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidNumber.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty number value"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid number value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // build a table with the error summary nicely formatted&#010;+        // lets use 24 as min length&#010;+        int maxLen = 24;&#010;+        for (String key : options.keySet()) {&#010;+            maxLen = Math.max(maxLen, key.length());&#010;+        }&#010;+        String format = ""%"" + maxLen + ""s    %s"";&#010;+&#010;+        // build the human error summary&#010;+        StringBuilder sb = new StringBuilder();&#010;+        if (includeHeader) {&#010;+            sb.append(""Endpoint validator error\n"");&#010;+            sb.append(""---------------------------------------------------------------------------------------------------------------------------------------\n"");&#010;+            sb.append(""\n"");&#010;+        }&#010;+        if (uri != null) {&#010;+            sb.append(""\t"").append(uri).append(""\n"");&#010;+        } else {&#010;+            sb.append(""\n"");&#010;+        }&#010;+        for (Map.Entry&lt;String, String&gt; option : options.entrySet()) {&#010;+            String out = String.format(format, option.getKey(), option.getValue());&#010;+            sb.append(""\n\t"").append(out);&#010;+        }&#010;+&#010;+        return sb.toString();&#010;+    }&#010;+}&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C0ffd278dae9f48d5849d5bd0dc60655f%40git.apache.org%3E,2017-04-14 10:52,commits,5.0,325.0,  [4/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
20,326.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java b/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&#010;deleted file mode 100644&#010;index 9bb98f0..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&#010;+++ /dev/null&#010;@@ -1,451 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.io.Serializable;&#010;-import java.util.Arrays;&#010;-import java.util.Collections;&#010;-import java.util.LinkedHashMap;&#010;-import java.util.LinkedHashSet;&#010;-import java.util.List;&#010;-import java.util.Map;&#010;-import java.util.Set;&#010;-&#010;-import static org.apache.camel.catalog.URISupport.isEmpty;&#010;-&#010;-/**&#010;- * Details result of validating endpoint uri.&#010;- */&#010;-public class EndpointValidationResult implements Serializable {&#010;-&#010;-    private final String uri;&#010;-    private int errors;&#010;-&#010;-    // general&#010;-    private String syntaxError;&#010;-    private String unknownComponent;&#010;-    private String incapable;&#010;-&#010;-    // options&#010;-    private Set&lt;String&gt; unknown;&#010;-    private Map&lt;String, String[]&gt; unknownSuggestions;&#010;-    private Set&lt;String&gt; lenient;&#010;-    private Set&lt;String&gt; notConsumerOnly;&#010;-    private Set&lt;String&gt; notProducerOnly;&#010;-    private Set&lt;String&gt; required;&#010;-    private Map&lt;String, String&gt; invalidEnum;&#010;-    private Map&lt;String, String[]&gt; invalidEnumChoices;&#010;-    private Map&lt;String, String[]&gt; invalidEnumSuggestions;&#010;-    private Map&lt;String, String&gt; invalidReference;&#010;-    private Map&lt;String, String&gt; invalidBoolean;&#010;-    private Map&lt;String, String&gt; invalidInteger;&#010;-    private Map&lt;String, String&gt; invalidNumber;&#010;-    private Map&lt;String, String&gt; defaultValues;&#010;-&#010;-    public EndpointValidationResult() {&#010;-        this(null);&#010;-    }&#010;-&#010;-    public EndpointValidationResult(String uri) {&#010;-        this.uri = uri;&#010;-    }&#010;-&#010;-    public String getUri() {&#010;-        return uri;&#010;-    }&#010;-&#010;-    public boolean hasErrors() {&#010;-        return errors &gt; 0;&#010;-    }&#010;-&#010;-    public int getNumberOfErrors() {&#010;-        return errors;&#010;-    }&#010;-&#010;-    public boolean isSuccess() {&#010;-        boolean ok = syntaxError == null &amp;&amp; unknownComponent == null &amp;&amp; incapable == null&#010;-                &amp;&amp; unknown == null &amp;&amp; required == null;&#010;-        if (ok) {&#010;-            ok = notConsumerOnly == null &amp;&amp; notProducerOnly == null;&#010;-        }&#010;-        if (ok) {&#010;-            ok = invalidEnum == null &amp;&amp; invalidEnumChoices == null &amp;&amp; invalidReference == null&#010;-                &amp;&amp; invalidBoolean == null &amp;&amp; invalidInteger == null &amp;&amp; invalidNumber == null;&#010;-        }&#010;-        return ok;&#010;-    }&#010;-&#010;-    public void addSyntaxError(String syntaxError) {&#010;-        this.syntaxError = syntaxError;&#010;-        errors++;&#010;-    }&#010;-&#010;-    public void addIncapable(String uri) {&#010;-        this.incapable = uri;&#010;-        errors++;&#010;-    }&#010;-&#010;-    public void addUnknownComponent(String name) {&#010;-        this.unknownComponent = name;&#010;-        errors++;&#010;-    }&#010;-&#010;-    public void addUnknown(String name) {&#010;-        if (unknown == null) {&#010;-            unknown = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!unknown.contains(name)) {&#010;-            unknown.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addUnknownSuggestions(String name, String[] suggestions) {&#010;-        if (unknownSuggestions == null) {&#010;-            unknownSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;-        }&#010;-        unknownSuggestions.put(name, suggestions);&#010;-    }&#010;-&#010;-    public void addLenient(String name) {&#010;-        if (lenient == null) {&#010;-            lenient = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!lenient.contains(name)) {&#010;-            lenient.add(name);&#010;-        }&#010;-    }&#010;-&#010;-    public void addRequired(String name) {&#010;-        if (required == null) {&#010;-            required = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!required.contains(name)) {&#010;-            required.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidEnum(String name, String value) {&#010;-        if (invalidEnum == null) {&#010;-            invalidEnum = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidEnum.containsKey(name)) {&#010;-            invalidEnum.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidEnumChoices(String name, String[] choices) {&#010;-        if (invalidEnumChoices == null) {&#010;-            invalidEnumChoices = new LinkedHashMap&lt;String, String[]&gt;();&#010;-        }&#010;-        invalidEnumChoices.put(name, choices);&#010;-    }&#010;-&#010;-    public void addInvalidEnumSuggestions(String name, String[] suggestions) {&#010;-        if (invalidEnumSuggestions == null) {&#010;-            invalidEnumSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;-        }&#010;-        invalidEnumSuggestions.put(name, suggestions);&#010;-    }&#010;-&#010;-    public void addInvalidReference(String name, String value) {&#010;-        if (invalidReference == null) {&#010;-            invalidReference = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidReference.containsKey(name)) {&#010;-            invalidReference.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidBoolean(String name, String value) {&#010;-        if (invalidBoolean == null) {&#010;-            invalidBoolean = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidBoolean.containsKey(name)) {&#010;-            invalidBoolean.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidInteger(String name, String value) {&#010;-        if (invalidInteger == null) {&#010;-            invalidInteger = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidInteger.containsKey(name)) {&#010;-            invalidInteger.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidNumber(String name, String value) {&#010;-        if (invalidNumber == null) {&#010;-            invalidNumber = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidNumber.containsKey(name)) {&#010;-            invalidNumber.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addDefaultValue(String name, String value)  {&#010;-        if (defaultValues == null) {&#010;-            defaultValues = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        defaultValues.put(name, value);&#010;-    }&#010;-&#010;-    public void addNotConsumerOnly(String name) {&#010;-        if (notConsumerOnly == null) {&#010;-            notConsumerOnly = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!notConsumerOnly.contains(name)) {&#010;-            notConsumerOnly.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addNotProducerOnly(String name) {&#010;-        if (notProducerOnly == null) {&#010;-            notProducerOnly = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!notProducerOnly.contains(name)) {&#010;-            notProducerOnly.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public String getSyntaxError() {&#010;-        return syntaxError;&#010;-    }&#010;-&#010;-    public String getIncapable() {&#010;-        return incapable;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getUnknown() {&#010;-        return unknown;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getLenient() {&#010;-        return lenient;&#010;-    }&#010;-&#010;-    public Map&lt;String, String[]&gt; getUnknownSuggestions() {&#010;-        return unknownSuggestions;&#010;-    }&#010;-&#010;-    public String getUnknownComponent() {&#010;-        return unknownComponent;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getRequired() {&#010;-        return required;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidEnum() {&#010;-        return invalidEnum;&#010;-    }&#010;-&#010;-    public Map&lt;String, String[]&gt; getInvalidEnumChoices() {&#010;-        return invalidEnumChoices;&#010;-    }&#010;-&#010;-    public List&lt;String&gt; getEnumChoices(String optionName) {&#010;-        if (invalidEnumChoices != null) {&#010;-            String[] enums = invalidEnumChoices.get(optionName);&#010;-            if (enums != null) {&#010;-                return Arrays.asList(enums);&#010;-            }&#010;-        }&#010;-&#010;-        return Collections.emptyList();&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidReference() {&#010;-        return invalidReference;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidBoolean() {&#010;-        return invalidBoolean;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidInteger() {&#010;-        return invalidInteger;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidNumber() {&#010;-        return invalidNumber;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getDefaultValues() {&#010;-        return defaultValues;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getNotConsumerOnly() {&#010;-        return notConsumerOnly;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getNotProducerOnly() {&#010;-        return notProducerOnly;&#010;-    }&#010;-&#010;-    /**&#010;-     * A human readable summary of the validation errors.&#010;-     *&#010;-     * @param includeHeader whether to include a header&#010;-     * @return the summary, or &lt;tt&gt;null&lt;/tt&gt; if no validation errors&#010;-     */&#010;-    public String summaryErrorMessage(boolean includeHeader) {&#010;-        if (isSuccess()) {&#010;-            return null;&#010;-        }&#010;-&#010;-        if (incapable != null) {&#010;-            return ""\tIncapable of parsing uri: "" + incapable;&#010;-        } else if (syntaxError != null) {&#010;-            return ""\tSyntax error: "" + syntaxError;&#010;-        } else if (unknownComponent != null) {&#010;-            return ""\tUnknown component: "" + unknownComponent;&#010;-        }&#010;-&#010;-        // for each invalid option build a reason message&#010;-        Map&lt;String, String&gt; options = new LinkedHashMap&lt;String, String&gt;();&#010;-        if (unknown != null) {&#010;-            for (String name : unknown) {&#010;-                if (unknownSuggestions != null &amp;&amp; unknownSuggestions.containsKey(name)) {&#010;-                    String[] suggestions = unknownSuggestions.get(name);&#010;-                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;-                        String str = Arrays.asList(suggestions).toString();&#010;-                        options.put(name, ""Unknown option. Did you mean: "" + str);&#010;-                    } else {&#010;-                        options.put(name, ""Unknown option"");&#010;-                    }&#010;-                } else {&#010;-                    options.put(name, ""Unknown option"");&#010;-                }&#010;-            }&#010;-        }&#010;-        if (notConsumerOnly != null) {&#010;-            for (String name : notConsumerOnly) {&#010;-                options.put(name, ""Option not applicable in consumer only mode"");&#010;-            }&#010;-        }&#010;-        if (notProducerOnly != null) {&#010;-            for (String name : notProducerOnly) {&#010;-                options.put(name, ""Option not applicable in producer only mode"");&#010;-            }&#010;-        }&#010;-        if (required != null) {&#010;-            for (String name : required) {&#010;-                options.put(name, ""Missing required option"");&#010;-            }&#010;-        }&#010;-        if (invalidEnum != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidEnum.entrySet()) {&#010;-                String name = entry.getKey();&#010;-                String[] choices = invalidEnumChoices.get(name);&#010;-                String defaultValue = defaultValues != null ? defaultValues.get(entry.getKey()) : null;&#010;-                String str = Arrays.asList(choices).toString();&#010;-                String msg = ""Invalid enum value: "" + entry.getValue() + "". Possible values: "" + str;&#010;-                if (invalidEnumSuggestions != null) {&#010;-                    String[] suggestions = invalidEnumSuggestions.get(name);&#010;-                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;-                        str = Arrays.asList(suggestions).toString();&#010;-                        msg += "". Did you mean: "" + str;&#010;-                    }&#010;-                }&#010;-                if (defaultValue != null) {&#010;-                    msg += "". Default value: "" + defaultValue;&#010;-                }&#010;-&#010;-                options.put(entry.getKey(), msg);&#010;-            }&#010;-        }&#010;-        if (invalidReference != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidReference.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty reference value"");&#010;-                } else if (!entry.getValue().startsWith(""#"")) {&#010;-                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue() + "" must start with #"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-        if (invalidBoolean != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidBoolean.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty boolean value"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid boolean value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-        if (invalidInteger != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidInteger.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty integer value"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid integer value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-        if (invalidNumber != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidNumber.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty number value"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid number value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-&#010;-        // build a table with the error summary nicely formatted&#010;-        // lets use 24 as min length&#010;-        int maxLen = 24;&#010;-        for (String key : options.keySet()) {&#010;-            maxLen = Math.max(maxLen, key.length());&#010;-        }&#010;-        String format = ""%"" + maxLen + ""s    %s"";&#010;-&#010;-        // build the human error summary&#010;-        StringBuilder sb = new StringBuilder();&#010;-        if (includeHeader) {&#010;-            sb.append(""Endpoint validator error\n"");&#010;-            sb.append(""---------------------------------------------------------------------------------------------------------------------------------------\n"");&#010;-            sb.append(""\n"");&#010;-        }&#010;-        if (uri != null) {&#010;-            sb.append(""\t"").append(uri).append(""\n"");&#010;-        } else {&#010;-            sb.append(""\n"");&#010;-        }&#010;-        for (Map.Entry&lt;String, String&gt; option : options.entrySet()) {&#010;-            String out = String.format(format, option.getKey(), option.getValue());&#010;-            sb.append(""\n\t"").append(out);&#010;-        }&#010;-&#010;-        return sb.toString();&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java b/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&#010;deleted file mode 100644&#010;index 774facd..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&#010;+++ /dev/null&#010;@@ -1,424 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.ArrayList;&#010;-import java.util.LinkedHashMap;&#010;-import java.util.LinkedHashSet;&#010;-import java.util.List;&#010;-import java.util.Map;&#010;-import java.util.Set;&#010;-import java.util.regex.Matcher;&#010;-import java.util.regex.Pattern;&#010;-&#010;-public final class JSonSchemaHelper {&#010;-&#010;-    // 0 = text, 1 = enum, 2 = boolean, 3 = integer or number&#010;-    private static final Pattern PATTERN = Pattern.compile(""\""(.+?)\""|\\[(.+)\\]|(true|false)|(-?\\d+\\.?\\d*)"");&#010;-    private static final String QUOT = ""&amp;quot;"";&#010;-&#010;-    private JSonSchemaHelper() {&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the json schema to split it into a list or rows, where each row contains key value pairs with the metadata&#010;-     *&#010;-     * @param group the group to parse from such as &lt;tt&gt;component&lt;/tt&gt;, &lt;tt&gt;componentProperties&lt;/tt&gt;, or &lt;tt&gt;properties&lt;/tt&gt;.&#010;-     * @param json the json&#010;-     * @return a list of all the rows, where each row is a set of key value pairs with metadata&#010;-     */&#010;-    public static List&lt;Map&lt;String, String&gt;&gt; parseJsonSchema(String group, String json, boolean parseProperties) {&#010;-        List&lt;Map&lt;String, String&gt;&gt; answer = new ArrayList&lt;Map&lt;String, String&gt;&gt;();&#010;-        if (json == null) {&#010;-            return answer;&#010;-        }&#010;-&#010;-        boolean found = false;&#010;-&#010;-        // parse line by line&#010;-        String[] lines = json.split(""\n"");&#010;-        for (String line : lines) {&#010;-            // we need to find the group first&#010;-            if (!found) {&#010;-                String s = line.trim();&#010;-                found = s.startsWith(""\"""" + group + ""\"":"") &amp;&amp; s.endsWith(""{"");&#010;-                continue;&#010;-            }&#010;-&#010;-            // we should stop when we end the group&#010;-            if (line.equals(""  },"") || line.equals(""  }"")) {&#010;-                break;&#010;-            }&#010;-&#010;-            // need to safe encode \"" so we can parse the line&#010;-            line = line.replaceAll(""\""\\\\\""\"""", '""' + QUOT + '""');&#010;-&#010;-            Map&lt;String, String&gt; row = new LinkedHashMap&lt;String, String&gt;();&#010;-            Matcher matcher = PATTERN.matcher(line);&#010;-&#010;-            String key;&#010;-            if (parseProperties) {&#010;-                // when parsing properties the first key is given as name, so the first parsed token is the value of the name&#010;-                key = ""name"";&#010;-            } else {&#010;-                key = null;&#010;-            }&#010;-            while (matcher.find()) {&#010;-                if (key == null) {&#010;-                    key = matcher.group(1);&#010;-                } else {&#010;-                    String value = matcher.group(1);&#010;-                    if (value != null) {&#010;-                        // its text based&#010;-                        value = value.trim();&#010;-                        // decode&#010;-                        value = value.replaceAll(QUOT, ""\"""");&#010;-                        value = decodeJson(value);&#010;-                    }&#010;-                    if (value == null) {&#010;-                        // not text then its maybe an enum?&#010;-                        value = matcher.group(2);&#010;-                        if (value != null) {&#010;-                            // its an enum so strip out "" and trim spaces after comma&#010;-                            value = value.replaceAll(""\"""", """");&#010;-                            value = value.replaceAll("", "", "","");&#010;-                            value = value.trim();&#010;-                        }&#010;-                    }&#010;-                    if (value == null) {&#010;-                        // not text then its maybe a boolean?&#010;-                        value = matcher.group(3);&#010;-                    }&#010;-                    if (value == null) {&#010;-                        // not text then its maybe a integer?&#010;-                        value = matcher.group(4);&#010;-                    }&#010;-                    if (value != null) {&#010;-                        row.put(key, value);&#010;-                    }&#010;-                    // reset&#010;-                    key = null;&#010;-                }&#010;-            }&#010;-            if (!row.isEmpty()) {&#010;-                answer.add(row);&#010;-            }&#010;-        }&#010;-&#010;-        return answer;&#010;-    }&#010;-&#010;-    private static String decodeJson(String value) {&#010;-        // json encodes a \ as \\ so we need to decode from \\ back to \&#010;-        if (""\\\\"".equals(value)) {&#010;-            value = ""\\"";&#010;-        }&#010;-        return value;&#010;-    }&#010;-&#010;-    public static boolean isComponentLenientProperties(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""lenientProperties"")) {&#010;-                return ""true"".equals(row.get(""lenientProperties""));&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isComponentConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""consumerOnly"")) {&#010;-                return ""true"".equals(row.get(""consumerOnly""));&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isComponentProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""producerOnly"")) {&#010;-                return ""true"".equals(row.get(""producerOnly""));&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String labels = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""label"")) {&#010;-                labels = row.get(""label"");&#010;-            }&#010;-            if (found) {&#010;-                return labels != null &amp;&amp; labels.contains(""consumer"");&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String labels = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""label"")) {&#010;-                labels = row.get(""label"");&#010;-            }&#010;-            if (found) {&#010;-                return labels != null &amp;&amp; labels.contains(""producer"");&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyRequired(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            boolean required = false;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""required"")) {&#010;-                required = ""true"".equals(row.get(""required""));&#010;-            }&#010;-            if (found) {&#010;-                return required;&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static String getPropertyKind(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String kind = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""kind"")) {&#010;-                kind = row.get(""kind"");&#010;-            }&#010;-            if (found) {&#010;-                return kind;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static boolean isPropertyBoolean(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""boolean"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyInteger(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""integer"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyNumber(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""number"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyObject(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""object"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static String getPropertyDefaultValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String defaultValue = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""defaultValue"")) {&#010;-                defaultValue = row.get(""defaultValue"");&#010;-            }&#010;-            if (found) {&#010;-                return defaultValue;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static String stripOptionalPrefixFromName(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String optionalPrefix = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""optionalPrefix"")) {&#010;-                optionalPrefix = row.get(""optionalPrefix"");&#010;-            }&#010;-            if (row.containsKey(""name"")) {&#010;-                if (optionalPrefix != null &amp;&amp; name.startsWith(optionalPrefix)) {&#010;-                    name = name.substring(optionalPrefix.length());&#010;-                    // try again&#010;-                    return stripOptionalPrefixFromName(rows, name);&#010;-                } else {&#010;-                    found = name.equals(row.get(""name""));&#010;-                }&#010;-            }&#010;-            if (found) {&#010;-                return name;&#010;-            }&#010;-        }&#010;-        return name;&#010;-    }&#010;-&#010;-    public static String getPropertyEnum(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String enums = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""enum"")) {&#010;-                enums = row.get(""enum"");&#010;-            }&#010;-            if (found) {&#010;-                return enums;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static String getPropertyPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String prefix = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""prefix"")) {&#010;-                prefix = row.get(""prefix"");&#010;-            }&#010;-            if (found) {&#010;-                return prefix;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static boolean isPropertyMultiValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            boolean multiValue = false;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""multiValue"")) {&#010;-                multiValue = ""true"".equals(row.get(""multiValue""));&#010;-            }&#010;-            if (found) {&#010;-                return multiValue;&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static String getPropertyNameFromNameWithPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String propertyName = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                propertyName = row.get(""name"");&#010;-            }&#010;-            if (row.containsKey(""prefix"")) {&#010;-                String preifx = row.get(""prefix"");&#010;-                found = name.startsWith(preifx);&#010;-            }&#010;-            if (found) {&#010;-                return propertyName;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static Map&lt;String, String&gt; getRow(List&lt;Map&lt;String, String&gt;&gt; rows, String key) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (key.equals(row.get(""name""))) {&#010;-                return row;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static Set&lt;String&gt; getNames(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        Set&lt;String&gt; answer = new LinkedHashSet&lt;String&gt;();&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""name"")) {&#010;-                answer.add(row.get(""name""));&#010;-            }&#010;-        }&#010;-        return answer;&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java b/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&#010;deleted file mode 100644&#010;index 9bf09cc..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&#010;+++ /dev/null&#010;@@ -1,64 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-/**&#010;- * Pluggable resolver to load JSon schema files for components, data formats, languages etc.&#010;- */&#010;-public interface JSonSchemaResolver {&#010;-&#010;-    /**&#010;-     * Returns the component information as JSon format.&#010;-     *&#010;-     * @param name the component name&#010;-     * @return component details in JSon&#010;-     */&#010;-    String getComponentJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the data format information as JSon format.&#010;-     *&#010;-     * @param name the data format name&#010;-     * @return data format details in JSon&#010;-     */&#010;-    String getDataFormatJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the language information as JSon format.&#010;-     *&#010;-     * @param name the language name&#010;-     * @return language details in JSon&#010;-     */&#010;-    String getLanguageJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the other (miscellaneous) information as JSon format.&#010;-     *&#010;-     * @param name the other (miscellaneous) name&#010;-     * @return other (miscellaneous) details in JSon&#010;-     */&#010;-    String getOtherJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the model information as JSon format.&#010;-     *&#010;-     * @param name the model name&#010;-     * @return model details in JSon&#010;-     */&#010;-    String getModelJSonSchema(String name);&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java b/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&#010;deleted file mode 100644&#010;index 4a977eb..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&#010;+++ /dev/null&#010;@@ -1,65 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.io.Serializable;&#010;-&#010;-/**&#010;- * Validation result of parsing a language expression or predicate&#010;- */&#010;-public class LanguageValidationResult implements Serializable {&#010;-    private final String text;&#010;-    private String error;&#010;-    private String shortError;&#010;-    private int index;&#010;-&#010;-    public LanguageValidationResult(String text) {&#010;-        this.text = text;&#010;-    }&#010;-&#010;-    public String getText() {&#010;-        return text;&#010;-    }&#010;-&#010;-    public boolean isSuccess() {&#010;-        return error == null;&#010;-    }&#010;-&#010;-    public void setError(String error) {&#010;-        this.error = error;&#010;-    }&#010;-&#010;-    public String getError() {&#010;-        return error;&#010;-    }&#010;-&#010;-    public String getShortError() {&#010;-        return shortError;&#010;-    }&#010;-&#010;-    public void setShortError(String shortError) {&#010;-        this.shortError = shortError;&#010;-    }&#010;-&#010;-    public int getIndex() {&#010;-        return index;&#010;-    }&#010;-&#010;-    public void setIndex(int index) {&#010;-        this.index = index;&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java&#010;deleted file mode 100644&#010;index b46edab..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java&#010;+++ /dev/null&#010;@@ -1,234 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.net.URISyntaxException;&#010;-import java.util.Map;&#010;-&#010;-import org.apache.camel.StaticService;&#010;-&#010;-/**&#010;- * Runtime based CamelCatalog which are included in camel-core that can provided limit CamelCatalog capabilities&#010;- */&#010;-public interface RuntimeCamelCatalog extends StaticService {&#010;-&#010;-    /**&#010;-     * Returns the component information as JSon format.&#010;-     *&#010;-     * @param name the component name&#010;-     * @return component details in JSon&#010;-     */&#010;-    String componentJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the data format information as JSon format.&#010;-     *&#010;-     * @param name the data format name&#010;-     * @return data format details in JSon&#010;-     */&#010;-    String dataFormatJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the language information as JSon format.&#010;-     *&#010;-     * @param name the language name&#010;-     * @return language details in JSon&#010;-     */&#010;-    String languageJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the model information as JSon format.&#010;-     *&#010;-     * @param name the model name&#010;-     * @return model details in JSon&#010;-     */&#010;-    String modelJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Parses the endpoint uri and constructs a key/value properties of each option&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return properties as key value pairs of each endpoint option&#010;-     */&#010;-    Map&lt;String, String&gt; endpointProperties(String uri) throws URISyntaxException;&#010;-&#010;-    /**&#010;-     * Parses the endpoint uri and constructs a key/value properties of only the lenient properties (eg custom options)&#010;-     * &lt;p/&gt;&#010;-     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return properties as key value pairs of each lenient properties&#010;-     */&#010;-    Map&lt;String, String&gt; endpointLenientProperties(String uri) throws URISyntaxException;&#010;-&#010;-    /**&#010;-     * Validates the pattern whether its a valid time pattern.&#010;-     *&#010;-     * @param pattern  the pattern such as 5000, 5s, 5sec, 4min, 4m30s, 1h, etc.&#010;-     * @return &lt;tt&gt;true&lt;/tt&gt; if valid, &lt;tt&gt;false&lt;/tt&gt; if invalid&#010;-     */&#010;-    boolean validateTimePattern(String pattern);&#010;-&#010;-    /**&#010;-     * Validates the properties for the given scheme against component and endpoint&#010;-     *&#010;-     * @param scheme  the endpoint scheme&#010;-     * @param properties  the endpoint properties&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateProperties(String scheme, Map&lt;String, String&gt; properties);&#010;-&#010;-    /**&#010;-     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateEndpointProperties(String uri);&#010;-&#010;-    /**&#010;-     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;-     * &lt;p/&gt;&#010;-     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;-     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;-     * but in the uri because of using lenient properties.&#010;-     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties);&#010;-&#010;-    /**&#010;-     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;-     * &lt;p/&gt;&#010;-     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;-     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;-     * but in the uri because of using lenient properties.&#010;-     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;-     * @param consumerOnly whether the endpoint is only used as a consumer&#010;-     * @param producerOnly whether the endpoint is only used as a producer&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties, boolean consumerOnly, boolean producerOnly);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple expression.&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param simple  the simple expression&#010;-     * @return validation result&#010;-     * @deprecated use {@link #validateSimpleExpression(ClassLoader, String)}&#010;-     */&#010;-    @Deprecated&#010;-    SimpleValidationResult validateSimpleExpression(String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple expression.&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param simple  the simple expression&#010;-     * @return validation result&#010;-     */&#010;-    SimpleValidationResult validateSimpleExpression(ClassLoader classLoader, String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple predicate&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param simple  the simple predicate&#010;-     * @return validation result&#010;-     * @deprecated use {@link #validateSimplePredicate(ClassLoader, String)}&#010;-     */&#010;-    @Deprecated&#010;-    SimpleValidationResult validateSimplePredicate(String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple predicate&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param simple  the simple predicate&#010;-     * @return validation result&#010;-     */&#010;-    SimpleValidationResult validateSimplePredicate(ClassLoader classLoader, String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the language as a predicate&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param language the name of the language&#010;-     * @param text  the predicate text&#010;-     * @return validation result&#010;-     */&#010;-    LanguageValidationResult validateLanguagePredicate(ClassLoader classLoader, String language, String text);&#010;-&#010;-    /**&#010;-     * Parses and validates the language as an expression&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param language the name of the language&#010;-     * @param text  the expression text&#010;-     * @return validation result&#010;-     */&#010;-    LanguageValidationResult validateLanguageExpression(ClassLoader classLoader, String language, String text);&#010;-&#010;-    /**&#010;-     * Returns the component name from the given endpoint uri&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return the component name (aka scheme), or &lt;tt&gt;null&lt;/tt&gt; if not possible to determine&#010;-     */&#010;-    String endpointComponentName(String uri);&#010;-&#010;-    /**&#010;-     * Creates an endpoint uri in Java style from the information from the properties&#010;-     *&#010;-     * @param scheme the endpoint schema&#010;-     * @param properties the properties as key value pairs&#010;-     * @param encode whether to URL encode the returned uri or not&#010;-     * @return the constructed endpoint uri&#010;-     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;-     */&#010;-    String asEndpointUri(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;-&#010;-    /**&#010;-     * Creates an endpoint uri in XML style (eg escape &amp; as &amp;ampl;) from the information from the properties&#010;-     *&#010;-     * @param scheme the endpoint schema&#010;-     * @param properties the properties as key value pairs&#010;-     * @param encode whether to URL encode the returned uri or not&#010;-     * @return the constructed endpoint uri&#010;-     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;-     */&#010;-    String asEndpointUriXml(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java b/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&#010;deleted file mode 100644&#010;index 5c86f23..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&#010;+++ /dev/null&#010;@@ -1,32 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-/**&#010;- * To be backwards compatible, but favor using {@link LanguageValidationResult} instead.&#010;- */&#010;-public class SimpleValidationResult extends LanguageValidationResult {&#010;-&#010;-    public SimpleValidationResult(String text) {&#010;-        super(text);&#010;-    }&#010;-&#010;-    public String getSimple() {&#010;-        return getText();&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java b/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&#010;deleted file mode 100644&#010;index 057d372..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&#010;+++ /dev/null&#010;@@ -1,34 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.Set;&#010;-&#010;-/**&#010;- * Strategy to provide suggestions for unknown endpoint options&#010;- */&#010;-public interface SuggestionStrategy {&#010;-&#010;-    /**&#010;-     * Provides a list of valid option names for a did you mean function.&#010;-     *&#010;-     * @param names         valid names&#010;-     * @param unknownOption unknown option name&#010;-     * @return a list of suggested names (did you mean)&#010;-     */&#010;-    String[] suggestEndpointOptions(Set&lt;String&gt; names, String unknownOption);&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java b/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&#010;deleted file mode 100644&#010;index 4ed843a..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&#010;+++ /dev/null&#010;@@ -1,120 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.regex.Matcher;&#010;-import java.util.regex.Pattern;&#010;-&#010;-/**&#010;- * This class is a copy from camel-core so we can use it independent to validate uris with time patterns&#010;- */&#010;-public final class TimePatternConverter {&#010;-    private static final Pattern NUMBERS_ONLY_STRING_PATTERN = Pattern.compile(""^[-]?(\\d)+$"", Pattern.CASE_INSENSITIVE);&#010;-    private static final Pattern HOUR_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))h(our(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;-    private static final Pattern MINUTES_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))m(in(ute(s)?)?)?"", Pattern.CASE_INSENSITIVE);&#010;-    private static final Pattern SECONDS_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))s(ec(ond)?(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;-&#010;-    /**&#010;-     * Utility classes should not have a public constructor.&#010;-     */&#010;-    private TimePatternConverter() {&#010;-    }&#010;-&#010;-    public static long toMilliSeconds(String source) throws IllegalArgumentException {&#010;-        long milliseconds = 0;&#010;-        boolean foundFlag = false;&#010;-&#010;-        checkCorrectnessOfPattern(source);&#010;-        Matcher matcher;&#010;-&#010;-        matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;-        if (matcher.find()) {&#010;-            // Note: This will also be used for regular numeric strings.&#010;-            //       This String -&gt; long converter will be used for all strings.&#010;-            milliseconds = Long.valueOf(source);&#010;-        } else {&#010;-            matcher = createMatcher(HOUR_REGEX_PATTERN, source);&#010;-            if (matcher.find()) {&#010;-                milliseconds = milliseconds + (3600000 * Long.valueOf(matcher.group(1)));&#010;-                foundFlag = true;&#010;-            }&#010;-&#010;-            matcher = createMatcher(MINUTES_REGEX_PATTERN, source);&#010;-            if (matcher.find()) {&#010;-                long minutes = Long.valueOf(matcher.group(1));&#010;-                if ((minutes &gt; 59) &amp;&amp; foundFlag) {&#010;-                    throw new IllegalArgumentException(""Minutes should contain a valid value between 0 and 59: "" + source);&#010;-                }&#010;-                foundFlag = true;&#010;-                milliseconds = milliseconds + (60000 * minutes);&#010;-            }&#010;-&#010;-            matcher = createMatcher(SECONDS_REGEX_PATTERN, source);&#010;-            if (matcher.find()) {&#010;-                long seconds = Long.valueOf(matcher.group(1));&#010;-                if ((seconds &gt; 59) &amp;&amp; foundFlag) {&#010;-                    throw new IllegalArgumentException(""Seconds should contain a valid value between 0 and 59: "" + source);&#010;-                }&#010;-                foundFlag = true;&#010;-                milliseconds = milliseconds + (1000 * seconds);&#010;-            }&#010;-&#010;-            // No pattern matched... initiating fallback check and conversion (if required).&#010;-            // The source at this point may contain illegal values or special characters&#010;-            if (!foundFlag) {&#010;-                milliseconds = Long.valueOf(source);&#010;-            }&#010;-        }&#010;-&#010;-        return milliseconds;&#010;-    }&#010;-&#010;-    private static void checkCorrectnessOfPattern(String source) {&#010;-        //replace only numbers once&#010;-        Matcher matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;-        String replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        //replace hour string once&#010;-        matcher = createMatcher(HOUR_REGEX_PATTERN, replaceSource);&#010;-        if (matcher.find() &amp;&amp; matcher.find()) {&#010;-            throw new IllegalArgumentException(""Hours should not be specified more then once: "" + source);&#010;-        }&#010;-        replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        //replace minutes once&#010;-        matcher = createMatcher(MINUTES_REGEX_PATTERN, replaceSource);&#010;-        if (matcher.find() &amp;&amp; matcher.find()) {&#010;-            throw new IllegalArgumentException(""Minutes should not be specified more then once: "" + source);&#010;-        }&#010;-        replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        //replace seconds once&#010;-        matcher = createMatcher(SECONDS_REGEX_PATTERN, replaceSource);&#010;-        if (matcher.find() &amp;&amp; matcher.find()) {&#010;-            throw new IllegalArgumentException(""Seconds should not be specified more then once: "" + source);&#010;-        }&#010;-        replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        if (replaceSource.length() &gt; 0) {&#010;-            throw new IllegalArgumentException(""Illegal characters: "" + source);&#010;-        }&#010;-    }&#010;-&#010;-    private static Matcher createMatcher(Pattern pattern, String source) {&#010;-        return pattern.matcher(source);&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java b/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java&#010;deleted file mode 100644&#010;index ea1ecd5..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java&#010;+++ /dev/null&#010;@@ -1,392 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.io.UnsupportedEncodingException;&#010;-import java.net.URI;&#010;-import java.net.URISyntaxException;&#010;-import java.net.URLDecoder;&#010;-import java.net.URLEncoder;&#010;-import java.util.ArrayList;&#010;-import java.util.Iterator;&#010;-import java.util.LinkedHashMap;&#010;-import java.util.List;&#010;-import java.util.Map;&#010;-&#010;-/**&#010;- * Copied from org.apache.camel.util.URISupport&#010;- */&#010;-public final class URISupport {&#010;-&#010;-    public static final String RAW_TOKEN_START = ""RAW("";&#010;-    public static final String RAW_TOKEN_END = "")"";&#010;-&#010;-    private static final String CHARSET = ""UTF-8"";&#010;-&#010;-    private URISupport() {&#010;-        // Helper class&#010;-    }&#010;-&#010;-    /**&#010;-     * Normalizes the URI so unsafe characters is encoded&#010;-     *&#010;-     * @param uri the input uri&#010;-     * @return as URI instance&#010;-     * @throws URISyntaxException is thrown if syntax error in the input uri&#010;-     */&#010;-    public static URI normalizeUri(String uri) throws URISyntaxException {&#010;-        return new URI(UnsafeUriCharactersEncoder.encode(uri, true));&#010;-    }&#010;-&#010;-    public static Map&lt;String, Object&gt; extractProperties(Map&lt;String, Object&gt; properties, String optionPrefix) {&#010;-        Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;(properties.size());&#010;-&#010;-        for (Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; it = properties.entrySet().iterator(); it.hasNext();) {&#010;-            Map.Entry&lt;String, Object&gt; entry = it.next();&#010;-            String name = entry.getKey();&#010;-            if (name.startsWith(optionPrefix)) {&#010;-                Object value = properties.get(name);&#010;-                name = name.substring(optionPrefix.length());&#010;-                rc.put(name, value);&#010;-                it.remove();&#010;-            }&#010;-        }&#010;-&#010;-        return rc;&#010;-    }&#010;-&#010;-    /**&#010;-     * Strips the query parameters from the uri&#010;-     *&#010;-     * @param uri  the uri&#010;-     * @return the uri without the query parameter&#010;-     */&#010;-    public static String stripQuery(String uri) {&#010;-        int idx = uri.indexOf('?');&#010;-        if (idx &gt; -1) {&#010;-            uri = uri.substring(0, idx);&#010;-        }&#010;-        return uri;&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the query parameters of the uri (eg the query part).&#010;-     *&#010;-     * @param uri the uri&#010;-     * @return the parameters, or an empty map if no parameters (eg never null)&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     */&#010;-    public static Map&lt;String, Object&gt; parseParameters(URI uri) throws URISyntaxException {&#010;-        String query = uri.getQuery();&#010;-        if (query == null) {&#010;-            String schemeSpecificPart = uri.getSchemeSpecificPart();&#010;-            int idx = schemeSpecificPart.indexOf('?');&#010;-            if (idx &lt; 0) {&#010;-                // return an empty map&#010;-                return new LinkedHashMap&lt;String, Object&gt;(0);&#010;-            } else {&#010;-                query = schemeSpecificPart.substring(idx + 1);&#010;-            }&#010;-        } else {&#010;-            query = stripPrefix(query, ""?"");&#010;-        }&#010;-        return parseQuery(query);&#010;-    }&#010;-&#010;-    /**&#010;-     * Strips the prefix from the value.&#010;-     * &lt;p/&gt;&#010;-     * Returns the value as-is if not starting with the prefix.&#010;-     *&#010;-     * @param value  the value&#010;-     * @param prefix the prefix to remove from value&#010;-     * @return the value without the prefix&#010;-     */&#010;-    public static String stripPrefix(String value, String prefix) {&#010;-        if (value != null &amp;&amp; value.startsWith(prefix)) {&#010;-            return value.substring(prefix.length());&#010;-        }&#010;-        return value;&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the query part of the uri (eg the parameters).&#010;-     * &lt;p/&gt;&#010;-     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;-     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;-     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;-     *&#010;-     * @param uri the uri&#010;-     * @return the parameters, or an empty map if no parameters (eg never null)&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     * @see #RAW_TOKEN_START&#010;-     * @see #RAW_TOKEN_END&#010;-     */&#010;-    public static Map&lt;String, Object&gt; parseQuery(String uri) throws URISyntaxException {&#010;-        return parseQuery(uri, false);&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the query part of the uri (eg the parameters).&#010;-     * &lt;p/&gt;&#010;-     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;-     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;-     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;-     *&#010;-     * @param uri the uri&#010;-     * @param useRaw whether to force using raw values&#010;-     * @return the parameters, or an empty map if no parameters (eg never null)&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     * @see #RAW_TOKEN_START&#010;-     * @see #RAW_TOKEN_END&#010;-     */&#010;-    public static Map&lt;String, Object&gt; parseQuery(String uri, boolean useRaw) throws URISyntaxException {&#010;-        // must check for trailing &amp; as the uri.split(""&amp;"") will ignore those&#010;-        if (uri != null &amp;&amp; uri.endsWith(""&amp;"")) {&#010;-            throw new URISyntaxException(uri, ""Invalid uri syntax: Trailing &amp; marker found. ""&#010;-                    + ""Check the uri and remove the trailing &amp; marker."");&#010;-        }&#010;-&#010;-        if (isEmpty(uri)) {&#010;-            // return an empty map&#010;-            return new LinkedHashMap&lt;String, Object&gt;(0);&#010;-        }&#010;-&#010;-        // need to parse the uri query parameters manually as we cannot rely on splitting by &amp;,&#010;-        // as &amp; can be used in a parameter value as well.&#010;-&#010;-        try {&#010;-            // use a linked map so the parameters is in the same order&#010;-            Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;();&#010;-&#010;-            boolean isKey = true;&#010;-            boolean isValue = false;&#010;-            boolean isRaw = false;&#010;-            StringBuilder key = new StringBuilder();&#010;-            StringBuilder value = new StringBuilder();&#010;-&#010;-            // parse the uri parameters char by char&#010;-            for (int i = 0; i &lt; uri.length(); i++) {&#010;-                // current char&#010;-                char ch = uri.charAt(i);&#010;-                // look ahead of the next char&#010;-                char next;&#010;-                if (i &lt;= uri.length() - 2) {&#010;-                    next = uri.charAt(i + 1);&#010;-                } else {&#010;-                    next = '\u0000';&#010;-                }&#010;-&#010;-                // are we a raw value&#010;-                isRaw = value.toString().startsWith(RAW_TOKEN_START);&#010;-&#010;-                // if we are in raw mode, then we keep adding until we hit the end marker&#010;-                if (isRaw) {&#010;-                    if (isKey) {&#010;-                        key.append(ch);&#010;-                    } else if (isValue) {&#010;-                        value.append(ch);&#010;-                    }&#010;-&#010;-                    // we only end the raw marker if its )&amp; or at the end of the value&#010;-&#010;-                    boolean end = ch == RAW_TOKEN_END.charAt(0) &amp;&amp; (next == '&amp;' || next == '\u0000');&#010;-                    if (end) {&#010;-                        // raw value end, so add that as a parameter, and reset flags&#010;-                        addParameter(key.toString(), value.toString(), rc, useRaw || isRaw);&#010;-                        key.setLength(0);&#010;-                        value.setLength(0);&#010;-                        isKey = true;&#010;-                        isValue = false;&#010;-                        isRaw = false;&#010;-                        // skip to next as we are in raw mode and have already added the value&#010;-                        i++;&#010;-                    }&#010;-                    continue;&#010;-                }&#010;-&#010;-                // if its a key and there is a = sign then the key ends and we are in value mode&#010;-                if (isKey &amp;&amp; ch == '=') {&#010;-                    isKey = false;&#010;-                    isValue = true;&#010;-                    isRaw = false;&#010;-                    continue;&#010;-                }&#010;-&#010;-                // the &amp; denote parameter is ended&#010;-                if (ch == '&amp;') {&#010;-                    // parameter is ended, as we hit &amp; separator&#010;-                    String aKey = key.toString();&#010;-                    // the key may be a placeholder of options which we then do not know what is&#010;-                    boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;-                    if (validKey) {&#010;-                        addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;-                    }&#010;-                    key.setLength(0);&#010;-                    value.setLength(0);&#010;-                    isKey = true;&#010;-                    isValue = false;&#010;-                    isRaw = false;&#010;-                    continue;&#010;-                }&#010;-&#010;-                // regular char so add it to the key or value&#010;-                if (isKey) {&#010;-                    key.append(ch);&#010;-                } else if (isValue) {&#010;-                    value.append(ch);&#010;-                }&#010;-            }&#010;-&#010;-            // any left over parameters, then add that&#010;-            if (key.length() &gt; 0) {&#010;-                String aKey = key.toString();&#010;-                // the key may be a placeholder of options which we then do not know what is&#010;-                boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;-                if (validKey) {&#010;-                    addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;-                }&#010;-            }&#010;-&#010;-            return rc;&#010;-&#010;-        } catch (UnsupportedEncodingException e) {&#010;-            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;-            se.initCause(e);&#010;-            throw se;&#010;-        }&#010;-    }&#010;-&#010;-    @SuppressWarnings(""unchecked"")&#010;-    private static void addParameter(String name, String value, Map&lt;String, Object&gt; map, boolean isRaw) throws UnsupportedEncodingException {&#010;-        name = URLDecoder.decode(name, CHARSET);&#010;-        if (!isRaw) {&#010;-            // need to replace % with %25&#010;-            value = URLDecoder.decode(value.replaceAll(""%"", ""%25""), CHARSET);&#010;-        }&#010;-&#010;-        // does the key already exist?&#010;-        if (map.containsKey(name)) {&#010;-            // yes it does, so make sure we can support multiple values, but using a list&#010;-            // to hold the multiple values&#010;-            Object existing = map.get(name);&#010;-            List&lt;String&gt; list;&#010;-            if (existing instanceof List) {&#010;-                list = (List&lt;String&gt;) existing;&#010;-            } else {&#010;-                // create a new list to hold the multiple values&#010;-                list = new ArrayList&lt;String&gt;();&#010;-                String s = existing != null ? existing.toString() : null;&#010;-                if (s != null) {&#010;-                    list.add(s);&#010;-                }&#010;-            }&#010;-            list.add(value);&#010;-            map.put(name, list);&#010;-        } else {&#010;-            map.put(name, value);&#010;-        }&#010;-    }&#010;-&#010;-    /**&#010;-     * Assembles a query from the given map.&#010;-     *&#010;-     * @param options  the map with the options (eg key/value pairs)&#010;-     * @param ampersand to use &amp; for Java code, and &amp;amp; for XML&#010;-     * @return a query string with &lt;tt&gt;key1=value&amp;key2=value2&amp;...&lt;/tt&gt;, or an empty string if there is no options.&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     */&#010;-    public static String createQueryString(Map&lt;String, String&gt; options, String ampersand, boolean encode) throws URISyntaxException {&#010;-        try {&#010;-            if (options.size() &gt; 0) {&#010;-                StringBuilder rc = new StringBuilder();&#010;-                boolean first = true;&#010;-                for (Object o : options.keySet()) {&#010;-                    if (first) {&#010;-                        first = false;&#010;-                    } else {&#010;-                        rc.append(ampersand);&#010;-                    }&#010;-&#010;-                    String key = (String) o;&#010;-                    Object value = options.get(key);&#010;-&#010;-                    // use the value as a String&#010;-                    String s = value != null ? value.toString() : null;&#010;-                    appendQueryStringParameter(key, s, rc, encode);&#010;-                }&#010;-                return rc.toString();&#010;-            } else {&#010;-                return """";&#010;-            }&#010;-        } catch (UnsupportedEncodingException e) {&#010;-            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;-            se.initCause(e);&#010;-            throw se;&#010;-        }&#010;-    }&#010;-&#010;-    private static void appendQueryStringParameter(String key, String value, StringBuilder rc, boolean encode) throws UnsupportedEncodingException {&#010;-        if (encode) {&#010;-            rc.append(URLEncoder.encode(key, CHARSET));&#010;-        } else {&#010;-            rc.append(key);&#010;-        }&#010;-        // only append if value is not null&#010;-        if (value != null) {&#010;-            rc.append(""="");&#010;-            if (value.startsWith(RAW_TOKEN_START) &amp;&amp; value.endsWith(RAW_TOKEN_END)) {&#010;-                // do not encode RAW parameters&#010;-                rc.append(value);&#010;-            } else {&#010;-                if (encode) {&#010;-                    rc.append(URLEncoder.encode(value, CHARSET));&#010;-                } else {&#010;-                    rc.append(value);&#010;-                }&#010;-            }&#010;-        }&#010;-    }&#010;-&#010;-    /**&#010;-     * Tests whether the value is &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;-     *&#010;-     * @param value  the value, if its a String it will be tested for text length as well&#010;-     * @return true if empty&#010;-     */&#010;-    public static boolean isEmpty(Object value) {&#010;-        return !isNotEmpty(value);&#010;-    }&#010;-&#010;-    /**&#010;-     * Tests whether the value is &lt;b&gt;not&lt;/b&gt; &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;-     *&#010;-     * @param value  the value, if its a String it will be tested for text length as well&#010;-     * @return true if &lt;b&gt;not&lt;/b&gt; empty&#010;-     */&#010;-    public static boolean isNotEmpty(Object value) {&#010;-        if (value == null) {&#010;-            return false;&#010;-        } else if (value instanceof String) {&#010;-            String text = (String) value;&#010;-            return text.trim().length() &gt; 0;&#010;-        } else {&#010;-            return true;&#010;-        }&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java b/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&#010;deleted file mode 100644&#010;index 563bac2..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&#010;+++ /dev/null&#010;@@ -1,206 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.ArrayList;&#010;-import java.util.BitSet;&#010;-import java.util.List;&#010;-import java.util.regex.Matcher;&#010;-import java.util.regex.Pattern;&#010;-&#010;-/**&#010;- * Encoder for unsafe URI characters.&#010;- * &lt;p/&gt;&#010;- * A good source for details is &lt;a href=""http://en.wikipedia.org/wiki/Url_encode""&gt;wikipedia url encode&lt;/a&gt; article.&#010;- */&#010;-public final class UnsafeUriCharactersEncoder {&#010;-    private static BitSet unsafeCharactersRfc1738;&#010;-    private static BitSet unsafeCharactersHttp;&#010;-    private static final char[] HEX_DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C',&#010;-        'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'};&#010;-    private static final Pattern RAW_PATTERN = Pattern.compile(""RAW\\([^\\)]+\\)"");&#010;-&#010;-    static {&#010;-        unsafeCharactersRfc1738 = new BitSet(256);&#010;-        unsafeCharactersRfc1738.set(' ');&#010;-        unsafeCharactersRfc1738.set('""');&#010;-        unsafeCharactersRfc1738.set('&lt;');&#010;-        unsafeCharactersRfc1738.set('&gt;');&#010;-        unsafeCharactersRfc1738.set('#');&#010;-        unsafeCharactersRfc1738.set('%');&#010;-        unsafeCharactersRfc1738.set('{');&#010;-        unsafeCharactersRfc1738.set('}');&#010;-        unsafeCharactersRfc1738.set('|');&#010;-        unsafeCharactersRfc1738.set('\\');&#010;-        unsafeCharactersRfc1738.set('^');&#010;-        unsafeCharactersRfc1738.set('~');&#010;-        unsafeCharactersRfc1738.set('[');&#010;-        unsafeCharactersRfc1738.set(']');&#010;-        unsafeCharactersRfc1738.set('`');&#010;-    }&#010;-&#010;-    static {&#010;-        unsafeCharactersHttp = new BitSet(256);&#010;-        unsafeCharactersHttp.set(' ');&#010;-        unsafeCharactersHttp.set('""');&#010;-        unsafeCharactersHttp.set('&lt;');&#010;-        unsafeCharactersHttp.set('&gt;');&#010;-        unsafeCharactersHttp.set('#');&#010;-        unsafeCharactersHttp.set('%');&#010;-        unsafeCharactersHttp.set('{');&#010;-        unsafeCharactersHttp.set('}');&#010;-        unsafeCharactersHttp.set('|');&#010;-        unsafeCharactersHttp.set('\\');&#010;-        unsafeCharactersHttp.set('^');&#010;-        unsafeCharactersHttp.set('~');&#010;-        unsafeCharactersHttp.set('`');&#010;-    }&#010;-&#010;-    private UnsafeUriCharactersEncoder() {&#010;-        // util class&#010;-    }&#010;-&#010;-    public static String encode(String s) {&#010;-        return encode(s, unsafeCharactersRfc1738);&#010;-    }&#010;-&#010;-    public static String encodeHttpURI(String s) {&#010;-        return encode(s, unsafeCharactersHttp);&#010;-    }&#010;-&#010;-    public static String encode(String s, BitSet unsafeCharacters) {&#010;-        return encode(s, unsafeCharacters, false);&#010;-    }&#010;-&#010;-    public static String encode(String s, boolean checkRaw) {&#010;-        return encode(s, unsafeCharactersRfc1738, checkRaw);&#010;-    }&#010;-&#010;-    public static String encodeHttpURI(String s, boolean checkRaw) {&#010;-        return encode(s, unsafeCharactersHttp, checkRaw);&#010;-    }&#010;-&#010;-    private static List&lt;Pair&gt; checkRAW(String s) {&#010;-        Matcher matcher = RAW_PATTERN.matcher(s);&#010;-        List&lt;Pair&gt; answer = new ArrayList&lt;Pair&gt;();&#010;-        // Check all occurrences&#010;-        while (matcher.find()) {&#010;-            answer.add(new Pair(matcher.start(), matcher.end()));&#010;-        }&#010;-        return answer;&#010;-    }&#010;-&#010;-    private static boolean isRaw(int index, List&lt;Pair&gt; pairs) {&#010;-        for (Pair pair : pairs) {&#010;-            if (index &lt; pair.left) {&#010;-                return false;&#010;-            } else {&#010;-                if (index &gt;= pair.left) {&#010;-                    if (index &lt;= pair.right) {&#010;-                        return true;&#010;-                    } else {&#010;-                        continue;&#010;-                    }&#010;-                }&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    private static class Pair {&#010;-        int left;&#010;-        int right;&#010;-&#010;-        Pair(int left, int right) {&#010;-            this.left = left;&#010;-            this.right = right;&#010;-        }&#010;-    }&#010;-&#010;-    // Just skip the encode for isRAW part&#010;-    public static String encode(String s, BitSet unsafeCharacters, boolean checkRaw) {&#010;-        List&lt;Pair&gt; rawPairs;&#010;-        if (checkRaw) {&#010;-            rawPairs = checkRAW(s);&#010;-        } else {&#010;-            rawPairs = new ArrayList&lt;Pair&gt;();&#010;-        }&#010;-&#010;-        int n = s == null ? 0 : s.length();&#010;-        if (n == 0) {&#010;-            return s;&#010;-        }&#010;-&#010;-        // First check whether we actually need to encode&#010;-        char chars[] = s.toCharArray();&#010;-        for (int i = 0;;) {&#010;-            // just deal with the ascii character&#010;-            if (chars[i] &gt; 0 &amp;&amp; chars[i] &lt; 128) {&#010;-                if (unsafeCharacters.get(chars[i])) {&#010;-                    break;&#010;-                }&#010;-            }&#010;-            if (++i &gt;= chars.length) {&#010;-                return s;&#010;-            }&#010;-        }&#010;-&#010;-        // okay there are some unsafe characters so we do need to encode&#010;-        // see details at: http://en.wikipedia.org/wiki/Url_encode&#010;-        StringBuilder sb = new StringBuilder();&#010;-        for (int i = 0; i &lt; chars.length; i++) {&#010;-            char ch = chars[i];&#010;-            if (ch &gt; 0 &amp;&amp; ch &lt; 128 &amp;&amp; unsafeCharacters.get(ch)) {&#010;-                // special for % sign as it may be a decimal encoded value&#010;-                if (ch == '%') {&#010;-                    char next = i + 1 &lt; chars.length ? chars[i + 1] : ' ';&#010;-                    char next2 = i + 2 &lt; chars.length ? chars[i + 2] : ' ';&#010;-&#010;-                    if (isHexDigit(next) &amp;&amp; isHexDigit(next2) &amp;&amp; !isRaw(i, rawPairs)) {&#010;-                        // its already encoded (decimal encoded) so just append as is&#010;-                        sb.append(ch);&#010;-                    } else {&#010;-                        // must escape then, as its an unsafe character&#010;-                        appendEscape(sb, (byte) ch);&#010;-                    }&#010;-                } else {&#010;-                    // must escape then, as its an unsafe character&#010;-                    appendEscape(sb, (byte) ch);&#010;-                }&#010;-            } else {&#010;-                sb.append(ch);&#010;-            }&#010;-        }&#010;-        return sb.toString();&#010;-    }&#010;-&#010;-    private static void appendEscape(StringBuilder sb, byte b) {&#010;-        sb.append('%');&#010;-        sb.append(HEX_DIGITS[(b &gt;&gt; 4) &amp; 0x0f]);&#010;-        sb.append(HEX_DIGITS[(b &gt;&gt; 0) &amp; 0x0f]);&#010;-    }&#010;-&#010;-    private static boolean isHexDigit(char ch) {&#010;-        for (char hex : HEX_DIGITS) {&#010;-            if (hex == ch) {&#010;-                return true;&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/package.html&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/package.html b/camel-core/src/main/java/org/apache/camel/catalog/package.html&#010;deleted file mode 100644&#010;index 98786d1..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/package.html&#010;+++ /dev/null&#010;@@ -1,25 +0,0 @@&#010;-&lt;!--&#010;-    Licensed to the Apache Software Foundation (ASF) under one or more&#010;-    contributor license agreements.  See the NOTICE file distributed with&#010;-    this work for additional information regarding copyright ownership.&#010;-    The ASF licenses this file to You under the Apache License, Version 2.0&#010;-    (the ""License""); you may not use this file except in compliance with&#010;-    the License.  You may obtain a copy of the License at&#010;-&#010;-    http://www.apache.org/licenses/LICENSE-2.0&#010;-&#010;-    Unless required by applicable law or agreed to in writing, software&#010;-    distributed under the License is distributed on an ""AS IS"" BASIS,&#010;-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;-    See the License for the specific language governing permissions and&#010;-    limitations under the License.&#010;---&gt;&#010;-&lt;html&gt;&#010;-&lt;head&gt;&#010;-&lt;/head&gt;&#010;-&lt;body&gt;&#010;-&#010;-Camel Catalog&#010;-&#010;-&lt;/body&gt;&#010;-&lt;/html&gt;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java b/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;index 5d19e0d..4013e5f 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;@@ -22,12 +22,12 @@ import java.util.Map;&#010; import org.apache.camel.Component;&#010; import org.apache.camel.ComponentVerifier;&#010; import org.apache.camel.VerifiableComponent;&#010;-import org.apache.camel.catalog.JSonSchemaHelper;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010; import org.apache.camel.impl.verifier.CatalogVerifierCustomizer;&#010; import org.apache.camel.impl.verifier.DefaultComponentVerifier;&#010; import org.apache.camel.impl.verifier.ResultBuilder;&#010; import org.apache.camel.impl.verifier.ResultErrorBuilder;&#010;+import org.apache.camel.runtimecatalog.JSonSchemaHelper;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.RestConsumerFactory;&#010; import org.apache.camel.spi.RestProducerFactory;&#010; import org.apache.camel.util.ObjectHelper;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;index c85ce8c..b53efc8 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;@@ -26,7 +26,6 @@ import java.util.Collections;&#010; import java.util.Comparator;&#010; import java.util.Date;&#010; import java.util.HashMap;&#010;-import java.util.HashSet;&#010; import java.util.Iterator;&#010; import java.util.LinkedHashMap;&#010; import java.util.LinkedHashSet;&#010;@@ -87,8 +86,6 @@ import org.apache.camel.api.management.mbean.ManagedRouteMBean;&#010; import org.apache.camel.builder.DefaultFluentProducerTemplate;&#010; import org.apache.camel.builder.ErrorHandlerBuilder;&#010; import org.apache.camel.builder.ErrorHandlerBuilderSupport;&#010;-import org.apache.camel.catalog.DefaultRuntimeCamelCatalog;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010; import org.apache.camel.component.properties.PropertiesComponent;&#010; import org.apache.camel.impl.converter.BaseTypeConverterRegistry;&#010; import org.apache.camel.impl.converter.DefaultTypeConverter;&#010;@@ -121,6 +118,8 @@ import org.apache.camel.processor.interceptor.Delayer;&#010; import org.apache.camel.processor.interceptor.HandleFault;&#010; import org.apache.camel.processor.interceptor.StreamCaching;&#010; import org.apache.camel.processor.interceptor.Tracer;&#010;+import org.apache.camel.runtimecatalog.DefaultRuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.AsyncProcessorAwaitManager;&#010; import org.apache.camel.spi.CamelContextNameStrategy;&#010; import org.apache.camel.spi.ClassResolver;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java b/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;index b9d9998..f05cdb1 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;@@ -25,8 +25,8 @@ import org.apache.camel.CamelContext;&#010; import org.apache.camel.ComponentVerifier;&#010; import org.apache.camel.NoSuchOptionException;&#010; import org.apache.camel.TypeConverter;&#010;-import org.apache.camel.catalog.EndpointValidationResult;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.EndpointValidationResult;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.util.CamelContextHelper;&#010; import org.apache.camel.util.EndpointHelper;&#010; import org.apache.camel.util.IntrospectionSupport;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;index a09ff7d..9a70390 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;@@ -46,12 +46,9 @@ import org.apache.camel.StartupListener;&#010; import org.apache.camel.TimerListener;&#010; import org.apache.camel.VetoCamelContextStartException;&#010; import org.apache.camel.api.management.PerformanceCounter;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010; import org.apache.camel.impl.ConsumerCache;&#010; import org.apache.camel.impl.DefaultCamelContext;&#010; import org.apache.camel.impl.DefaultEndpointRegistry;&#010;-import org.apache.camel.impl.DefaultTransformerRegistry;&#010;-import org.apache.camel.impl.DefaultValidatorRegistry;&#010; import org.apache.camel.impl.EventDrivenConsumerRoute;&#010; import org.apache.camel.impl.ProducerCache;&#010; import org.apache.camel.impl.ThrottlingExceptionRoutePolicy;&#010;@@ -89,6 +86,7 @@ import org.apache.camel.processor.CamelInternalProcessor;&#010; import org.apache.camel.processor.interceptor.BacklogDebugger;&#010; import org.apache.camel.processor.interceptor.BacklogTracer;&#010; import org.apache.camel.processor.interceptor.Tracer;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.AsyncProcessorAwaitManager;&#010; import org.apache.camel.spi.DataFormat;&#010; import org.apache.camel.spi.EventNotifier;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;index 20d3f28..6a99656 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;@@ -19,7 +19,7 @@ package org.apache.camel.management.mbean;&#010; import org.apache.camel.CamelContext;&#010; import org.apache.camel.api.management.ManagedResource;&#010; import org.apache.camel.api.management.mbean.ManagedRuntimeCamelCatalogMBean;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.ManagementStrategy;&#010; &#010; /**&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C6a3e7fae5cba4f918aede10c3ae6ef26%40git.apache.org%3E,2017-04-14 10:52,commits,5.0,326.0,  [5/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
21,322.0,davscl...@apache.org,"Repository: camel&#010;Updated Branches:&#010;  refs/heads/master d72696455 -&gt; 6b42a3534&#010;&#010;&#010;Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/6b42a353&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/6b42a353&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/6b42a353&#010;&#010;Branch: refs/heads/master&#010;Commit: 6b42a3534120f58180e6194e6bf4f1a284707abc&#010;Parents: c66be7a&#010;Author: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Authored: Fri Apr 14 12:17:14 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:52:40 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; platforms/camel-catalog/pom.xml | 40 ++++++++++++++++++++++++++++++++++--&#010; 1 file changed, 38 insertions(+), 2 deletions(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/6b42a353/platforms/camel-catalog/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/platforms/camel-catalog/pom.xml b/platforms/camel-catalog/pom.xml&#010;index 2be82e0..6c71fcb 100644&#010;--- a/platforms/camel-catalog/pom.xml&#010;+++ b/platforms/camel-catalog/pom.xml&#010;@@ -92,7 +92,7 @@&#010;         &lt;executions&gt;&#010;           &lt;execution&gt;&#010;             &lt;id&gt;copy-resources&lt;/id&gt;&#010;-            &lt;phase&gt;process-sources&lt;/phase&gt;&#010;+            &lt;phase&gt;generate-sources&lt;/phase&gt;&#010;             &lt;goals&gt;&#010;               &lt;goal&gt;copy-resources&lt;/goal&gt;&#010;             &lt;/goals&gt;&#010;@@ -101,7 +101,7 @@&#010;               &lt;overwrite&gt;true&lt;/overwrite&gt;&#010;               &lt;resources&gt;&#010;                 &lt;resource&gt;&#010;-                  &lt;directory&gt;../../camel-core/src/main/java/org/apache/camel/catalog&lt;/directory&gt;&#010;+                  &lt;directory&gt;../../camel-core/src/main/java/org/apache/camel/runtimecatalog&lt;/directory&gt;&#010;                   &lt;!-- the following files are maintained in camel-core and not here,&#010;so they are copied over --&gt;&#010;                   &lt;includes&gt;&#010;                     &lt;include&gt;AbstractCamelCatalog.java&lt;/include&gt;&#010;@@ -123,6 +123,42 @@&#010;           &lt;/execution&gt;&#010;         &lt;/executions&gt;&#010;       &lt;/plugin&gt;&#010;+      &lt;!-- rename runtimecatalog to catalog which is the package name we use here --&gt;&#010;+      &lt;plugin&gt;&#010;+        &lt;groupId&gt;com.google.code.maven-replacer-plugin&lt;/groupId&gt;&#010;+        &lt;artifactId&gt;replacer&lt;/artifactId&gt;&#010;+        &lt;version&gt;1.5.3&lt;/version&gt;&#010;+        &lt;executions&gt;&#010;+          &lt;execution&gt;&#010;+            &lt;phase&gt;process-sources&lt;/phase&gt;&#010;+            &lt;goals&gt;&#010;+              &lt;goal&gt;replace&lt;/goal&gt;&#010;+            &lt;/goals&gt;&#010;+          &lt;/execution&gt;&#010;+        &lt;/executions&gt;&#010;+        &lt;configuration&gt;&#010;+          &lt;includes&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/AbstractCamelCatalog.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/CatalogHelper.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/CollectionStringBuffer.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&lt;/include&gt;&#010;+            &lt;include&gt;${basedir}/src/main/java/org/apache/camel/catalog/URISupport.java&lt;/include&gt;&#010;+          &lt;/includes&gt;&#010;+          &lt;replacements&gt;&#010;+            &lt;replacement&gt;&#010;+              &lt;token&gt;org.apache.camel.runtimecatalog&lt;/token&gt;&#010;+              &lt;value&gt;org.apache.camel.catalog&lt;/value&gt;&#010;+            &lt;/replacement&gt;&#010;+          &lt;/replacements&gt;&#010;+        &lt;/configuration&gt;&#010;+      &lt;/plugin&gt;&#010; &#010;       &lt;!-- generate and include all components in the catalog --&gt;&#010;       &lt;plugin&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cde5de0a2e2ca40e6bcaa03835723a40e%40git.apache.org%3E,2017-04-14 10:52,commits,6.0,322.0,[1/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
22,323.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;b/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;new file mode 100644&#010;index 0000000..309fb8e&#010;--- /dev/null&#010;+++ b/camel-core/src/test/java/org/apache/camel/runtimecatalog/AbstractCamelCatalogTest.java&#010;@@ -0,0 +1,104 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.net.URISyntaxException;&#010;+import java.util.HashMap;&#010;+import java.util.Map;&#010;+&#010;+import org.junit.Before;&#010;+import org.junit.Test;&#010;+&#010;+import static org.easymock.EasyMock.expect;&#010;+import static org.easymock.EasyMock.mock;&#010;+import static org.easymock.EasyMock.replay;&#010;+import static org.junit.Assert.assertEquals;&#010;+&#010;+public class AbstractCamelCatalogTest {&#010;+&#010;+    AbstractCamelCatalog catalog = new AbstractCamelCatalog() {&#010;+    };&#010;+&#010;+    JSonSchemaResolver resolver;&#010;+&#010;+    @Before&#010;+    public void setupMockCatalog() {&#010;+        resolver = mock(JSonSchemaResolver.class);&#010;+&#010;+        catalog.setJSonSchemaResolver(resolver);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void shouldConstructEndpointUris() throws URISyntaxException {&#010;+        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;+            + ""  \""component\"": {\n""//&#010;+            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;+            + ""  }\n""//&#010;+            + ""}"");&#010;+&#010;+        replay(resolver);&#010;+&#010;+        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;+        properties.put(""param1"", ""value1"");&#010;+        properties.put(""param2"", ""value2"");&#010;+        properties.put(""param3"", ""value3"");&#010;+&#010;+        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;+&#010;+        assertEquals(""comp:value1:value2?param3=value3"", endpointUri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void shouldConstructEndpointUrisWithPropertyPlaceholders() throws URISyntaxException&#010;{&#010;+        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;+            + ""  \""component\"": {\n""//&#010;+            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;+            + ""  }\n""//&#010;+            + ""}"");&#010;+&#010;+        replay(resolver);&#010;+&#010;+        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;+        properties.put(""param1"", ""{{prop1}}"");&#010;+        properties.put(""param2"", ""{{prop2}}"");&#010;+        properties.put(""param3"", ""{{prop3}}"");&#010;+&#010;+        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;+&#010;+        assertEquals(""comp:{{prop1}}:{{prop2}}?param3={{prop3}}"", endpointUri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void shouldConstructEndpointUrisWhenValuesContainTokens() throws URISyntaxException&#010;{&#010;+        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;+            + ""  \""component\"": {\n""//&#010;+            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;+            + ""  }\n""//&#010;+            + ""}"");&#010;+&#010;+        replay(resolver);&#010;+&#010;+        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;+        properties.put(""param1"", ""{value1}"");&#010;+        properties.put(""param2"", ""/value2/"");&#010;+        properties.put(""param3"", ""/value3/{param}"");&#010;+&#010;+        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;+&#010;+        assertEquals(""comp:{value1}:/value2/?param3=/value3/{param}"", endpointUri);&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;b/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;new file mode 100644&#010;index 0000000..dfdd5c5&#010;--- /dev/null&#010;+++ b/camel-core/src/test/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalogTest.java&#010;@@ -0,0 +1,393 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.HashMap;&#010;+import java.util.Map;&#010;+&#010;+import org.apache.camel.impl.DefaultCamelContext;&#010;+import org.junit.BeforeClass;&#010;+import org.junit.Test;&#010;+import org.slf4j.Logger;&#010;+import org.slf4j.LoggerFactory;&#010;+&#010;+import static org.junit.Assert.assertEquals;&#010;+import static org.junit.Assert.assertFalse;&#010;+import static org.junit.Assert.assertNotNull;&#010;+import static org.junit.Assert.assertTrue;&#010;+&#010;+public class RuntimeCamelCatalogTest {&#010;+&#010;+    static RuntimeCamelCatalog catalog;&#010;+&#010;+    private static final Logger LOG = LoggerFactory.getLogger(RuntimeCamelCatalogTest.class);&#010;+&#010;+    @BeforeClass&#010;+    public static void createCamelCatalog() {&#010;+        catalog = new DefaultRuntimeCamelCatalog(new DefaultCamelContext());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testFromCamelContext() throws Exception {&#010;+        String schema = new DefaultCamelContext().getRuntimeCamelCatalog().modelJSonSchema(""choice"");&#010;+        assertNotNull(schema);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testJsonSchema() throws Exception {&#010;+        String schema = catalog.modelJSonSchema(""aggregate"");&#010;+        assertNotNull(schema);&#010;+&#010;+        // lets make it possible to find bean/method using both names&#010;+        schema = catalog.modelJSonSchema(""method"");&#010;+        assertNotNull(schema);&#010;+        schema = catalog.modelJSonSchema(""bean"");&#010;+        assertNotNull(schema);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriMapFile() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""directoryName"", ""src/data/inbox"");&#010;+        map.put(""noop"", ""true"");&#010;+        map.put(""delay"", ""5000"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""file"", map, true);&#010;+        assertEquals(""file:src/data/inbox?delay=5000&amp;noop=true"", uri);&#010;+&#010;+        String uri2 = catalog.asEndpointUriXml(""file"", map, true);&#010;+        assertEquals(""file:src/data/inbox?delay=5000&amp;amp;noop=true"", uri2);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriTimer() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""timerName"", ""foo"");&#010;+        map.put(""period"", ""5000"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;+        assertEquals(""timer:foo?period=5000"", uri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriPropertiesPlaceholders() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""timerName"", ""foo"");&#010;+        map.put(""period"", ""{{howoften}}"");&#010;+        map.put(""repeatCount"", ""5"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;+        assertEquals(""timer:foo?period=%7B%7Bhowoften%7D%7D&amp;repeatCount=5"", uri);&#010;+&#010;+        uri = catalog.asEndpointUri(""timer"", map, false);&#010;+        assertEquals(""timer:foo?period={{howoften}}&amp;repeatCount=5"", uri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriBeanLookup() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""resourceUri"", ""foo.xslt"");&#010;+        map.put(""converter"", ""#myConverter"");&#010;+&#010;+        String uri = catalog.asEndpointUri(""xslt"", map, true);&#010;+        assertEquals(""xslt:foo.xslt?converter=%23myConverter"", uri);&#010;+&#010;+        uri = catalog.asEndpointUri(""xslt"", map, false);&#010;+        assertEquals(""xslt:foo.xslt?converter=#myConverter"", uri);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testEndpointPropertiesPlaceholders() throws Exception {&#010;+        Map&lt;String, String&gt; map = catalog.endpointProperties(""timer:foo?period={{howoften}}&amp;repeatCount=5"");&#010;+        assertNotNull(map);&#010;+        assertEquals(3, map.size());&#010;+&#010;+        assertEquals(""foo"", map.get(""timerName""));&#010;+        assertEquals(""{{howoften}}"", map.get(""period""));&#010;+        assertEquals(""5"", map.get(""repeatCount""));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriLog() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""loggerName"", ""foo"");&#010;+        map.put(""loggerLevel"", ""WARN"");&#010;+        map.put(""multiline"", ""true"");&#010;+        map.put(""showAll"", ""true"");&#010;+        map.put(""showBody"", ""false"");&#010;+        map.put(""showBodyType"", ""false"");&#010;+        map.put(""showExchangePattern"", ""false"");&#010;+        map.put(""style"", ""Tab"");&#010;+&#010;+        assertEquals(""log:foo?loggerLevel=WARN&amp;multiline=true&amp;showAll=true&amp;style=Tab"",&#010;catalog.asEndpointUri(""log"", map, false));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriLogShort() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""loggerName"", ""foo"");&#010;+        map.put(""loggerLevel"", ""DEBUG"");&#010;+&#010;+        assertEquals(""log:foo?loggerLevel=DEBUG"", catalog.asEndpointUri(""log"", map, false));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testAsEndpointUriWithplaceholder() throws Exception {&#010;+        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;+        map.put(""name"", ""foo"");&#010;+        map.put(""blockWhenFull"", ""{{block}}"");&#010;+        assertEquals(""seda:foo?blockWhenFull={{block}}"", catalog.asEndpointUri(""seda"", map,&#010;false));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testEndpointPropertiesSedaRequired() throws Exception {&#010;+        Map&lt;String, String&gt; map = catalog.endpointProperties(""seda:foo"");&#010;+        assertNotNull(map);&#010;+        assertEquals(1, map.size());&#010;+&#010;+        assertEquals(""foo"", map.get(""name""));&#010;+&#010;+        map = catalog.endpointProperties(""seda:foo?blockWhenFull=true"");&#010;+        assertNotNull(map);&#010;+        assertEquals(2, map.size());&#010;+&#010;+        assertEquals(""foo"", map.get(""name""));&#010;+        assertEquals(""true"", map.get(""blockWhenFull""));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void validateProperties() throws Exception {&#010;+        // valid&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(""log:mylog"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // unknown&#010;+        result = catalog.validateEndpointProperties(""log:mylog?level=WARN&amp;foo=bar"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getUnknown().contains(""foo""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // enum&#010;+        result = catalog.validateEndpointProperties(""seda:foo?waitForTaskToComplete=blah"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""blah"", result.getInvalidEnum().get(""waitForTaskToComplete""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // reference okay&#010;+        result = catalog.validateEndpointProperties(""seda:foo?queue=#queue"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(0, result.getNumberOfErrors());&#010;+&#010;+        // unknown component&#010;+        result = catalog.validateEndpointProperties(""foo:bar?me=you"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getUnknownComponent().equals(""foo""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // invalid boolean but default value&#010;+        result = catalog.validateEndpointProperties(""log:output?showAll=ggg"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""ggg"", result.getInvalidBoolean().get(""showAll""));&#010;+        assertEquals(1, result.getNumberOfErrors());&#010;+&#010;+        // dataset&#010;+        result = catalog.validateEndpointProperties(""dataset:foo?minRate=50"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // time pattern&#010;+        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=true&amp;delay=0&amp;period=2s"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // reference lookup&#010;+        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=#fixed&amp;delay=#myDelay"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // optional consumer. prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?consumer.delay=5000&amp;consumer.greedy=true"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // optional without consumer. prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;greedy=true"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // mixed optional without consumer. prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;consumer.greedy=true"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // prefix&#010;+        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;scheduler.foo=123&amp;scheduler.bar=456"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // stub&#010;+        result = catalog.validateEndpointProperties(""stub:foo?me=123&amp;you=456"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // lenient on&#010;+        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"");&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // lenient off&#010;+        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"",&#010;true);&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getUnknown().contains(""foo""));&#010;+&#010;+        // data format&#010;+        result = catalog.validateEndpointProperties(""dataformat:string:marshal?charset=utf-8"",&#010;true);&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        // incapable to parse&#010;+        result = catalog.validateEndpointProperties(""{{getFtpUrl}}?recursive=true"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertTrue(result.getIncapable() != null);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void validatePropertiesSummary() throws Exception {&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(""yammer:MESSAGES?blah=yada&amp;accessToken=aaa&amp;consumerKey=&amp;useJson=no&amp;initialDelay=five&amp;pollStrategy=myStrategy"");&#010;+        assertFalse(result.isSuccess());&#010;+        String reason = result.summaryErrorMessage(true);&#010;+        LOG.info(reason);&#010;+&#010;+        result = catalog.validateEndpointProperties(""jms:unknown:myqueue"");&#010;+        assertFalse(result.isSuccess());&#010;+        reason = result.summaryErrorMessage(false);&#010;+        LOG.info(reason);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void validateTimePattern() throws Exception {&#010;+        assertTrue(catalog.validateTimePattern(""0""));&#010;+        assertTrue(catalog.validateTimePattern(""500""));&#010;+        assertTrue(catalog.validateTimePattern(""10000""));&#010;+        assertTrue(catalog.validateTimePattern(""5s""));&#010;+        assertTrue(catalog.validateTimePattern(""5sec""));&#010;+        assertTrue(catalog.validateTimePattern(""5secs""));&#010;+        assertTrue(catalog.validateTimePattern(""3m""));&#010;+        assertTrue(catalog.validateTimePattern(""3min""));&#010;+        assertTrue(catalog.validateTimePattern(""3minutes""));&#010;+        assertTrue(catalog.validateTimePattern(""5m15s""));&#010;+        assertTrue(catalog.validateTimePattern(""1h""));&#010;+        assertTrue(catalog.validateTimePattern(""1hour""));&#010;+        assertTrue(catalog.validateTimePattern(""2hours""));&#010;+&#010;+        assertFalse(catalog.validateTimePattern(""bla""));&#010;+        assertFalse(catalog.validateTimePattern(""2year""));&#010;+        assertFalse(catalog.validateTimePattern(""60darn""));&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testEndpointComponentName() throws Exception {&#010;+        String name = catalog.endpointComponentName(""jms:queue:foo"");&#010;+        assertEquals(""jms"", name);&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testSimpleExpression() throws Exception {&#010;+        SimpleValidationResult result = catalog.validateSimpleExpression(null, ""${body}"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body}"", result.getSimple());&#010;+&#010;+        result = catalog.validateSimpleExpression(null, ""${body"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""${body"", result.getSimple());&#010;+        LOG.info(result.getError());&#010;+        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol&#010;at location 5""));&#010;+        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;+        assertEquals(5, result.getIndex());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testSimplePredicate() throws Exception {&#010;+        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} ==&#010;'abc'"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body} == 'abc'"", result.getSimple());&#010;+&#010;+        result = catalog.validateSimplePredicate(null, ""${body} &gt; ${header.size"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""${body} &gt; ${header.size"", result.getSimple());&#010;+        LOG.info(result.getError());&#010;+        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol&#010;at location 22""));&#010;+        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;+        assertEquals(22, result.getIndex());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testSimplePredicatePlaceholder() throws Exception {&#010;+        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} contains&#010;'{{danger}}'"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body} contains '{{danger}}'"", result.getSimple());&#010;+&#010;+        result = catalog.validateSimplePredicate(null, ""${bdy} contains '{{danger}}'"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""${bdy} contains '{{danger}}'"", result.getSimple());&#010;+        LOG.info(result.getError());&#010;+        assertTrue(result.getError().startsWith(""Unknown function: bdy at location 0""));&#010;+        assertTrue(result.getError().contains(""'{{danger}}'""));&#010;+        assertEquals(""Unknown function: bdy"", result.getShortError());&#010;+        assertEquals(0, result.getIndex());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testValidateLanguage() throws Exception {&#010;+        LanguageValidationResult result = catalog.validateLanguageExpression(null, ""simple"",&#010;""${body}"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body}"", result.getText());&#010;+&#010;+        result = catalog.validateLanguageExpression(null, ""header"", ""foo"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""foo"", result.getText());&#010;+&#010;+        result = catalog.validateLanguagePredicate(null, ""simple"", ""${body} &gt; 10"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""${body} &gt; 10"", result.getText());&#010;+&#010;+        result = catalog.validateLanguagePredicate(null, ""header"", ""bar"");&#010;+        assertTrue(result.isSuccess());&#010;+        assertEquals(""bar"", result.getText());&#010;+&#010;+        result = catalog.validateLanguagePredicate(null, ""foobar"", ""bar"");&#010;+        assertFalse(result.isSuccess());&#010;+        assertEquals(""Unknown language foobar"", result.getError());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testValidateEndpointConsumerOnly() throws Exception {&#010;+        String uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true"";&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false,&#010;true, false);&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true&amp;fileExist=Append"";&#010;+        result = catalog.validateEndpointProperties(uri, false, true, false);&#010;+        assertFalse(result.isSuccess());&#010;+&#010;+        assertEquals(""fileExist"", result.getNotConsumerOnly().iterator().next());&#010;+    }&#010;+&#010;+    @Test&#010;+    public void testValidateEndpointProducerOnly() throws Exception {&#010;+        String uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append"";&#010;+        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false,&#010;false, true);&#010;+        assertTrue(result.isSuccess());&#010;+&#010;+        uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append&amp;delete=true"";&#010;+        result = catalog.validateEndpointProperties(uri, false, false, true);&#010;+        assertFalse(result.isSuccess());&#010;+&#010;+        assertEquals(""delete"", result.getNotProducerOnly().iterator().next());&#010;+    }&#010;+&#010;+}&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C9e3f964e77d045cf840b002cc3565efe%40git.apache.org%3E,2017-04-14 10:52,commits,6.0,323.0,  [2/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
23,324.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java&#010;new file mode 100644&#010;index 0000000..1e69269&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaHelper.java&#010;@@ -0,0 +1,424 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.ArrayList;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.LinkedHashSet;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+import java.util.Set;&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+public final class JSonSchemaHelper {&#010;+&#010;+    // 0 = text, 1 = enum, 2 = boolean, 3 = integer or number&#010;+    private static final Pattern PATTERN = Pattern.compile(""\""(.+?)\""|\\[(.+)\\]|(true|false)|(-?\\d+\\.?\\d*)"");&#010;+    private static final String QUOT = ""&amp;quot;"";&#010;+&#010;+    private JSonSchemaHelper() {&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the json schema to split it into a list or rows, where each row contains key value pairs with the metadata&#010;+     *&#010;+     * @param group the group to parse from such as &lt;tt&gt;component&lt;/tt&gt;, &lt;tt&gt;componentProperties&lt;/tt&gt;, or &lt;tt&gt;properties&lt;/tt&gt;.&#010;+     * @param json the json&#010;+     * @return a list of all the rows, where each row is a set of key value pairs with metadata&#010;+     */&#010;+    public static List&lt;Map&lt;String, String&gt;&gt; parseJsonSchema(String group, String json, boolean parseProperties) {&#010;+        List&lt;Map&lt;String, String&gt;&gt; answer = new ArrayList&lt;Map&lt;String, String&gt;&gt;();&#010;+        if (json == null) {&#010;+            return answer;&#010;+        }&#010;+&#010;+        boolean found = false;&#010;+&#010;+        // parse line by line&#010;+        String[] lines = json.split(""\n"");&#010;+        for (String line : lines) {&#010;+            // we need to find the group first&#010;+            if (!found) {&#010;+                String s = line.trim();&#010;+                found = s.startsWith(""\"""" + group + ""\"":"") &amp;&amp; s.endsWith(""{"");&#010;+                continue;&#010;+            }&#010;+&#010;+            // we should stop when we end the group&#010;+            if (line.equals(""  },"") || line.equals(""  }"")) {&#010;+                break;&#010;+            }&#010;+&#010;+            // need to safe encode \"" so we can parse the line&#010;+            line = line.replaceAll(""\""\\\\\""\"""", '""' + QUOT + '""');&#010;+&#010;+            Map&lt;String, String&gt; row = new LinkedHashMap&lt;String, String&gt;();&#010;+            Matcher matcher = PATTERN.matcher(line);&#010;+&#010;+            String key;&#010;+            if (parseProperties) {&#010;+                // when parsing properties the first key is given as name, so the first parsed token is the value of the name&#010;+                key = ""name"";&#010;+            } else {&#010;+                key = null;&#010;+            }&#010;+            while (matcher.find()) {&#010;+                if (key == null) {&#010;+                    key = matcher.group(1);&#010;+                } else {&#010;+                    String value = matcher.group(1);&#010;+                    if (value != null) {&#010;+                        // its text based&#010;+                        value = value.trim();&#010;+                        // decode&#010;+                        value = value.replaceAll(QUOT, ""\"""");&#010;+                        value = decodeJson(value);&#010;+                    }&#010;+                    if (value == null) {&#010;+                        // not text then its maybe an enum?&#010;+                        value = matcher.group(2);&#010;+                        if (value != null) {&#010;+                            // its an enum so strip out "" and trim spaces after comma&#010;+                            value = value.replaceAll(""\"""", """");&#010;+                            value = value.replaceAll("", "", "","");&#010;+                            value = value.trim();&#010;+                        }&#010;+                    }&#010;+                    if (value == null) {&#010;+                        // not text then its maybe a boolean?&#010;+                        value = matcher.group(3);&#010;+                    }&#010;+                    if (value == null) {&#010;+                        // not text then its maybe a integer?&#010;+                        value = matcher.group(4);&#010;+                    }&#010;+                    if (value != null) {&#010;+                        row.put(key, value);&#010;+                    }&#010;+                    // reset&#010;+                    key = null;&#010;+                }&#010;+            }&#010;+            if (!row.isEmpty()) {&#010;+                answer.add(row);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    private static String decodeJson(String value) {&#010;+        // json encodes a \ as \\ so we need to decode from \\ back to \&#010;+        if (""\\\\"".equals(value)) {&#010;+            value = ""\\"";&#010;+        }&#010;+        return value;&#010;+    }&#010;+&#010;+    public static boolean isComponentLenientProperties(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""lenientProperties"")) {&#010;+                return ""true"".equals(row.get(""lenientProperties""));&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isComponentConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""consumerOnly"")) {&#010;+                return ""true"".equals(row.get(""consumerOnly""));&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isComponentProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""producerOnly"")) {&#010;+                return ""true"".equals(row.get(""producerOnly""));&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String labels = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""label"")) {&#010;+                labels = row.get(""label"");&#010;+            }&#010;+            if (found) {&#010;+                return labels != null &amp;&amp; labels.contains(""consumer"");&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String labels = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""label"")) {&#010;+                labels = row.get(""label"");&#010;+            }&#010;+            if (found) {&#010;+                return labels != null &amp;&amp; labels.contains(""producer"");&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyRequired(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            boolean required = false;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""required"")) {&#010;+                required = ""true"".equals(row.get(""required""));&#010;+            }&#010;+            if (found) {&#010;+                return required;&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static String getPropertyKind(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String kind = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""kind"")) {&#010;+                kind = row.get(""kind"");&#010;+            }&#010;+            if (found) {&#010;+                return kind;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static boolean isPropertyBoolean(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""boolean"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyInteger(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""integer"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyNumber(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""number"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static boolean isPropertyObject(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String type = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""type"")) {&#010;+                type = row.get(""type"");&#010;+            }&#010;+            if (found) {&#010;+                return ""object"".equals(type);&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static String getPropertyDefaultValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String defaultValue = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""defaultValue"")) {&#010;+                defaultValue = row.get(""defaultValue"");&#010;+            }&#010;+            if (found) {&#010;+                return defaultValue;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static String stripOptionalPrefixFromName(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String optionalPrefix = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""optionalPrefix"")) {&#010;+                optionalPrefix = row.get(""optionalPrefix"");&#010;+            }&#010;+            if (row.containsKey(""name"")) {&#010;+                if (optionalPrefix != null &amp;&amp; name.startsWith(optionalPrefix)) {&#010;+                    name = name.substring(optionalPrefix.length());&#010;+                    // try again&#010;+                    return stripOptionalPrefixFromName(rows, name);&#010;+                } else {&#010;+                    found = name.equals(row.get(""name""));&#010;+                }&#010;+            }&#010;+            if (found) {&#010;+                return name;&#010;+            }&#010;+        }&#010;+        return name;&#010;+    }&#010;+&#010;+    public static String getPropertyEnum(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String enums = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""enum"")) {&#010;+                enums = row.get(""enum"");&#010;+            }&#010;+            if (found) {&#010;+                return enums;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static String getPropertyPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String prefix = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""prefix"")) {&#010;+                prefix = row.get(""prefix"");&#010;+            }&#010;+            if (found) {&#010;+                return prefix;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static boolean isPropertyMultiValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            boolean multiValue = false;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                found = name.equals(row.get(""name""));&#010;+            }&#010;+            if (row.containsKey(""multiValue"")) {&#010;+                multiValue = ""true"".equals(row.get(""multiValue""));&#010;+            }&#010;+            if (found) {&#010;+                return multiValue;&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    public static String getPropertyNameFromNameWithPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String propertyName = null;&#010;+            boolean found = false;&#010;+            if (row.containsKey(""name"")) {&#010;+                propertyName = row.get(""name"");&#010;+            }&#010;+            if (row.containsKey(""prefix"")) {&#010;+                String preifx = row.get(""prefix"");&#010;+                found = name.startsWith(preifx);&#010;+            }&#010;+            if (found) {&#010;+                return propertyName;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static Map&lt;String, String&gt; getRow(List&lt;Map&lt;String, String&gt;&gt; rows, String key) {&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (key.equals(row.get(""name""))) {&#010;+                return row;&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public static Set&lt;String&gt; getNames(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;+        Set&lt;String&gt; answer = new LinkedHashSet&lt;String&gt;();&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""name"")) {&#010;+                answer.add(row.get(""name""));&#010;+            }&#010;+        }&#010;+        return answer;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java&#010;new file mode 100644&#010;index 0000000..dbd6f45&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/JSonSchemaResolver.java&#010;@@ -0,0 +1,64 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+/**&#010;+ * Pluggable resolver to load JSon schema files for components, data formats, languages etc.&#010;+ */&#010;+public interface JSonSchemaResolver {&#010;+&#010;+    /**&#010;+     * Returns the component information as JSon format.&#010;+     *&#010;+     * @param name the component name&#010;+     * @return component details in JSon&#010;+     */&#010;+    String getComponentJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the data format information as JSon format.&#010;+     *&#010;+     * @param name the data format name&#010;+     * @return data format details in JSon&#010;+     */&#010;+    String getDataFormatJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the language information as JSon format.&#010;+     *&#010;+     * @param name the language name&#010;+     * @return language details in JSon&#010;+     */&#010;+    String getLanguageJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the other (miscellaneous) information as JSon format.&#010;+     *&#010;+     * @param name the other (miscellaneous) name&#010;+     * @return other (miscellaneous) details in JSon&#010;+     */&#010;+    String getOtherJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the model information as JSon format.&#010;+     *&#010;+     * @param name the model name&#010;+     * @return model details in JSon&#010;+     */&#010;+    String getModelJSonSchema(String name);&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java&#010;new file mode 100644&#010;index 0000000..dbb5525&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/LanguageValidationResult.java&#010;@@ -0,0 +1,65 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.Serializable;&#010;+&#010;+/**&#010;+ * Validation result of parsing a language expression or predicate&#010;+ */&#010;+public class LanguageValidationResult implements Serializable {&#010;+    private final String text;&#010;+    private String error;&#010;+    private String shortError;&#010;+    private int index;&#010;+&#010;+    public LanguageValidationResult(String text) {&#010;+        this.text = text;&#010;+    }&#010;+&#010;+    public String getText() {&#010;+        return text;&#010;+    }&#010;+&#010;+    public boolean isSuccess() {&#010;+        return error == null;&#010;+    }&#010;+&#010;+    public void setError(String error) {&#010;+        this.error = error;&#010;+    }&#010;+&#010;+    public String getError() {&#010;+        return error;&#010;+    }&#010;+&#010;+    public String getShortError() {&#010;+        return shortError;&#010;+    }&#010;+&#010;+    public void setShortError(String shortError) {&#010;+        this.shortError = shortError;&#010;+    }&#010;+&#010;+    public int getIndex() {&#010;+        return index;&#010;+    }&#010;+&#010;+    public void setIndex(int index) {&#010;+        this.index = index;&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java&#010;new file mode 100644&#010;index 0000000..86c4b53&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/RuntimeCamelCatalog.java&#010;@@ -0,0 +1,234 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.net.URISyntaxException;&#010;+import java.util.Map;&#010;+&#010;+import org.apache.camel.StaticService;&#010;+&#010;+/**&#010;+ * Runtime based CamelCatalog which are included in camel-core that can provided limit CamelCatalog capabilities&#010;+ */&#010;+public interface RuntimeCamelCatalog extends StaticService {&#010;+&#010;+    /**&#010;+     * Returns the component information as JSon format.&#010;+     *&#010;+     * @param name the component name&#010;+     * @return component details in JSon&#010;+     */&#010;+    String componentJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the data format information as JSon format.&#010;+     *&#010;+     * @param name the data format name&#010;+     * @return data format details in JSon&#010;+     */&#010;+    String dataFormatJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the language information as JSon format.&#010;+     *&#010;+     * @param name the language name&#010;+     * @return language details in JSon&#010;+     */&#010;+    String languageJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Returns the model information as JSon format.&#010;+     *&#010;+     * @param name the model name&#010;+     * @return model details in JSon&#010;+     */&#010;+    String modelJSonSchema(String name);&#010;+&#010;+    /**&#010;+     * Parses the endpoint uri and constructs a key/value properties of each option&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return properties as key value pairs of each endpoint option&#010;+     */&#010;+    Map&lt;String, String&gt; endpointProperties(String uri) throws URISyntaxException;&#010;+&#010;+    /**&#010;+     * Parses the endpoint uri and constructs a key/value properties of only the lenient properties (eg custom options)&#010;+     * &lt;p/&gt;&#010;+     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return properties as key value pairs of each lenient properties&#010;+     */&#010;+    Map&lt;String, String&gt; endpointLenientProperties(String uri) throws URISyntaxException;&#010;+&#010;+    /**&#010;+     * Validates the pattern whether its a valid time pattern.&#010;+     *&#010;+     * @param pattern  the pattern such as 5000, 5s, 5sec, 4min, 4m30s, 1h, etc.&#010;+     * @return &lt;tt&gt;true&lt;/tt&gt; if valid, &lt;tt&gt;false&lt;/tt&gt; if invalid&#010;+     */&#010;+    boolean validateTimePattern(String pattern);&#010;+&#010;+    /**&#010;+     * Validates the properties for the given scheme against component and endpoint&#010;+     *&#010;+     * @param scheme  the endpoint scheme&#010;+     * @param properties  the endpoint properties&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateProperties(String scheme, Map&lt;String, String&gt; properties);&#010;+&#010;+    /**&#010;+     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateEndpointProperties(String uri);&#010;+&#010;+    /**&#010;+     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;+     * &lt;p/&gt;&#010;+     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;+     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;+     * but in the uri because of using lenient properties.&#010;+     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties);&#010;+&#010;+    /**&#010;+     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;+     * &lt;p/&gt;&#010;+     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;+     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;+     * but in the uri because of using lenient properties.&#010;+     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;+     * @param consumerOnly whether the endpoint is only used as a consumer&#010;+     * @param producerOnly whether the endpoint is only used as a producer&#010;+     * @return validation result&#010;+     */&#010;+    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties, boolean consumerOnly, boolean producerOnly);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple expression.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param simple  the simple expression&#010;+     * @return validation result&#010;+     * @deprecated use {@link #validateSimpleExpression(ClassLoader, String)}&#010;+     */&#010;+    @Deprecated&#010;+    SimpleValidationResult validateSimpleExpression(String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple expression.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param simple  the simple expression&#010;+     * @return validation result&#010;+     */&#010;+    SimpleValidationResult validateSimpleExpression(ClassLoader classLoader, String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple predicate&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param simple  the simple predicate&#010;+     * @return validation result&#010;+     * @deprecated use {@link #validateSimplePredicate(ClassLoader, String)}&#010;+     */&#010;+    @Deprecated&#010;+    SimpleValidationResult validateSimplePredicate(String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the simple predicate&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param simple  the simple predicate&#010;+     * @return validation result&#010;+     */&#010;+    SimpleValidationResult validateSimplePredicate(ClassLoader classLoader, String simple);&#010;+&#010;+    /**&#010;+     * Parses and validates the language as a predicate&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param language the name of the language&#010;+     * @param text  the predicate text&#010;+     * @return validation result&#010;+     */&#010;+    LanguageValidationResult validateLanguagePredicate(ClassLoader classLoader, String language, String text);&#010;+&#010;+    /**&#010;+     * Parses and validates the language as an expression&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;+     *&#010;+     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;+     * @param language the name of the language&#010;+     * @param text  the expression text&#010;+     * @return validation result&#010;+     */&#010;+    LanguageValidationResult validateLanguageExpression(ClassLoader classLoader, String language, String text);&#010;+&#010;+    /**&#010;+     * Returns the component name from the given endpoint uri&#010;+     *&#010;+     * @param uri  the endpoint uri&#010;+     * @return the component name (aka scheme), or &lt;tt&gt;null&lt;/tt&gt; if not possible to determine&#010;+     */&#010;+    String endpointComponentName(String uri);&#010;+&#010;+    /**&#010;+     * Creates an endpoint uri in Java style from the information from the properties&#010;+     *&#010;+     * @param scheme the endpoint schema&#010;+     * @param properties the properties as key value pairs&#010;+     * @param encode whether to URL encode the returned uri or not&#010;+     * @return the constructed endpoint uri&#010;+     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;+     */&#010;+    String asEndpointUri(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;+&#010;+    /**&#010;+     * Creates an endpoint uri in XML style (eg escape &amp; as &amp;ampl;) from the information from the properties&#010;+     *&#010;+     * @param scheme the endpoint schema&#010;+     * @param properties the properties as key value pairs&#010;+     * @param encode whether to URL encode the returned uri or not&#010;+     * @return the constructed endpoint uri&#010;+     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;+     */&#010;+    String asEndpointUriXml(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java&#010;new file mode 100644&#010;index 0000000..1b8dd0e&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SimpleValidationResult.java&#010;@@ -0,0 +1,32 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+/**&#010;+ * To be backwards compatible, but favor using {@link LanguageValidationResult} instead.&#010;+ */&#010;+public class SimpleValidationResult extends LanguageValidationResult {&#010;+&#010;+    public SimpleValidationResult(String text) {&#010;+        super(text);&#010;+    }&#010;+&#010;+    public String getSimple() {&#010;+        return getText();&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java&#010;new file mode 100644&#010;index 0000000..e29afc6&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/SuggestionStrategy.java&#010;@@ -0,0 +1,34 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.Set;&#010;+&#010;+/**&#010;+ * Strategy to provide suggestions for unknown endpoint options&#010;+ */&#010;+public interface SuggestionStrategy {&#010;+&#010;+    /**&#010;+     * Provides a list of valid option names for a did you mean function.&#010;+     *&#010;+     * @param names         valid names&#010;+     * @param unknownOption unknown option name&#010;+     * @return a list of suggested names (did you mean)&#010;+     */&#010;+    String[] suggestEndpointOptions(Set&lt;String&gt; names, String unknownOption);&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java&#010;new file mode 100644&#010;index 0000000..ed5585c&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/TimePatternConverter.java&#010;@@ -0,0 +1,120 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+/**&#010;+ * This class is a copy from camel-core so we can use it independent to validate uris with time patterns&#010;+ */&#010;+public final class TimePatternConverter {&#010;+    private static final Pattern NUMBERS_ONLY_STRING_PATTERN = Pattern.compile(""^[-]?(\\d)+$"", Pattern.CASE_INSENSITIVE);&#010;+    private static final Pattern HOUR_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))h(our(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;+    private static final Pattern MINUTES_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))m(in(ute(s)?)?)?"", Pattern.CASE_INSENSITIVE);&#010;+    private static final Pattern SECONDS_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))s(ec(ond)?(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;+&#010;+    /**&#010;+     * Utility classes should not have a public constructor.&#010;+     */&#010;+    private TimePatternConverter() {&#010;+    }&#010;+&#010;+    public static long toMilliSeconds(String source) throws IllegalArgumentException {&#010;+        long milliseconds = 0;&#010;+        boolean foundFlag = false;&#010;+&#010;+        checkCorrectnessOfPattern(source);&#010;+        Matcher matcher;&#010;+&#010;+        matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;+        if (matcher.find()) {&#010;+            // Note: This will also be used for regular numeric strings.&#010;+            //       This String -&gt; long converter will be used for all strings.&#010;+            milliseconds = Long.valueOf(source);&#010;+        } else {&#010;+            matcher = createMatcher(HOUR_REGEX_PATTERN, source);&#010;+            if (matcher.find()) {&#010;+                milliseconds = milliseconds + (3600000 * Long.valueOf(matcher.group(1)));&#010;+                foundFlag = true;&#010;+            }&#010;+&#010;+            matcher = createMatcher(MINUTES_REGEX_PATTERN, source);&#010;+            if (matcher.find()) {&#010;+                long minutes = Long.valueOf(matcher.group(1));&#010;+                if ((minutes &gt; 59) &amp;&amp; foundFlag) {&#010;+                    throw new IllegalArgumentException(""Minutes should contain a valid value between 0 and 59: "" + source);&#010;+                }&#010;+                foundFlag = true;&#010;+                milliseconds = milliseconds + (60000 * minutes);&#010;+            }&#010;+&#010;+            matcher = createMatcher(SECONDS_REGEX_PATTERN, source);&#010;+            if (matcher.find()) {&#010;+                long seconds = Long.valueOf(matcher.group(1));&#010;+                if ((seconds &gt; 59) &amp;&amp; foundFlag) {&#010;+                    throw new IllegalArgumentException(""Seconds should contain a valid value between 0 and 59: "" + source);&#010;+                }&#010;+                foundFlag = true;&#010;+                milliseconds = milliseconds + (1000 * seconds);&#010;+            }&#010;+&#010;+            // No pattern matched... initiating fallback check and conversion (if required).&#010;+            // The source at this point may contain illegal values or special characters&#010;+            if (!foundFlag) {&#010;+                milliseconds = Long.valueOf(source);&#010;+            }&#010;+        }&#010;+&#010;+        return milliseconds;&#010;+    }&#010;+&#010;+    private static void checkCorrectnessOfPattern(String source) {&#010;+        //replace only numbers once&#010;+        Matcher matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;+        String replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        //replace hour string once&#010;+        matcher = createMatcher(HOUR_REGEX_PATTERN, replaceSource);&#010;+        if (matcher.find() &amp;&amp; matcher.find()) {&#010;+            throw new IllegalArgumentException(""Hours should not be specified more then once: "" + source);&#010;+        }&#010;+        replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        //replace minutes once&#010;+        matcher = createMatcher(MINUTES_REGEX_PATTERN, replaceSource);&#010;+        if (matcher.find() &amp;&amp; matcher.find()) {&#010;+            throw new IllegalArgumentException(""Minutes should not be specified more then once: "" + source);&#010;+        }&#010;+        replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        //replace seconds once&#010;+        matcher = createMatcher(SECONDS_REGEX_PATTERN, replaceSource);&#010;+        if (matcher.find() &amp;&amp; matcher.find()) {&#010;+            throw new IllegalArgumentException(""Seconds should not be specified more then once: "" + source);&#010;+        }&#010;+        replaceSource = matcher.replaceFirst("""");&#010;+&#010;+        if (replaceSource.length() &gt; 0) {&#010;+            throw new IllegalArgumentException(""Illegal characters: "" + source);&#010;+        }&#010;+    }&#010;+&#010;+    private static Matcher createMatcher(Pattern pattern, String source) {&#010;+        return pattern.matcher(source);&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java&#010;new file mode 100644&#010;index 0000000..8389590&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/URISupport.java&#010;@@ -0,0 +1,392 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.UnsupportedEncodingException;&#010;+import java.net.URI;&#010;+import java.net.URISyntaxException;&#010;+import java.net.URLDecoder;&#010;+import java.net.URLEncoder;&#010;+import java.util.ArrayList;&#010;+import java.util.Iterator;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+&#010;+/**&#010;+ * Copied from org.apache.camel.util.URISupport&#010;+ */&#010;+public final class URISupport {&#010;+&#010;+    public static final String RAW_TOKEN_START = ""RAW("";&#010;+    public static final String RAW_TOKEN_END = "")"";&#010;+&#010;+    private static final String CHARSET = ""UTF-8"";&#010;+&#010;+    private URISupport() {&#010;+        // Helper class&#010;+    }&#010;+&#010;+    /**&#010;+     * Normalizes the URI so unsafe characters is encoded&#010;+     *&#010;+     * @param uri the input uri&#010;+     * @return as URI instance&#010;+     * @throws URISyntaxException is thrown if syntax error in the input uri&#010;+     */&#010;+    public static URI normalizeUri(String uri) throws URISyntaxException {&#010;+        return new URI(UnsafeUriCharactersEncoder.encode(uri, true));&#010;+    }&#010;+&#010;+    public static Map&lt;String, Object&gt; extractProperties(Map&lt;String, Object&gt; properties, String optionPrefix) {&#010;+        Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;(properties.size());&#010;+&#010;+        for (Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; it = properties.entrySet().iterator(); it.hasNext();) {&#010;+            Map.Entry&lt;String, Object&gt; entry = it.next();&#010;+            String name = entry.getKey();&#010;+            if (name.startsWith(optionPrefix)) {&#010;+                Object value = properties.get(name);&#010;+                name = name.substring(optionPrefix.length());&#010;+                rc.put(name, value);&#010;+                it.remove();&#010;+            }&#010;+        }&#010;+&#010;+        return rc;&#010;+    }&#010;+&#010;+    /**&#010;+     * Strips the query parameters from the uri&#010;+     *&#010;+     * @param uri  the uri&#010;+     * @return the uri without the query parameter&#010;+     */&#010;+    public static String stripQuery(String uri) {&#010;+        int idx = uri.indexOf('?');&#010;+        if (idx &gt; -1) {&#010;+            uri = uri.substring(0, idx);&#010;+        }&#010;+        return uri;&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the query parameters of the uri (eg the query part).&#010;+     *&#010;+     * @param uri the uri&#010;+     * @return the parameters, or an empty map if no parameters (eg never null)&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     */&#010;+    public static Map&lt;String, Object&gt; parseParameters(URI uri) throws URISyntaxException {&#010;+        String query = uri.getQuery();&#010;+        if (query == null) {&#010;+            String schemeSpecificPart = uri.getSchemeSpecificPart();&#010;+            int idx = schemeSpecificPart.indexOf('?');&#010;+            if (idx &lt; 0) {&#010;+                // return an empty map&#010;+                return new LinkedHashMap&lt;String, Object&gt;(0);&#010;+            } else {&#010;+                query = schemeSpecificPart.substring(idx + 1);&#010;+            }&#010;+        } else {&#010;+            query = stripPrefix(query, ""?"");&#010;+        }&#010;+        return parseQuery(query);&#010;+    }&#010;+&#010;+    /**&#010;+     * Strips the prefix from the value.&#010;+     * &lt;p/&gt;&#010;+     * Returns the value as-is if not starting with the prefix.&#010;+     *&#010;+     * @param value  the value&#010;+     * @param prefix the prefix to remove from value&#010;+     * @return the value without the prefix&#010;+     */&#010;+    public static String stripPrefix(String value, String prefix) {&#010;+        if (value != null &amp;&amp; value.startsWith(prefix)) {&#010;+            return value.substring(prefix.length());&#010;+        }&#010;+        return value;&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the query part of the uri (eg the parameters).&#010;+     * &lt;p/&gt;&#010;+     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;+     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;+     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;+     *&#010;+     * @param uri the uri&#010;+     * @return the parameters, or an empty map if no parameters (eg never null)&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     * @see #RAW_TOKEN_START&#010;+     * @see #RAW_TOKEN_END&#010;+     */&#010;+    public static Map&lt;String, Object&gt; parseQuery(String uri) throws URISyntaxException {&#010;+        return parseQuery(uri, false);&#010;+    }&#010;+&#010;+    /**&#010;+     * Parses the query part of the uri (eg the parameters).&#010;+     * &lt;p/&gt;&#010;+     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;+     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;+     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;+     *&#010;+     * @param uri the uri&#010;+     * @param useRaw whether to force using raw values&#010;+     * @return the parameters, or an empty map if no parameters (eg never null)&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     * @see #RAW_TOKEN_START&#010;+     * @see #RAW_TOKEN_END&#010;+     */&#010;+    public static Map&lt;String, Object&gt; parseQuery(String uri, boolean useRaw) throws URISyntaxException {&#010;+        // must check for trailing &amp; as the uri.split(""&amp;"") will ignore those&#010;+        if (uri != null &amp;&amp; uri.endsWith(""&amp;"")) {&#010;+            throw new URISyntaxException(uri, ""Invalid uri syntax: Trailing &amp; marker found. ""&#010;+                    + ""Check the uri and remove the trailing &amp; marker."");&#010;+        }&#010;+&#010;+        if (isEmpty(uri)) {&#010;+            // return an empty map&#010;+            return new LinkedHashMap&lt;String, Object&gt;(0);&#010;+        }&#010;+&#010;+        // need to parse the uri query parameters manually as we cannot rely on splitting by &amp;,&#010;+        // as &amp; can be used in a parameter value as well.&#010;+&#010;+        try {&#010;+            // use a linked map so the parameters is in the same order&#010;+            Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;();&#010;+&#010;+            boolean isKey = true;&#010;+            boolean isValue = false;&#010;+            boolean isRaw = false;&#010;+            StringBuilder key = new StringBuilder();&#010;+            StringBuilder value = new StringBuilder();&#010;+&#010;+            // parse the uri parameters char by char&#010;+            for (int i = 0; i &lt; uri.length(); i++) {&#010;+                // current char&#010;+                char ch = uri.charAt(i);&#010;+                // look ahead of the next char&#010;+                char next;&#010;+                if (i &lt;= uri.length() - 2) {&#010;+                    next = uri.charAt(i + 1);&#010;+                } else {&#010;+                    next = '\u0000';&#010;+                }&#010;+&#010;+                // are we a raw value&#010;+                isRaw = value.toString().startsWith(RAW_TOKEN_START);&#010;+&#010;+                // if we are in raw mode, then we keep adding until we hit the end marker&#010;+                if (isRaw) {&#010;+                    if (isKey) {&#010;+                        key.append(ch);&#010;+                    } else if (isValue) {&#010;+                        value.append(ch);&#010;+                    }&#010;+&#010;+                    // we only end the raw marker if its )&amp; or at the end of the value&#010;+&#010;+                    boolean end = ch == RAW_TOKEN_END.charAt(0) &amp;&amp; (next == '&amp;' || next == '\u0000');&#010;+                    if (end) {&#010;+                        // raw value end, so add that as a parameter, and reset flags&#010;+                        addParameter(key.toString(), value.toString(), rc, useRaw || isRaw);&#010;+                        key.setLength(0);&#010;+                        value.setLength(0);&#010;+                        isKey = true;&#010;+                        isValue = false;&#010;+                        isRaw = false;&#010;+                        // skip to next as we are in raw mode and have already added the value&#010;+                        i++;&#010;+                    }&#010;+                    continue;&#010;+                }&#010;+&#010;+                // if its a key and there is a = sign then the key ends and we are in value mode&#010;+                if (isKey &amp;&amp; ch == '=') {&#010;+                    isKey = false;&#010;+                    isValue = true;&#010;+                    isRaw = false;&#010;+                    continue;&#010;+                }&#010;+&#010;+                // the &amp; denote parameter is ended&#010;+                if (ch == '&amp;') {&#010;+                    // parameter is ended, as we hit &amp; separator&#010;+                    String aKey = key.toString();&#010;+                    // the key may be a placeholder of options which we then do not know what is&#010;+                    boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;+                    if (validKey) {&#010;+                        addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;+                    }&#010;+                    key.setLength(0);&#010;+                    value.setLength(0);&#010;+                    isKey = true;&#010;+                    isValue = false;&#010;+                    isRaw = false;&#010;+                    continue;&#010;+                }&#010;+&#010;+                // regular char so add it to the key or value&#010;+                if (isKey) {&#010;+                    key.append(ch);&#010;+                } else if (isValue) {&#010;+                    value.append(ch);&#010;+                }&#010;+            }&#010;+&#010;+            // any left over parameters, then add that&#010;+            if (key.length() &gt; 0) {&#010;+                String aKey = key.toString();&#010;+                // the key may be a placeholder of options which we then do not know what is&#010;+                boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;+                if (validKey) {&#010;+                    addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;+                }&#010;+            }&#010;+&#010;+            return rc;&#010;+&#010;+        } catch (UnsupportedEncodingException e) {&#010;+            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;+            se.initCause(e);&#010;+            throw se;&#010;+        }&#010;+    }&#010;+&#010;+    @SuppressWarnings(""unchecked"")&#010;+    private static void addParameter(String name, String value, Map&lt;String, Object&gt; map, boolean isRaw) throws UnsupportedEncodingException {&#010;+        name = URLDecoder.decode(name, CHARSET);&#010;+        if (!isRaw) {&#010;+            // need to replace % with %25&#010;+            value = URLDecoder.decode(value.replaceAll(""%"", ""%25""), CHARSET);&#010;+        }&#010;+&#010;+        // does the key already exist?&#010;+        if (map.containsKey(name)) {&#010;+            // yes it does, so make sure we can support multiple values, but using a list&#010;+            // to hold the multiple values&#010;+            Object existing = map.get(name);&#010;+            List&lt;String&gt; list;&#010;+            if (existing instanceof List) {&#010;+                list = (List&lt;String&gt;) existing;&#010;+            } else {&#010;+                // create a new list to hold the multiple values&#010;+                list = new ArrayList&lt;String&gt;();&#010;+                String s = existing != null ? existing.toString() : null;&#010;+                if (s != null) {&#010;+                    list.add(s);&#010;+                }&#010;+            }&#010;+            list.add(value);&#010;+            map.put(name, list);&#010;+        } else {&#010;+            map.put(name, value);&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Assembles a query from the given map.&#010;+     *&#010;+     * @param options  the map with the options (eg key/value pairs)&#010;+     * @param ampersand to use &amp; for Java code, and &amp;amp; for XML&#010;+     * @return a query string with &lt;tt&gt;key1=value&amp;key2=value2&amp;...&lt;/tt&gt;, or an empty string if there is no options.&#010;+     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;+     */&#010;+    public static String createQueryString(Map&lt;String, String&gt; options, String ampersand, boolean encode) throws URISyntaxException {&#010;+        try {&#010;+            if (options.size() &gt; 0) {&#010;+                StringBuilder rc = new StringBuilder();&#010;+                boolean first = true;&#010;+                for (Object o : options.keySet()) {&#010;+                    if (first) {&#010;+                        first = false;&#010;+                    } else {&#010;+                        rc.append(ampersand);&#010;+                    }&#010;+&#010;+                    String key = (String) o;&#010;+                    Object value = options.get(key);&#010;+&#010;+                    // use the value as a String&#010;+                    String s = value != null ? value.toString() : null;&#010;+                    appendQueryStringParameter(key, s, rc, encode);&#010;+                }&#010;+                return rc.toString();&#010;+            } else {&#010;+                return """";&#010;+            }&#010;+        } catch (UnsupportedEncodingException e) {&#010;+            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;+            se.initCause(e);&#010;+            throw se;&#010;+        }&#010;+    }&#010;+&#010;+    private static void appendQueryStringParameter(String key, String value, StringBuilder rc, boolean encode) throws UnsupportedEncodingException {&#010;+        if (encode) {&#010;+            rc.append(URLEncoder.encode(key, CHARSET));&#010;+        } else {&#010;+            rc.append(key);&#010;+        }&#010;+        // only append if value is not null&#010;+        if (value != null) {&#010;+            rc.append(""="");&#010;+            if (value.startsWith(RAW_TOKEN_START) &amp;&amp; value.endsWith(RAW_TOKEN_END)) {&#010;+                // do not encode RAW parameters&#010;+                rc.append(value);&#010;+            } else {&#010;+                if (encode) {&#010;+                    rc.append(URLEncoder.encode(value, CHARSET));&#010;+                } else {&#010;+                    rc.append(value);&#010;+                }&#010;+            }&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if empty&#010;+     */&#010;+    public static boolean isEmpty(Object value) {&#010;+        return !isNotEmpty(value);&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;b&gt;not&lt;/b&gt; &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if &lt;b&gt;not&lt;/b&gt; empty&#010;+     */&#010;+    public static boolean isNotEmpty(Object value) {&#010;+        if (value == null) {&#010;+            return false;&#010;+        } else if (value instanceof String) {&#010;+            String text = (String) value;&#010;+            return text.trim().length() &gt; 0;&#010;+        } else {&#010;+            return true;&#010;+        }&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java&#010;new file mode 100644&#010;index 0000000..a11c810&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/UnsafeUriCharactersEncoder.java&#010;@@ -0,0 +1,206 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.ArrayList;&#010;+import java.util.BitSet;&#010;+import java.util.List;&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+/**&#010;+ * Encoder for unsafe URI characters.&#010;+ * &lt;p/&gt;&#010;+ * A good source for details is &lt;a href=""http://en.wikipedia.org/wiki/Url_encode""&gt;wikipedia url encode&lt;/a&gt; article.&#010;+ */&#010;+public final class UnsafeUriCharactersEncoder {&#010;+    private static BitSet unsafeCharactersRfc1738;&#010;+    private static BitSet unsafeCharactersHttp;&#010;+    private static final char[] HEX_DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C',&#010;+        'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'};&#010;+    private static final Pattern RAW_PATTERN = Pattern.compile(""RAW\\([^\\)]+\\)"");&#010;+&#010;+    static {&#010;+        unsafeCharactersRfc1738 = new BitSet(256);&#010;+        unsafeCharactersRfc1738.set(' ');&#010;+        unsafeCharactersRfc1738.set('""');&#010;+        unsafeCharactersRfc1738.set('&lt;');&#010;+        unsafeCharactersRfc1738.set('&gt;');&#010;+        unsafeCharactersRfc1738.set('#');&#010;+        unsafeCharactersRfc1738.set('%');&#010;+        unsafeCharactersRfc1738.set('{');&#010;+        unsafeCharactersRfc1738.set('}');&#010;+        unsafeCharactersRfc1738.set('|');&#010;+        unsafeCharactersRfc1738.set('\\');&#010;+        unsafeCharactersRfc1738.set('^');&#010;+        unsafeCharactersRfc1738.set('~');&#010;+        unsafeCharactersRfc1738.set('[');&#010;+        unsafeCharactersRfc1738.set(']');&#010;+        unsafeCharactersRfc1738.set('`');&#010;+    }&#010;+&#010;+    static {&#010;+        unsafeCharactersHttp = new BitSet(256);&#010;+        unsafeCharactersHttp.set(' ');&#010;+        unsafeCharactersHttp.set('""');&#010;+        unsafeCharactersHttp.set('&lt;');&#010;+        unsafeCharactersHttp.set('&gt;');&#010;+        unsafeCharactersHttp.set('#');&#010;+        unsafeCharactersHttp.set('%');&#010;+        unsafeCharactersHttp.set('{');&#010;+        unsafeCharactersHttp.set('}');&#010;+        unsafeCharactersHttp.set('|');&#010;+        unsafeCharactersHttp.set('\\');&#010;+        unsafeCharactersHttp.set('^');&#010;+        unsafeCharactersHttp.set('~');&#010;+        unsafeCharactersHttp.set('`');&#010;+    }&#010;+&#010;+    private UnsafeUriCharactersEncoder() {&#010;+        // util class&#010;+    }&#010;+&#010;+    public static String encode(String s) {&#010;+        return encode(s, unsafeCharactersRfc1738);&#010;+    }&#010;+&#010;+    public static String encodeHttpURI(String s) {&#010;+        return encode(s, unsafeCharactersHttp);&#010;+    }&#010;+&#010;+    public static String encode(String s, BitSet unsafeCharacters) {&#010;+        return encode(s, unsafeCharacters, false);&#010;+    }&#010;+&#010;+    public static String encode(String s, boolean checkRaw) {&#010;+        return encode(s, unsafeCharactersRfc1738, checkRaw);&#010;+    }&#010;+&#010;+    public static String encodeHttpURI(String s, boolean checkRaw) {&#010;+        return encode(s, unsafeCharactersHttp, checkRaw);&#010;+    }&#010;+&#010;+    private static List&lt;Pair&gt; checkRAW(String s) {&#010;+        Matcher matcher = RAW_PATTERN.matcher(s);&#010;+        List&lt;Pair&gt; answer = new ArrayList&lt;Pair&gt;();&#010;+        // Check all occurrences&#010;+        while (matcher.find()) {&#010;+            answer.add(new Pair(matcher.start(), matcher.end()));&#010;+        }&#010;+        return answer;&#010;+    }&#010;+&#010;+    private static boolean isRaw(int index, List&lt;Pair&gt; pairs) {&#010;+        for (Pair pair : pairs) {&#010;+            if (index &lt; pair.left) {&#010;+                return false;&#010;+            } else {&#010;+                if (index &gt;= pair.left) {&#010;+                    if (index &lt;= pair.right) {&#010;+                        return true;&#010;+                    } else {&#010;+                        continue;&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    private static class Pair {&#010;+        int left;&#010;+        int right;&#010;+&#010;+        Pair(int left, int right) {&#010;+            this.left = left;&#010;+            this.right = right;&#010;+        }&#010;+    }&#010;+&#010;+    // Just skip the encode for isRAW part&#010;+    public static String encode(String s, BitSet unsafeCharacters, boolean checkRaw) {&#010;+        List&lt;Pair&gt; rawPairs;&#010;+        if (checkRaw) {&#010;+            rawPairs = checkRAW(s);&#010;+        } else {&#010;+            rawPairs = new ArrayList&lt;Pair&gt;();&#010;+        }&#010;+&#010;+        int n = s == null ? 0 : s.length();&#010;+        if (n == 0) {&#010;+            return s;&#010;+        }&#010;+&#010;+        // First check whether we actually need to encode&#010;+        char chars[] = s.toCharArray();&#010;+        for (int i = 0;;) {&#010;+            // just deal with the ascii character&#010;+            if (chars[i] &gt; 0 &amp;&amp; chars[i] &lt; 128) {&#010;+                if (unsafeCharacters.get(chars[i])) {&#010;+                    break;&#010;+                }&#010;+            }&#010;+            if (++i &gt;= chars.length) {&#010;+                return s;&#010;+            }&#010;+        }&#010;+&#010;+        // okay there are some unsafe characters so we do need to encode&#010;+        // see details at: http://en.wikipedia.org/wiki/Url_encode&#010;+        StringBuilder sb = new StringBuilder();&#010;+        for (int i = 0; i &lt; chars.length; i++) {&#010;+            char ch = chars[i];&#010;+            if (ch &gt; 0 &amp;&amp; ch &lt; 128 &amp;&amp; unsafeCharacters.get(ch)) {&#010;+                // special for % sign as it may be a decimal encoded value&#010;+                if (ch == '%') {&#010;+                    char next = i + 1 &lt; chars.length ? chars[i + 1] : ' ';&#010;+                    char next2 = i + 2 &lt; chars.length ? chars[i + 2] : ' ';&#010;+&#010;+                    if (isHexDigit(next) &amp;&amp; isHexDigit(next2) &amp;&amp; !isRaw(i, rawPairs)) {&#010;+                        // its already encoded (decimal encoded) so just append as is&#010;+                        sb.append(ch);&#010;+                    } else {&#010;+                        // must escape then, as its an unsafe character&#010;+                        appendEscape(sb, (byte) ch);&#010;+                    }&#010;+                } else {&#010;+                    // must escape then, as its an unsafe character&#010;+                    appendEscape(sb, (byte) ch);&#010;+                }&#010;+            } else {&#010;+                sb.append(ch);&#010;+            }&#010;+        }&#010;+        return sb.toString();&#010;+    }&#010;+&#010;+    private static void appendEscape(StringBuilder sb, byte b) {&#010;+        sb.append('%');&#010;+        sb.append(HEX_DIGITS[(b &gt;&gt; 4) &amp; 0x0f]);&#010;+        sb.append(HEX_DIGITS[(b &gt;&gt; 0) &amp; 0x0f]);&#010;+    }&#010;+&#010;+    private static boolean isHexDigit(char ch) {&#010;+        for (char hex : HEX_DIGITS) {&#010;+            if (hex == ch) {&#010;+                return true;&#010;+            }&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html b/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html&#010;new file mode 100644&#010;index 0000000..2f15a04&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/package.html&#010;@@ -0,0 +1,25 @@&#010;+&lt;!--&#010;+    Licensed to the Apache Software Foundation (ASF) under one or more&#010;+    contributor license agreements.  See the NOTICE file distributed with&#010;+    this work for additional information regarding copyright ownership.&#010;+    The ASF licenses this file to You under the Apache License, Version 2.0&#010;+    (the ""License""); you may not use this file except in compliance with&#010;+    the License.  You may obtain a copy of the License at&#010;+&#010;+    http://www.apache.org/licenses/LICENSE-2.0&#010;+&#010;+    Unless required by applicable law or agreed to in writing, software&#010;+    distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+    See the License for the specific language governing permissions and&#010;+    limitations under the License.&#010;+--&gt;&#010;+&lt;html&gt;&#010;+&lt;head&gt;&#010;+&lt;/head&gt;&#010;+&lt;body&gt;&#010;+&#010;+Runtime Camel Catalog&#010;+&#010;+&lt;/body&gt;&#010;+&lt;/html&gt;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java b/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;index fd22f55..a32c109 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/util/EndpointHelper.java&#010;@@ -37,8 +37,8 @@ import org.apache.camel.PollingConsumer;&#010; import org.apache.camel.Processor;&#010; import org.apache.camel.ResolveEndpointFailedException;&#010; import org.apache.camel.Route;&#010;-import org.apache.camel.catalog.DefaultRuntimeCamelCatalog;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.DefaultRuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.BrowsableEndpoint;&#010; import org.slf4j.Logger;&#010; import org.slf4j.LoggerFactory;&#010;@@ -523,7 +523,7 @@ public final class EndpointHelper {&#010;      * @param uri          the endpoint uri&#010;      * @return a map for each option in the uri with the corresponding information from the json&#010;      * @throws Exception is thrown in case of error&#010;-     * @deprecated use {@link org.apache.camel.catalog.RuntimeCamelCatalog#endpointProperties(String)}&#010;+     * @deprecated use {@link org.apache.camel.runtimecatalog.RuntimeCamelCatalog#endpointProperties(String)}&#010;      */&#010;     @Deprecated&#010;     public static Map&lt;String, Object&gt; endpointProperties(CamelContext camelContext, String uri) throws Exception {&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java b/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java&#010;deleted file mode 100644&#010;index ed7e997..0000000&#010;--- a/camel-core/src/test/java/org/apache/camel/catalog/AbstractCamelCatalogTest.java&#010;+++ /dev/null&#010;@@ -1,104 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.net.URISyntaxException;&#010;-import java.util.HashMap;&#010;-import java.util.Map;&#010;-&#010;-import org.junit.Before;&#010;-import org.junit.Test;&#010;-&#010;-import static org.easymock.EasyMock.expect;&#010;-import static org.easymock.EasyMock.mock;&#010;-import static org.easymock.EasyMock.replay;&#010;-import static org.junit.Assert.assertEquals;&#010;-&#010;-public class AbstractCamelCatalogTest {&#010;-&#010;-    AbstractCamelCatalog catalog = new AbstractCamelCatalog() {&#010;-    };&#010;-&#010;-    JSonSchemaResolver resolver;&#010;-&#010;-    @Before&#010;-    public void setupMockCatalog() {&#010;-        resolver = mock(JSonSchemaResolver.class);&#010;-&#010;-        catalog.setJSonSchemaResolver(resolver);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void shouldConstructEndpointUris() throws URISyntaxException {&#010;-        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;-            + ""  \""component\"": {\n""//&#010;-            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;-            + ""  }\n""//&#010;-            + ""}"");&#010;-&#010;-        replay(resolver);&#010;-&#010;-        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;-        properties.put(""param1"", ""value1"");&#010;-        properties.put(""param2"", ""value2"");&#010;-        properties.put(""param3"", ""value3"");&#010;-&#010;-        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;-&#010;-        assertEquals(""comp:value1:value2?param3=value3"", endpointUri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void shouldConstructEndpointUrisWithPropertyPlaceholders() throws URISyntaxException {&#010;-        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;-            + ""  \""component\"": {\n""//&#010;-            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;-            + ""  }\n""//&#010;-            + ""}"");&#010;-&#010;-        replay(resolver);&#010;-&#010;-        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;-        properties.put(""param1"", ""{{prop1}}"");&#010;-        properties.put(""param2"", ""{{prop2}}"");&#010;-        properties.put(""param3"", ""{{prop3}}"");&#010;-&#010;-        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;-&#010;-        assertEquals(""comp:{{prop1}}:{{prop2}}?param3={{prop3}}"", endpointUri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void shouldConstructEndpointUrisWhenValuesContainTokens() throws URISyntaxException {&#010;-        expect(resolver.getComponentJSonSchema(""comp"")).andReturn(""{\n""//&#010;-            + ""  \""component\"": {\n""//&#010;-            + ""    \""syntax\"": \""comp:param1:param2\""\n""//&#010;-            + ""  }\n""//&#010;-            + ""}"");&#010;-&#010;-        replay(resolver);&#010;-&#010;-        final Map&lt;String, String&gt; properties = new HashMap&lt;&gt;();&#010;-        properties.put(""param1"", ""{value1}"");&#010;-        properties.put(""param2"", ""/value2/"");&#010;-        properties.put(""param3"", ""/value3/{param}"");&#010;-&#010;-        final String endpointUri = catalog.doAsEndpointUri(""comp"", properties, ""&amp;"", false);&#010;-&#010;-        assertEquals(""comp:{value1}:/value2/?param3=/value3/{param}"", endpointUri);&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java b/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java&#010;deleted file mode 100644&#010;index 78e51a2..0000000&#010;--- a/camel-core/src/test/java/org/apache/camel/catalog/RuntimeCamelCatalogTest.java&#010;+++ /dev/null&#010;@@ -1,393 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.HashMap;&#010;-import java.util.Map;&#010;-&#010;-import org.apache.camel.impl.DefaultCamelContext;&#010;-import org.junit.BeforeClass;&#010;-import org.junit.Test;&#010;-import org.slf4j.Logger;&#010;-import org.slf4j.LoggerFactory;&#010;-&#010;-import static org.junit.Assert.assertEquals;&#010;-import static org.junit.Assert.assertFalse;&#010;-import static org.junit.Assert.assertNotNull;&#010;-import static org.junit.Assert.assertTrue;&#010;-&#010;-public class RuntimeCamelCatalogTest {&#010;-&#010;-    static RuntimeCamelCatalog catalog;&#010;-&#010;-    private static final Logger LOG = LoggerFactory.getLogger(RuntimeCamelCatalogTest.class);&#010;-&#010;-    @BeforeClass&#010;-    public static void createCamelCatalog() {&#010;-        catalog = new DefaultRuntimeCamelCatalog(new DefaultCamelContext());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testFromCamelContext() throws Exception {&#010;-        String schema = new DefaultCamelContext().getRuntimeCamelCatalog().modelJSonSchema(""choice"");&#010;-        assertNotNull(schema);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testJsonSchema() throws Exception {&#010;-        String schema = catalog.modelJSonSchema(""aggregate"");&#010;-        assertNotNull(schema);&#010;-&#010;-        // lets make it possible to find bean/method using both names&#010;-        schema = catalog.modelJSonSchema(""method"");&#010;-        assertNotNull(schema);&#010;-        schema = catalog.modelJSonSchema(""bean"");&#010;-        assertNotNull(schema);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriMapFile() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""directoryName"", ""src/data/inbox"");&#010;-        map.put(""noop"", ""true"");&#010;-        map.put(""delay"", ""5000"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""file"", map, true);&#010;-        assertEquals(""file:src/data/inbox?delay=5000&amp;noop=true"", uri);&#010;-&#010;-        String uri2 = catalog.asEndpointUriXml(""file"", map, true);&#010;-        assertEquals(""file:src/data/inbox?delay=5000&amp;amp;noop=true"", uri2);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriTimer() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""timerName"", ""foo"");&#010;-        map.put(""period"", ""5000"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;-        assertEquals(""timer:foo?period=5000"", uri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriPropertiesPlaceholders() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""timerName"", ""foo"");&#010;-        map.put(""period"", ""{{howoften}}"");&#010;-        map.put(""repeatCount"", ""5"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""timer"", map, true);&#010;-        assertEquals(""timer:foo?period=%7B%7Bhowoften%7D%7D&amp;repeatCount=5"", uri);&#010;-&#010;-        uri = catalog.asEndpointUri(""timer"", map, false);&#010;-        assertEquals(""timer:foo?period={{howoften}}&amp;repeatCount=5"", uri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriBeanLookup() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""resourceUri"", ""foo.xslt"");&#010;-        map.put(""converter"", ""#myConverter"");&#010;-&#010;-        String uri = catalog.asEndpointUri(""xslt"", map, true);&#010;-        assertEquals(""xslt:foo.xslt?converter=%23myConverter"", uri);&#010;-&#010;-        uri = catalog.asEndpointUri(""xslt"", map, false);&#010;-        assertEquals(""xslt:foo.xslt?converter=#myConverter"", uri);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testEndpointPropertiesPlaceholders() throws Exception {&#010;-        Map&lt;String, String&gt; map = catalog.endpointProperties(""timer:foo?period={{howoften}}&amp;repeatCount=5"");&#010;-        assertNotNull(map);&#010;-        assertEquals(3, map.size());&#010;-&#010;-        assertEquals(""foo"", map.get(""timerName""));&#010;-        assertEquals(""{{howoften}}"", map.get(""period""));&#010;-        assertEquals(""5"", map.get(""repeatCount""));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriLog() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""loggerName"", ""foo"");&#010;-        map.put(""loggerLevel"", ""WARN"");&#010;-        map.put(""multiline"", ""true"");&#010;-        map.put(""showAll"", ""true"");&#010;-        map.put(""showBody"", ""false"");&#010;-        map.put(""showBodyType"", ""false"");&#010;-        map.put(""showExchangePattern"", ""false"");&#010;-        map.put(""style"", ""Tab"");&#010;-&#010;-        assertEquals(""log:foo?loggerLevel=WARN&amp;multiline=true&amp;showAll=true&amp;style=Tab"", catalog.asEndpointUri(""log"", map, false));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriLogShort() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""loggerName"", ""foo"");&#010;-        map.put(""loggerLevel"", ""DEBUG"");&#010;-&#010;-        assertEquals(""log:foo?loggerLevel=DEBUG"", catalog.asEndpointUri(""log"", map, false));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testAsEndpointUriWithplaceholder() throws Exception {&#010;-        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();&#010;-        map.put(""name"", ""foo"");&#010;-        map.put(""blockWhenFull"", ""{{block}}"");&#010;-        assertEquals(""seda:foo?blockWhenFull={{block}}"", catalog.asEndpointUri(""seda"", map, false));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testEndpointPropertiesSedaRequired() throws Exception {&#010;-        Map&lt;String, String&gt; map = catalog.endpointProperties(""seda:foo"");&#010;-        assertNotNull(map);&#010;-        assertEquals(1, map.size());&#010;-&#010;-        assertEquals(""foo"", map.get(""name""));&#010;-&#010;-        map = catalog.endpointProperties(""seda:foo?blockWhenFull=true"");&#010;-        assertNotNull(map);&#010;-        assertEquals(2, map.size());&#010;-&#010;-        assertEquals(""foo"", map.get(""name""));&#010;-        assertEquals(""true"", map.get(""blockWhenFull""));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void validateProperties() throws Exception {&#010;-        // valid&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(""log:mylog"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // unknown&#010;-        result = catalog.validateEndpointProperties(""log:mylog?level=WARN&amp;foo=bar"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getUnknown().contains(""foo""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // enum&#010;-        result = catalog.validateEndpointProperties(""seda:foo?waitForTaskToComplete=blah"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""blah"", result.getInvalidEnum().get(""waitForTaskToComplete""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // reference okay&#010;-        result = catalog.validateEndpointProperties(""seda:foo?queue=#queue"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(0, result.getNumberOfErrors());&#010;-&#010;-        // unknown component&#010;-        result = catalog.validateEndpointProperties(""foo:bar?me=you"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getUnknownComponent().equals(""foo""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // invalid boolean but default value&#010;-        result = catalog.validateEndpointProperties(""log:output?showAll=ggg"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""ggg"", result.getInvalidBoolean().get(""showAll""));&#010;-        assertEquals(1, result.getNumberOfErrors());&#010;-&#010;-        // dataset&#010;-        result = catalog.validateEndpointProperties(""dataset:foo?minRate=50"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // time pattern&#010;-        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=true&amp;delay=0&amp;period=2s"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // reference lookup&#010;-        result = catalog.validateEndpointProperties(""timer://foo?fixedRate=#fixed&amp;delay=#myDelay"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // optional consumer. prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?consumer.delay=5000&amp;consumer.greedy=true"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // optional without consumer. prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;greedy=true"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // mixed optional without consumer. prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;consumer.greedy=true"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // prefix&#010;-        result = catalog.validateEndpointProperties(""file:inbox?delay=5000&amp;scheduler.foo=123&amp;scheduler.bar=456"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // stub&#010;-        result = catalog.validateEndpointProperties(""stub:foo?me=123&amp;you=456"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // lenient on&#010;-        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"");&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // lenient off&#010;-        result = catalog.validateEndpointProperties(""dataformat:string:marshal?foo=bar"", true);&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getUnknown().contains(""foo""));&#010;-&#010;-        // data format&#010;-        result = catalog.validateEndpointProperties(""dataformat:string:marshal?charset=utf-8"", true);&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        // incapable to parse&#010;-        result = catalog.validateEndpointProperties(""{{getFtpUrl}}?recursive=true"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertTrue(result.getIncapable() != null);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void validatePropertiesSummary() throws Exception {&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(""yammer:MESSAGES?blah=yada&amp;accessToken=aaa&amp;consumerKey=&amp;useJson=no&amp;initialDelay=five&amp;pollStrategy=myStrategy"");&#010;-        assertFalse(result.isSuccess());&#010;-        String reason = result.summaryErrorMessage(true);&#010;-        LOG.info(reason);&#010;-&#010;-        result = catalog.validateEndpointProperties(""jms:unknown:myqueue"");&#010;-        assertFalse(result.isSuccess());&#010;-        reason = result.summaryErrorMessage(false);&#010;-        LOG.info(reason);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void validateTimePattern() throws Exception {&#010;-        assertTrue(catalog.validateTimePattern(""0""));&#010;-        assertTrue(catalog.validateTimePattern(""500""));&#010;-        assertTrue(catalog.validateTimePattern(""10000""));&#010;-        assertTrue(catalog.validateTimePattern(""5s""));&#010;-        assertTrue(catalog.validateTimePattern(""5sec""));&#010;-        assertTrue(catalog.validateTimePattern(""5secs""));&#010;-        assertTrue(catalog.validateTimePattern(""3m""));&#010;-        assertTrue(catalog.validateTimePattern(""3min""));&#010;-        assertTrue(catalog.validateTimePattern(""3minutes""));&#010;-        assertTrue(catalog.validateTimePattern(""5m15s""));&#010;-        assertTrue(catalog.validateTimePattern(""1h""));&#010;-        assertTrue(catalog.validateTimePattern(""1hour""));&#010;-        assertTrue(catalog.validateTimePattern(""2hours""));&#010;-&#010;-        assertFalse(catalog.validateTimePattern(""bla""));&#010;-        assertFalse(catalog.validateTimePattern(""2year""));&#010;-        assertFalse(catalog.validateTimePattern(""60darn""));&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testEndpointComponentName() throws Exception {&#010;-        String name = catalog.endpointComponentName(""jms:queue:foo"");&#010;-        assertEquals(""jms"", name);&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testSimpleExpression() throws Exception {&#010;-        SimpleValidationResult result = catalog.validateSimpleExpression(null, ""${body}"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body}"", result.getSimple());&#010;-&#010;-        result = catalog.validateSimpleExpression(null, ""${body"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""${body"", result.getSimple());&#010;-        LOG.info(result.getError());&#010;-        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol at location 5""));&#010;-        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;-        assertEquals(5, result.getIndex());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testSimplePredicate() throws Exception {&#010;-        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} == 'abc'"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body} == 'abc'"", result.getSimple());&#010;-&#010;-        result = catalog.validateSimplePredicate(null, ""${body} &gt; ${header.size"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""${body} &gt; ${header.size"", result.getSimple());&#010;-        LOG.info(result.getError());&#010;-        assertTrue(result.getError().startsWith(""expected symbol functionEnd but was eol at location 22""));&#010;-        assertEquals(""expected symbol functionEnd but was eol"", result.getShortError());&#010;-        assertEquals(22, result.getIndex());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testSimplePredicatePlaceholder() throws Exception {&#010;-        SimpleValidationResult result = catalog.validateSimplePredicate(null, ""${body} contains '{{danger}}'"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body} contains '{{danger}}'"", result.getSimple());&#010;-&#010;-        result = catalog.validateSimplePredicate(null, ""${bdy} contains '{{danger}}'"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""${bdy} contains '{{danger}}'"", result.getSimple());&#010;-        LOG.info(result.getError());&#010;-        assertTrue(result.getError().startsWith(""Unknown function: bdy at location 0""));&#010;-        assertTrue(result.getError().contains(""'{{danger}}'""));&#010;-        assertEquals(""Unknown function: bdy"", result.getShortError());&#010;-        assertEquals(0, result.getIndex());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testValidateLanguage() throws Exception {&#010;-        LanguageValidationResult result = catalog.validateLanguageExpression(null, ""simple"", ""${body}"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body}"", result.getText());&#010;-&#010;-        result = catalog.validateLanguageExpression(null, ""header"", ""foo"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""foo"", result.getText());&#010;-&#010;-        result = catalog.validateLanguagePredicate(null, ""simple"", ""${body} &gt; 10"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""${body} &gt; 10"", result.getText());&#010;-&#010;-        result = catalog.validateLanguagePredicate(null, ""header"", ""bar"");&#010;-        assertTrue(result.isSuccess());&#010;-        assertEquals(""bar"", result.getText());&#010;-&#010;-        result = catalog.validateLanguagePredicate(null, ""foobar"", ""bar"");&#010;-        assertFalse(result.isSuccess());&#010;-        assertEquals(""Unknown language foobar"", result.getError());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testValidateEndpointConsumerOnly() throws Exception {&#010;-        String uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true"";&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false, true, false);&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        uri = ""file:inbox?bufferSize=4096&amp;readLock=changed&amp;delete=true&amp;fileExist=Append"";&#010;-        result = catalog.validateEndpointProperties(uri, false, true, false);&#010;-        assertFalse(result.isSuccess());&#010;-&#010;-        assertEquals(""fileExist"", result.getNotConsumerOnly().iterator().next());&#010;-    }&#010;-&#010;-    @Test&#010;-    public void testValidateEndpointProducerOnly() throws Exception {&#010;-        String uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append"";&#010;-        EndpointValidationResult result = catalog.validateEndpointProperties(uri, false, false, true);&#010;-        assertTrue(result.isSuccess());&#010;-&#010;-        uri = ""file:outbox?bufferSize=4096&amp;fileExist=Append&amp;delete=true"";&#010;-        result = catalog.validateEndpointProperties(uri, false, false, true);&#010;-        assertFalse(result.isSuccess());&#010;-&#010;-        assertEquals(""delete"", result.getNotProducerOnly().iterator().next());&#010;-    }&#010;-&#010;-}&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C392ff0b6a5e9466c9cdb499eabbaf550%40git.apache.org%3E,2017-04-14 10:52,commits,6.0,324.0,  [3/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
24,325.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java&#010;new file mode 100644&#010;index 0000000..0420708&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/AbstractCamelCatalog.java&#010;@@ -0,0 +1,1294 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.lang.reflect.InvocationTargetException;&#010;+import java.lang.reflect.Method;&#010;+import java.net.URI;&#010;+import java.net.URISyntaxException;&#010;+import java.util.ArrayList;&#010;+import java.util.Arrays;&#010;+import java.util.HashMap;&#010;+import java.util.Iterator;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.LinkedHashSet;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+import java.util.Objects;&#010;+import java.util.Set;&#010;+import java.util.TreeMap;&#010;+import java.util.regex.Matcher;&#010;+import java.util.regex.Pattern;&#010;+&#010;+import static org.apache.camel.runtimecatalog.CatalogHelper.after;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getNames;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyDefaultValue;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyEnum;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyKind;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyNameFromNameWithPrefix;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getPropertyPrefix;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.getRow;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isComponentConsumerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isComponentLenientProperties;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isComponentProducerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyBoolean;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyConsumerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyInteger;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyMultiValue;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyNumber;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyObject;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyProducerOnly;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.isPropertyRequired;&#010;+import static org.apache.camel.runtimecatalog.JSonSchemaHelper.stripOptionalPrefixFromName;&#010;+import static org.apache.camel.runtimecatalog.URISupport.createQueryString;&#010;+import static org.apache.camel.runtimecatalog.URISupport.isEmpty;&#010;+import static org.apache.camel.runtimecatalog.URISupport.normalizeUri;&#010;+import static org.apache.camel.runtimecatalog.URISupport.stripQuery;&#010;+&#010;+/**&#010;+ * Base class for both the runtime RuntimeCamelCatalog from camel-core and the complete CamelCatalog from camel-catalog.&#010;+ */&#010;+public abstract class AbstractCamelCatalog {&#010;+&#010;+    // CHECKSTYLE:OFF&#010;+&#010;+    private static final Pattern SYNTAX_PATTERN = Pattern.compile(""(\\w+)"");&#010;+&#010;+    private SuggestionStrategy suggestionStrategy;&#010;+    private JSonSchemaResolver jsonSchemaResolver;&#010;+&#010;+    public SuggestionStrategy getSuggestionStrategy() {&#010;+        return suggestionStrategy;&#010;+    }&#010;+&#010;+    public void setSuggestionStrategy(SuggestionStrategy suggestionStrategy) {&#010;+        this.suggestionStrategy = suggestionStrategy;&#010;+    }&#010;+&#010;+    public JSonSchemaResolver getJSonSchemaResolver() {&#010;+        return jsonSchemaResolver;&#010;+    }&#010;+&#010;+    public void setJSonSchemaResolver(JSonSchemaResolver resolver) {&#010;+        this.jsonSchemaResolver = resolver;&#010;+    }&#010;+&#010;+    public boolean validateTimePattern(String pattern) {&#010;+        return validateInteger(pattern);&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateEndpointProperties(String uri) {&#010;+        return validateEndpointProperties(uri, false, false, false);&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties) {&#010;+        return validateEndpointProperties(uri, ignoreLenientProperties, false, false);&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateProperties(String scheme, Map&lt;String, String&gt; properties) {&#010;+        EndpointValidationResult result = new EndpointValidationResult(scheme);&#010;+&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+        List&lt;Map&lt;String, String&gt;&gt; componentProps = JSonSchemaHelper.parseJsonSchema(""componentProperties"", json, true);&#010;+&#010;+        // endpoint options have higher priority so remove those from component&#010;+        // that may clash&#010;+        componentProps.stream()&#010;+            .filter(c -&gt; rows.stream().noneMatch(e -&gt; Objects.equals(e.get(""name""), c.get(""name""))))&#010;+            .forEach(rows::add);&#010;+&#010;+        boolean lenient = Boolean.getBoolean(properties.getOrDefault(""lenient"", ""false""));&#010;+&#010;+        // the dataformat component refers to a data format so lets add the properties for the selected&#010;+        // data format to the list of rows&#010;+        if (""dataformat"".equals(scheme)) {&#010;+            String dfName = properties.get(""name"");&#010;+            if (dfName != null) {&#010;+                String dfJson = jsonSchemaResolver.getDataFormatJSonSchema(dfName);&#010;+                List&lt;Map&lt;String, String&gt;&gt; dfRows = JSonSchemaHelper.parseJsonSchema(""properties"", dfJson, true);&#010;+                if (dfRows != null &amp;&amp; !dfRows.isEmpty()) {&#010;+                    rows.addAll(dfRows);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        for (Map.Entry&lt;String, String&gt; property : properties.entrySet()) {&#010;+            String value = property.getValue();&#010;+            String originalName = property.getKey();&#010;+            String name = property.getKey();&#010;+            // the name may be using an optional prefix, so lets strip that because the options&#010;+            // in the schema are listed without the prefix&#010;+            name = stripOptionalPrefixFromName(rows, name);&#010;+            // the name may be using a prefix, so lets see if we can find the real property name&#010;+            String propertyName = getPropertyNameFromNameWithPrefix(rows, name);&#010;+            if (propertyName != null) {&#010;+                name = propertyName;&#010;+            }&#010;+&#010;+            String prefix = getPropertyPrefix(rows, name);&#010;+            String kind = getPropertyKind(rows, name);&#010;+            boolean namePlaceholder = name.startsWith(""{{"") &amp;&amp; name.endsWith(""}}"");&#010;+            boolean valuePlaceholder = value.startsWith(""{{"") || value.startsWith(""${"") || value.startsWith(""$simple{"");&#010;+            boolean lookup = value.startsWith(""#"") &amp;&amp; value.length() &gt; 1;&#010;+            // we cannot evaluate multi values as strict as the others, as we don't know their expected types&#010;+            boolean multiValue = prefix != null &amp;&amp; originalName.startsWith(prefix) &amp;&amp; isPropertyMultiValue(rows, name);&#010;+&#010;+            Map&lt;String, String&gt; row = getRow(rows, name);&#010;+            if (row == null) {&#010;+                // unknown option&#010;+&#010;+                // only add as error if the component is not lenient properties, or not stub component&#010;+                // and the name is not a property placeholder for one or more values&#010;+                if (!namePlaceholder &amp;&amp; !""stub"".equals(scheme)) {&#010;+                    if (lenient) {&#010;+                        // as if we are lenient then the option is a dynamic extra option which we cannot validate&#010;+                        result.addLenient(name);&#010;+                    } else {&#010;+                        // its unknown&#010;+                        result.addUnknown(name);&#010;+                        if (suggestionStrategy != null) {&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(getNames(rows), name);&#010;+                            if (suggestions != null) {&#010;+                                result.addUnknownSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+                    }&#010;+                }&#010;+            } else {&#010;+                /* TODO: we may need to add something in the properties to know if they are related to a producer or consumer&#010;+                if (""parameter"".equals(kind)) {&#010;+                    // consumer only or producer only mode for parameters&#010;+                    if (consumerOnly) {&#010;+                        boolean producer = isPropertyProducerOnly(rows, name);&#010;+                        if (producer) {&#010;+                            // the option is only for producer so you cannot use it in consumer mode&#010;+                            result.addNotConsumerOnly(name);&#010;+                        }&#010;+                    } else if (producerOnly) {&#010;+                        boolean consumer = isPropertyConsumerOnly(rows, name);&#010;+                        if (consumer) {&#010;+                            // the option is only for consumer so you cannot use it in producer mode&#010;+                            result.addNotProducerOnly(name);&#010;+                        }&#010;+                    }&#010;+                }&#010;+                */&#010;+&#010;+                // default value&#010;+                String defaultValue = getPropertyDefaultValue(rows, name);&#010;+                if (defaultValue != null) {&#010;+                    result.addDefaultValue(name, defaultValue);&#010;+                }&#010;+&#010;+                // is required but the value is empty&#010;+                boolean required = isPropertyRequired(rows, name);&#010;+                if (required &amp;&amp; isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+&#010;+                // is enum but the value is not within the enum range&#010;+                // but we can only check if the value is not a placeholder&#010;+                String enums = getPropertyEnum(rows, name);&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; enums != null) {&#010;+                    String[] choices = enums.split("","");&#010;+                    boolean found = false;&#010;+                    for (String s : choices) {&#010;+                        if (value.equalsIgnoreCase(s)) {&#010;+                            found = true;&#010;+                            break;&#010;+                        }&#010;+                    }&#010;+                    if (!found) {&#010;+                        result.addInvalidEnum(name, value);&#010;+                        result.addInvalidEnumChoices(name, choices);&#010;+                        if (suggestionStrategy != null) {&#010;+                            Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;();&#010;+                            names.addAll(Arrays.asList(choices));&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(names, value);&#010;+                            if (suggestions != null) {&#010;+                                result.addInvalidEnumSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+&#010;+                    }&#010;+                }&#010;+&#010;+                // is reference lookup of bean (not applicable for @UriPath, enums, or multi-valued)&#010;+                if (!multiValue &amp;&amp; enums == null &amp;&amp; !""path"".equals(kind) &amp;&amp; isPropertyObject(rows, name)) {&#010;+                    // must start with # and be at least 2 characters&#010;+                    if (!value.startsWith(""#"") || value.length() &lt;= 1) {&#010;+                        result.addInvalidReference(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is boolean&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyBoolean(rows, name)) {&#010;+                    // value must be a boolean&#010;+                    boolean bool = ""true"".equalsIgnoreCase(value) || ""false"".equalsIgnoreCase(value);&#010;+                    if (!bool) {&#010;+                        result.addInvalidBoolean(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is integer&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyInteger(rows, name)) {&#010;+                    // value must be an integer&#010;+                    boolean valid = validateInteger(value);&#010;+                    if (!valid) {&#010;+                        result.addInvalidInteger(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is number&#010;+                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyNumber(rows, name)) {&#010;+                    // value must be an number&#010;+                    boolean valid = false;&#010;+                    try {&#010;+                        valid = !Double.valueOf(value).isNaN() || !Float.valueOf(value).isNaN();&#010;+                    } catch (Exception e) {&#010;+                        // ignore&#010;+                    }&#010;+                    if (!valid) {&#010;+                        result.addInvalidNumber(name, value);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // now check if all required values are there, and that a default value does not exists&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String name = row.get(""name"");&#010;+            boolean required = isPropertyRequired(rows, name);&#010;+            if (required) {&#010;+                String value = properties.get(name);&#010;+                if (isEmpty(value)) {&#010;+                    value = getPropertyDefaultValue(rows, name);&#010;+                }&#010;+                if (isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        return result;&#010;+    }&#010;+&#010;+    public EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties, boolean consumerOnly, boolean producerOnly) {&#010;+        EndpointValidationResult result = new EndpointValidationResult(uri);&#010;+&#010;+        Map&lt;String, String&gt; properties;&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows;&#010;+        boolean lenientProperties;&#010;+        String scheme;&#010;+&#010;+        try {&#010;+            String json = null;&#010;+&#010;+            // parse the uri&#010;+            URI u = normalizeUri(uri);&#010;+            scheme = u.getScheme();&#010;+&#010;+            if (scheme != null) {&#010;+                json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+            }&#010;+            if (json == null) {&#010;+                // if the uri starts with a placeholder then we are also incapable of parsing it as we wasn't able to resolve the component name&#010;+                if (uri.startsWith(""{{"")) {&#010;+                    result.addIncapable(uri);&#010;+                } else if (scheme != null) {&#010;+                    result.addUnknownComponent(scheme);&#010;+                } else {&#010;+                    result.addUnknownComponent(uri);&#010;+                }&#010;+                return result;&#010;+            }&#010;+&#010;+            rows = JSonSchemaHelper.parseJsonSchema(""component"", json, false);&#010;+&#010;+            // is the component capable of both consumer and producer?&#010;+            boolean canConsumeAndProduce = false;&#010;+            if (!isComponentConsumerOnly(rows) &amp;&amp; !isComponentProducerOnly(rows)) {&#010;+                canConsumeAndProduce = true;&#010;+            }&#010;+&#010;+            if (canConsumeAndProduce &amp;&amp; consumerOnly) {&#010;+                // lenient properties is not support in consumer only mode if the component can do both of them&#010;+                lenientProperties = false;&#010;+            } else {&#010;+                // only enable lenient properties if we should not ignore&#010;+                lenientProperties = !ignoreLenientProperties &amp;&amp; isComponentLenientProperties(rows);&#010;+            }&#010;+            rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+            properties = endpointProperties(uri);&#010;+        } catch (URISyntaxException e) {&#010;+            if (uri.startsWith(""{{"")) {&#010;+                // if the uri starts with a placeholder then we are also incapable of parsing it as we wasn't able to resolve the component name&#010;+                result.addIncapable(uri);&#010;+            } else {&#010;+                result.addSyntaxError(e.getMessage());&#010;+            }&#010;+&#010;+            return result;&#010;+        }&#010;+&#010;+        // the dataformat component refers to a data format so lets add the properties for the selected&#010;+        // data format to the list of rows&#010;+        if (""dataformat"".equals(scheme)) {&#010;+            String dfName = properties.get(""name"");&#010;+            if (dfName != null) {&#010;+                String dfJson = jsonSchemaResolver.getDataFormatJSonSchema(dfName);&#010;+                List&lt;Map&lt;String, String&gt;&gt; dfRows = JSonSchemaHelper.parseJsonSchema(""properties"", dfJson, true);&#010;+                if (dfRows != null &amp;&amp; !dfRows.isEmpty()) {&#010;+                    rows.addAll(dfRows);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        for (Map.Entry&lt;String, String&gt; property : properties.entrySet()) {&#010;+            String value = property.getValue();&#010;+            String originalName = property.getKey();&#010;+            String name = property.getKey();&#010;+            // the name may be using an optional prefix, so lets strip that because the options&#010;+            // in the schema are listed without the prefix&#010;+            name = stripOptionalPrefixFromName(rows, name);&#010;+            // the name may be using a prefix, so lets see if we can find the real property name&#010;+            String propertyName = getPropertyNameFromNameWithPrefix(rows, name);&#010;+            if (propertyName != null) {&#010;+                name = propertyName;&#010;+            }&#010;+&#010;+            String prefix = getPropertyPrefix(rows, name);&#010;+            String kind = getPropertyKind(rows, name);&#010;+            boolean namePlaceholder = name.startsWith(""{{"") &amp;&amp; name.endsWith(""}}"");&#010;+            boolean valuePlaceholder = value.startsWith(""{{"") || value.startsWith(""${"") || value.startsWith(""$simple{"");&#010;+            boolean lookup = value.startsWith(""#"") &amp;&amp; value.length() &gt; 1;&#010;+            // we cannot evaluate multi values as strict as the others, as we don't know their expected types&#010;+            boolean mulitValue = prefix != null &amp;&amp; originalName.startsWith(prefix) &amp;&amp; isPropertyMultiValue(rows, name);&#010;+&#010;+            Map&lt;String, String&gt; row = getRow(rows, name);&#010;+            if (row == null) {&#010;+                // unknown option&#010;+&#010;+                // only add as error if the component is not lenient properties, or not stub component&#010;+                // and the name is not a property placeholder for one or more values&#010;+                if (!namePlaceholder &amp;&amp; !""stub"".equals(scheme)) {&#010;+                    if (lenientProperties) {&#010;+                        // as if we are lenient then the option is a dynamic extra option which we cannot validate&#010;+                        result.addLenient(name);&#010;+                    } else {&#010;+                        // its unknown&#010;+                        result.addUnknown(name);&#010;+                        if (suggestionStrategy != null) {&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(getNames(rows), name);&#010;+                            if (suggestions != null) {&#010;+                                result.addUnknownSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+                    }&#010;+                }&#010;+            } else {&#010;+                if (""parameter"".equals(kind)) {&#010;+                    // consumer only or producer only mode for parameters&#010;+                    if (consumerOnly) {&#010;+                        boolean producer = isPropertyProducerOnly(rows, name);&#010;+                        if (producer) {&#010;+                            // the option is only for producer so you cannot use it in consumer mode&#010;+                            result.addNotConsumerOnly(name);&#010;+                        }&#010;+                    } else if (producerOnly) {&#010;+                        boolean consumer = isPropertyConsumerOnly(rows, name);&#010;+                        if (consumer) {&#010;+                            // the option is only for consumer so you cannot use it in producer mode&#010;+                            result.addNotProducerOnly(name);&#010;+                        }&#010;+                    }&#010;+                }&#010;+&#010;+                // default value&#010;+                String defaultValue = getPropertyDefaultValue(rows, name);&#010;+                if (defaultValue != null) {&#010;+                    result.addDefaultValue(name, defaultValue);&#010;+                }&#010;+&#010;+                // is required but the value is empty&#010;+                boolean required = isPropertyRequired(rows, name);&#010;+                if (required &amp;&amp; isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+&#010;+                // is enum but the value is not within the enum range&#010;+                // but we can only check if the value is not a placeholder&#010;+                String enums = getPropertyEnum(rows, name);&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; enums != null) {&#010;+                    String[] choices = enums.split("","");&#010;+                    boolean found = false;&#010;+                    for (String s : choices) {&#010;+                        if (value.equalsIgnoreCase(s)) {&#010;+                            found = true;&#010;+                            break;&#010;+                        }&#010;+                    }&#010;+                    if (!found) {&#010;+                        result.addInvalidEnum(name, value);&#010;+                        result.addInvalidEnumChoices(name, choices);&#010;+                        if (suggestionStrategy != null) {&#010;+                            Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;();&#010;+                            names.addAll(Arrays.asList(choices));&#010;+                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(names, value);&#010;+                            if (suggestions != null) {&#010;+                                result.addInvalidEnumSuggestions(name, suggestions);&#010;+                            }&#010;+                        }&#010;+&#010;+                    }&#010;+                }&#010;+&#010;+                // is reference lookup of bean (not applicable for @UriPath, enums, or multi-valued)&#010;+                if (!mulitValue &amp;&amp; enums == null &amp;&amp; !""path"".equals(kind) &amp;&amp; isPropertyObject(rows, name)) {&#010;+                    // must start with # and be at least 2 characters&#010;+                    if (!value.startsWith(""#"") || value.length() &lt;= 1) {&#010;+                        result.addInvalidReference(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is boolean&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyBoolean(rows, name)) {&#010;+                    // value must be a boolean&#010;+                    boolean bool = ""true"".equalsIgnoreCase(value) || ""false"".equalsIgnoreCase(value);&#010;+                    if (!bool) {&#010;+                        result.addInvalidBoolean(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is integer&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyInteger(rows, name)) {&#010;+                    // value must be an integer&#010;+                    boolean valid = validateInteger(value);&#010;+                    if (!valid) {&#010;+                        result.addInvalidInteger(name, value);&#010;+                    }&#010;+                }&#010;+&#010;+                // is number&#010;+                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyNumber(rows, name)) {&#010;+                    // value must be an number&#010;+                    boolean valid = false;&#010;+                    try {&#010;+                        valid = !Double.valueOf(value).isNaN() || !Float.valueOf(value).isNaN();&#010;+                    } catch (Exception e) {&#010;+                        // ignore&#010;+                    }&#010;+                    if (!valid) {&#010;+                        result.addInvalidNumber(name, value);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // now check if all required values are there, and that a default value does not exists&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String name = row.get(""name"");&#010;+            boolean required = isPropertyRequired(rows, name);&#010;+            if (required) {&#010;+                String value = properties.get(name);&#010;+                if (isEmpty(value)) {&#010;+                    value = getPropertyDefaultValue(rows, name);&#010;+                }&#010;+                if (isEmpty(value)) {&#010;+                    result.addRequired(name);&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        return result;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; endpointProperties(String uri) throws URISyntaxException {&#010;+        // need to normalize uri first&#010;+        URI u = normalizeUri(uri);&#010;+        String scheme = u.getScheme();&#010;+&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        if (json == null) {&#010;+            throw new IllegalArgumentException(""Cannot find endpoint with scheme "" + scheme);&#010;+        }&#010;+&#010;+        // grab the syntax&#010;+        String syntax = null;&#010;+        String alternativeSyntax = null;&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""component"", json, false);&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""syntax"")) {&#010;+                syntax = row.get(""syntax"");&#010;+            }&#010;+            if (row.containsKey(""alternativeSyntax"")) {&#010;+                alternativeSyntax = row.get(""alternativeSyntax"");&#010;+            }&#010;+        }&#010;+        if (syntax == null) {&#010;+            throw new IllegalArgumentException(""Endpoint with scheme "" + scheme + "" has no syntax defined in the json schema"");&#010;+        }&#010;+&#010;+        // only if we support alternative syntax, and the uri contains the username and password in the authority&#010;+        // part of the uri, then we would need some special logic to capture that information and strip those&#010;+        // details from the uri, so we can continue parsing the uri using the normal syntax&#010;+        Map&lt;String, String&gt; userInfoOptions = new LinkedHashMap&lt;String, String&gt;();&#010;+        if (alternativeSyntax != null &amp;&amp; alternativeSyntax.contains(""@"")) {&#010;+            // clip the scheme from the syntax&#010;+            alternativeSyntax = after(alternativeSyntax, "":"");&#010;+            // trim so only userinfo&#010;+            int idx = alternativeSyntax.indexOf(""@"");&#010;+            String fields = alternativeSyntax.substring(0, idx);&#010;+            String[] names = fields.split("":"");&#010;+&#010;+            // grab authority part and grab username and/or password&#010;+            String authority = u.getAuthority();&#010;+            if (authority != null &amp;&amp; authority.contains(""@"")) {&#010;+                String username = null;&#010;+                String password = null;&#010;+&#010;+                // grab unserinfo part before @&#010;+                String userInfo = authority.substring(0, authority.indexOf(""@""));&#010;+                String[] parts = userInfo.split("":"");&#010;+                if (parts.length == 2) {&#010;+                    username = parts[0];&#010;+                    password = parts[1];&#010;+                } else {&#010;+                    // only username&#010;+                    username = userInfo;&#010;+                }&#010;+&#010;+                // remember the username and/or password which we add later to the options&#010;+                if (names.length == 2) {&#010;+                    userInfoOptions.put(names[0], username);&#010;+                    if (password != null) {&#010;+                        // password is optional&#010;+                        userInfoOptions.put(names[1], password);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // clip the scheme from the syntax&#010;+        syntax = after(syntax, "":"");&#010;+        // clip the scheme from the uri&#010;+        uri = after(uri, "":"");&#010;+        String uriPath = stripQuery(uri);&#010;+&#010;+        // strip user info from uri path&#010;+        if (!userInfoOptions.isEmpty()) {&#010;+            int idx = uriPath.indexOf('@');&#010;+            if (idx &gt; -1) {&#010;+                uriPath = uriPath.substring(idx + 1);&#010;+            }&#010;+        }&#010;+&#010;+        // strip double slash in the start&#010;+        if (uriPath != null &amp;&amp; uriPath.startsWith(""//"")) {&#010;+            uriPath = uriPath.substring(2);&#010;+        }&#010;+&#010;+        // parse the syntax and find the names of each option&#010;+        Matcher matcher = SYNTAX_PATTERN.matcher(syntax);&#010;+        List&lt;String&gt; word = new ArrayList&lt;String&gt;();&#010;+        while (matcher.find()) {&#010;+            String s = matcher.group(1);&#010;+            if (!scheme.equals(s)) {&#010;+                word.add(s);&#010;+            }&#010;+        }&#010;+        // parse the syntax and find each token between each option&#010;+        String[] tokens = SYNTAX_PATTERN.split(syntax);&#010;+&#010;+        // find the position where each option start/end&#010;+        List&lt;String&gt; word2 = new ArrayList&lt;String&gt;();&#010;+        int prev = 0;&#010;+        int prevPath = 0;&#010;+&#010;+        // special for activemq/jms where the enum for destinationType causes a token issue as it includes a colon&#010;+        // for 'temp:queue' and 'temp:topic' values&#010;+        if (""activemq"".equals(scheme) || ""jms"".equals(scheme)) {&#010;+            if (uriPath.startsWith(""temp:"")) {&#010;+                prevPath = 5;&#010;+            }&#010;+        }&#010;+&#010;+        for (String token : tokens) {&#010;+            if (token.isEmpty()) {&#010;+                continue;&#010;+            }&#010;+&#010;+            // special for some tokens where :// can be used also, eg http://foo&#010;+            int idx = -1;&#010;+            int len = 0;&#010;+            if ("":"".equals(token)) {&#010;+                idx = uriPath.indexOf(""://"", prevPath);&#010;+                len = 3;&#010;+            }&#010;+            if (idx == -1) {&#010;+                idx = uriPath.indexOf(token, prevPath);&#010;+                len = token.length();&#010;+            }&#010;+&#010;+            if (idx &gt; 0) {&#010;+                String option = uriPath.substring(prev, idx);&#010;+                word2.add(option);&#010;+                prev = idx + len;&#010;+                prevPath = prev;&#010;+            }&#010;+        }&#010;+        // special for last or if we did not add anyone&#010;+        if (prev &gt; 0 || word2.isEmpty()) {&#010;+            String option = uriPath.substring(prev);&#010;+            word2.add(option);&#010;+        }&#010;+&#010;+        rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        boolean defaultValueAdded = false;&#010;+&#010;+        // now parse the uri to know which part isw what&#010;+        Map&lt;String, String&gt; options = new LinkedHashMap&lt;String, String&gt;();&#010;+&#010;+        // include the username and password from the userinfo section&#010;+        if (!userInfoOptions.isEmpty()) {&#010;+            options.putAll(userInfoOptions);&#010;+        }&#010;+&#010;+        // word contains the syntax path elements&#010;+        Iterator&lt;String&gt; it = word2.iterator();&#010;+        for (int i = 0; i &lt; word.size(); i++) {&#010;+            String key = word.get(i);&#010;+&#010;+            boolean allOptions = word.size() == word2.size();&#010;+            boolean required = isPropertyRequired(rows, key);&#010;+            String defaultValue = getPropertyDefaultValue(rows, key);&#010;+&#010;+            // we have all options so no problem&#010;+            if (allOptions) {&#010;+                String value = it.next();&#010;+                options.put(key, value);&#010;+            } else {&#010;+                // we have a little problem as we do not not have all options&#010;+                if (!required) {&#010;+                    String value = null;&#010;+&#010;+                    boolean last = i == word.size() - 1;&#010;+                    if (last) {&#010;+                        // if its the last value then use it instead of the default value&#010;+                        value = it.hasNext() ? it.next() : null;&#010;+                        if (value != null) {&#010;+                            options.put(key, value);&#010;+                        } else {&#010;+                            value = defaultValue;&#010;+                        }&#010;+                    }&#010;+                    if (value != null) {&#010;+                        options.put(key, value);&#010;+                        defaultValueAdded = true;&#010;+                    }&#010;+                } else {&#010;+                    String value = it.hasNext() ? it.next() : null;&#010;+                    if (value != null) {&#010;+                        options.put(key, value);&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        Map&lt;String, String&gt; answer = new LinkedHashMap&lt;String, String&gt;();&#010;+&#010;+        // remove all options which are using default values and are not required&#010;+        for (Map.Entry&lt;String, String&gt; entry : options.entrySet()) {&#010;+            String key = entry.getKey();&#010;+            String value = entry.getValue();&#010;+&#010;+            if (defaultValueAdded) {&#010;+                boolean required = isPropertyRequired(rows, key);&#010;+                String defaultValue = getPropertyDefaultValue(rows, key);&#010;+&#010;+                if (!required &amp;&amp; defaultValue != null) {&#010;+                    if (defaultValue.equals(value)) {&#010;+                        continue;&#010;+                    }&#010;+                }&#010;+            }&#010;+&#010;+            // we should keep this in the answer&#010;+            answer.put(key, value);&#010;+        }&#010;+&#010;+        // now parse the uri parameters&#010;+        Map&lt;String, Object&gt; parameters = URISupport.parseParameters(u);&#010;+&#010;+        // and covert the values to String so its JMX friendly&#010;+        while (!parameters.isEmpty()) {&#010;+            Map.Entry&lt;String, Object&gt; entry = parameters.entrySet().iterator().next();&#010;+            String key = entry.getKey();&#010;+            String value = entry.getValue() != null ? entry.getValue().toString() : """";&#010;+&#010;+            boolean multiValued = isPropertyMultiValue(rows, key);&#010;+            if (multiValued) {&#010;+                String prefix = getPropertyPrefix(rows, key);&#010;+                // extra all the multi valued options&#010;+                Map&lt;String, Object&gt; values = URISupport.extractProperties(parameters, prefix);&#010;+                // build a string with the extra multi valued options with the prefix and &amp; as separator&#010;+                CollectionStringBuffer csb = new CollectionStringBuffer(""&amp;"");&#010;+                for (Map.Entry&lt;String, Object&gt; multi : values.entrySet()) {&#010;+                    String line = prefix + multi.getKey() + ""="" + (multi.getValue() != null ? multi.getValue().toString() : """");&#010;+                    csb.append(line);&#010;+                }&#010;+                // append the extra multi-values to the existing (which contains the first multi value)&#010;+                if (!csb.isEmpty()) {&#010;+                    value = value + ""&amp;"" + csb.toString();&#010;+                }&#010;+            }&#010;+&#010;+            answer.put(key, value);&#010;+            // remove the parameter as we run in a while loop until no more parameters&#010;+            parameters.remove(key);&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; endpointLenientProperties(String uri) throws URISyntaxException {&#010;+        // need to normalize uri first&#010;+&#010;+        // parse the uri&#010;+        URI u = normalizeUri(uri);&#010;+        String scheme = u.getScheme();&#010;+&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        if (json == null) {&#010;+            throw new IllegalArgumentException(""Cannot find endpoint with scheme "" + scheme);&#010;+        }&#010;+&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        // now parse the uri parameters&#010;+        Map&lt;String, Object&gt; parameters = URISupport.parseParameters(u);&#010;+&#010;+        // all the known options&#010;+        Set&lt;String&gt; names = getNames(rows);&#010;+&#010;+        Map&lt;String, String&gt; answer = new LinkedHashMap&lt;&gt;();&#010;+&#010;+        // and covert the values to String so its JMX friendly&#010;+        parameters.forEach((k, v) -&gt; {&#010;+            String key = k;&#010;+            String value = v != null ? v.toString() : """";&#010;+&#010;+            // is the key a prefix property&#010;+            int dot = key.indexOf('.');&#010;+            if (dot != -1) {&#010;+                String prefix = key.substring(0, dot + 1); // include dot in prefix&#010;+                String option = getPropertyNameFromNameWithPrefix(rows, prefix);&#010;+                if (option == null || !isPropertyMultiValue(rows, option)) {&#010;+                    answer.put(key, value);&#010;+                }&#010;+            } else if (!names.contains(key)) {&#010;+                answer.put(key, value);&#010;+            }&#010;+        });&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    public String endpointComponentName(String uri) {&#010;+        if (uri != null) {&#010;+            int idx = uri.indexOf("":"");&#010;+            if (idx &gt; 0) {&#010;+                return uri.substring(0, idx);&#010;+            }&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    public String asEndpointUri(String scheme, String json, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, json, ""&amp;"", encode);&#010;+    }&#010;+&#010;+    public String asEndpointUriXml(String scheme, String json, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, json, ""&amp;amp;"", encode);&#010;+    }&#010;+&#010;+    private String doAsEndpointUri(String scheme, String json, String ampersand, boolean encode) throws URISyntaxException {&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        Map&lt;String, String&gt; copy = new HashMap&lt;String, String&gt;();&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            String name = row.get(""name"");&#010;+            String required = row.get(""required"");&#010;+            String value = row.get(""value"");&#010;+            String defaultValue = row.get(""defaultValue"");&#010;+&#010;+            // only add if either required, or the value is != default value&#010;+            String valueToAdd = null;&#010;+            if (""true"".equals(required)) {&#010;+                valueToAdd = value != null ? value : defaultValue;&#010;+                if (valueToAdd == null) {&#010;+                    valueToAdd = """";&#010;+                }&#010;+            } else {&#010;+                // if we have a value and no default then add it&#010;+                if (value != null &amp;&amp; defaultValue == null) {&#010;+                    valueToAdd = value;&#010;+                }&#010;+                // otherwise only add if the value is != default value&#010;+                if (value != null &amp;&amp; defaultValue != null &amp;&amp; !value.equals(defaultValue)) {&#010;+                    valueToAdd = value;&#010;+                }&#010;+            }&#010;+&#010;+            if (valueToAdd != null) {&#010;+                copy.put(name, valueToAdd);&#010;+            }&#010;+        }&#010;+&#010;+        return doAsEndpointUri(scheme, copy, ampersand, encode);&#010;+    }&#010;+&#010;+    public String asEndpointUri(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, properties, ""&amp;"", encode);&#010;+    }&#010;+&#010;+    public String asEndpointUriXml(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException {&#010;+        return doAsEndpointUri(scheme, properties, ""&amp;amp;"", encode);&#010;+    }&#010;+&#010;+    String doAsEndpointUri(String scheme, Map&lt;String, String&gt; properties, String ampersand, boolean encode) throws URISyntaxException {&#010;+        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;+        if (json == null) {&#010;+            throw new IllegalArgumentException(""Cannot find endpoint with scheme "" + scheme);&#010;+        }&#010;+&#010;+        // grab the syntax&#010;+        String syntax = null;&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""component"", json, false);&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""syntax"")) {&#010;+                syntax = row.get(""syntax"");&#010;+                break;&#010;+            }&#010;+        }&#010;+        if (syntax == null) {&#010;+            throw new IllegalArgumentException(""Endpoint with scheme "" + scheme + "" has no syntax defined in the json schema"");&#010;+        }&#010;+&#010;+        // do any properties filtering which can be needed for some special components&#010;+        properties = filterProperties(scheme, properties);&#010;+&#010;+        rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;+&#010;+        // clip the scheme from the syntax&#010;+        syntax = after(syntax, "":"");&#010;+&#010;+        String originalSyntax = syntax;&#010;+&#010;+        // build at first according to syntax (use a tree map as we want the uri options sorted)&#010;+        Map&lt;String, String&gt; copy = new TreeMap&lt;String, String&gt;();&#010;+        for (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) {&#010;+            String key = entry.getKey();&#010;+            String value = entry.getValue() != null ? entry.getValue() : """";&#010;+            if (syntax != null &amp;&amp; syntax.contains(key)) {&#010;+                syntax = syntax.replace(key, value);&#010;+            } else {&#010;+                copy.put(key, value);&#010;+            }&#010;+        }&#010;+&#010;+        // do we have all the options the original syntax needs (easy way)&#010;+        String[] keys = syntaxKeys(originalSyntax);&#010;+        boolean hasAllKeys = properties.keySet().containsAll(Arrays.asList(keys));&#010;+&#010;+        // build endpoint uri&#010;+        StringBuilder sb = new StringBuilder();&#010;+        sb.append(scheme);&#010;+        sb.append("":"");&#010;+&#010;+        if (hasAllKeys) {&#010;+            // we have all the keys for the syntax so we can build the uri the easy way&#010;+            sb.append(syntax);&#010;+&#010;+            if (!copy.isEmpty()) {&#010;+                boolean hasQuestionmark = sb.toString().contains(""?"");&#010;+                // the last option may already contain a ? char, if so we should use &amp; instead of ?&#010;+                sb.append(hasQuestionmark ? ampersand : '?');&#010;+                String query = createQueryString(copy, ampersand, encode);&#010;+                sb.append(query);&#010;+            }&#010;+        } else {&#010;+            // TODO: revisit this and see if we can do this in another way&#010;+            // oh darn some options is missing, so we need a complex way of building the uri&#010;+&#010;+            // the tokens between the options in the path&#010;+            String[] tokens = syntax.split(""\\w+"");&#010;+&#010;+            // parse the syntax into each options&#010;+            Matcher matcher = SYNTAX_PATTERN.matcher(originalSyntax);&#010;+            List&lt;String&gt; options = new ArrayList&lt;String&gt;();&#010;+            while (matcher.find()) {&#010;+                String s = matcher.group(1);&#010;+                options.add(s);&#010;+            }&#010;+&#010;+            // need to preserve {{ and }} from the syntax&#010;+            // (we need to use words only as its provisional placeholders)&#010;+            syntax = syntax.replaceAll(""\\{\\{"", ""BEGINCAMELPLACEHOLDER"");&#010;+            syntax = syntax.replaceAll(""\\}\\}"", ""ENDCAMELPLACEHOLDER"");&#010;+&#010;+            // parse the syntax into each options&#010;+            Matcher matcher2 = SYNTAX_PATTERN.matcher(syntax);&#010;+            List&lt;String&gt; options2 = new ArrayList&lt;String&gt;();&#010;+            while (matcher2.find()) {&#010;+                String s = matcher2.group(1);&#010;+                s = s.replaceAll(""BEGINCAMELPLACEHOLDER"", ""\\{\\{"");&#010;+                s = s.replaceAll(""ENDCAMELPLACEHOLDER"", ""\\}\\}"");&#010;+                options2.add(s);&#010;+            }&#010;+&#010;+            // build the endpoint&#010;+            int range = 0;&#010;+            boolean first = true;&#010;+            boolean hasQuestionmark = false;&#010;+            for (int i = 0; i &lt; options.size(); i++) {&#010;+                String key = options.get(i);&#010;+                String key2 = options2.get(i);&#010;+                String token = null;&#010;+                if (tokens.length &gt; i) {&#010;+                    token = tokens[i];&#010;+                }&#010;+&#010;+                boolean contains = properties.containsKey(key);&#010;+                if (!contains) {&#010;+                    // if the key are similar we have no explicit value and can try to find a default value if the option is required&#010;+                    if (isPropertyRequired(rows, key)) {&#010;+                        String value = getPropertyDefaultValue(rows, key);&#010;+                        if (value != null) {&#010;+                            properties.put(key, value);&#010;+                            key2 = value;&#010;+                        }&#010;+                    }&#010;+                }&#010;+&#010;+                // was the option provided?&#010;+                if (properties.containsKey(key)) {&#010;+                    if (!first &amp;&amp; token != null) {&#010;+                        sb.append(token);&#010;+                    }&#010;+                    hasQuestionmark |= key.contains(""?"") || (token != null &amp;&amp; token.contains(""?""));&#010;+                    sb.append(key2);&#010;+                    first = false;&#010;+                }&#010;+                range++;&#010;+            }&#010;+            // append any extra options that was in surplus for the last&#010;+            while (range &lt; options2.size()) {&#010;+                String token = null;&#010;+                if (tokens.length &gt; range) {&#010;+                    token = tokens[range];&#010;+                }&#010;+                String key2 = options2.get(range);&#010;+                sb.append(token);&#010;+                sb.append(key2);&#010;+                hasQuestionmark |= key2.contains(""?"") || (token != null &amp;&amp; token.contains(""?""));&#010;+                range++;&#010;+            }&#010;+&#010;+&#010;+            if (!copy.isEmpty()) {&#010;+                // the last option may already contain a ? char, if so we should use &amp; instead of ?&#010;+                sb.append(hasQuestionmark ? ampersand : '?');&#010;+                String query = createQueryString(copy, ampersand, encode);&#010;+                sb.append(query);&#010;+            }&#010;+        }&#010;+&#010;+        return sb.toString();&#010;+    }&#010;+&#010;+    @Deprecated&#010;+    private static String[] syntaxTokens(String syntax) {&#010;+        // build tokens between the words&#010;+        List&lt;String&gt; tokens = new ArrayList&lt;&gt;();&#010;+        // preserve backwards behavior which had an empty token first&#010;+        tokens.add("""");&#010;+&#010;+        String current = """";&#010;+        for (int i = 0; i &lt; syntax.length(); i++) {&#010;+            char ch = syntax.charAt(i);&#010;+            if (Character.isLetterOrDigit(ch)) {&#010;+                // reset for new current tokens&#010;+                if (current.length() &gt; 0) {&#010;+                    tokens.add(current);&#010;+                    current = """";&#010;+                }&#010;+            } else {&#010;+                current += ch;&#010;+            }&#010;+        }&#010;+        // anything left over?&#010;+        if (current.length() &gt; 0) {&#010;+            tokens.add(current);&#010;+        }&#010;+&#010;+        return tokens.toArray(new String[tokens.size()]);&#010;+    }&#010;+&#010;+    private static String[] syntaxKeys(String syntax) {&#010;+        // build tokens between the separators&#010;+        List&lt;String&gt; tokens = new ArrayList&lt;&gt;();&#010;+&#010;+        String current = """";&#010;+        for (int i = 0; i &lt; syntax.length(); i++) {&#010;+            char ch = syntax.charAt(i);&#010;+            if (Character.isLetterOrDigit(ch)) {&#010;+                current += ch;&#010;+            } else {&#010;+                // reset for new current tokens&#010;+                if (current.length() &gt; 0) {&#010;+                    tokens.add(current);&#010;+                    current = """";&#010;+                }&#010;+            }&#010;+        }&#010;+        // anything left over?&#010;+        if (current.length() &gt; 0) {&#010;+            tokens.add(current);&#010;+        }&#010;+&#010;+        return tokens.toArray(new String[tokens.size()]);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimpleExpression(String simple) {&#010;+        return doValidateSimple(null, simple, false);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimpleExpression(ClassLoader classLoader, String simple) {&#010;+        return doValidateSimple(classLoader, simple, false);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimplePredicate(String simple) {&#010;+        return doValidateSimple(null, simple, true);&#010;+    }&#010;+&#010;+    public SimpleValidationResult validateSimplePredicate(ClassLoader classLoader, String simple) {&#010;+        return doValidateSimple(classLoader, simple, true);&#010;+    }&#010;+&#010;+    private SimpleValidationResult doValidateSimple(ClassLoader classLoader, String simple, boolean predicate) {&#010;+        if (classLoader == null) {&#010;+            classLoader = getClass().getClassLoader();&#010;+        }&#010;+&#010;+        // if there are {{ }}} property placeholders then we need to resolve them to something else&#010;+        // as the simple parse cannot resolve them before parsing as we dont run the actual Camel application&#010;+        // with property placeholders setup so we need to dummy this by replace the {{ }} to something else&#010;+        // therefore we use an more unlikely character: {{XXX}} to ~^XXX^~&#010;+        String resolved = simple.replaceAll(""\\{\\{(.+)\\}\\}"", ""~^$1^~"");&#010;+&#010;+        SimpleValidationResult answer = new SimpleValidationResult(simple);&#010;+&#010;+        Object instance = null;&#010;+        Class clazz = null;&#010;+        try {&#010;+            clazz = classLoader.loadClass(""org.apache.camel.language.simple.SimpleLanguage"");&#010;+            instance = clazz.newInstance();&#010;+        } catch (Exception e) {&#010;+            // ignore&#010;+        }&#010;+&#010;+        if (clazz != null &amp;&amp; instance != null) {&#010;+            Throwable cause = null;&#010;+            try {&#010;+                if (predicate) {&#010;+                    instance.getClass().getMethod(""createPredicate"", String.class).invoke(instance, resolved);&#010;+                } else {&#010;+                    instance.getClass().getMethod(""createExpression"", String.class).invoke(instance, resolved);&#010;+                }&#010;+            } catch (InvocationTargetException e) {&#010;+                cause = e.getTargetException();&#010;+            } catch (Exception e) {&#010;+                cause = e;&#010;+            }&#010;+&#010;+            if (cause != null) {&#010;+&#010;+                // reverse ~^XXX^~ back to {{XXX}}&#010;+                String errMsg = cause.getMessage();&#010;+                errMsg = errMsg.replaceAll(""\\~\\^(.+)\\^\\~"", ""{{$1}}"");&#010;+&#010;+                answer.setError(errMsg);&#010;+&#010;+                // is it simple parser exception then we can grab the index where the problem is&#010;+                if (cause.getClass().getName().equals(""org.apache.camel.language.simple.types.SimpleIllegalSyntaxException"")&#010;+                    || cause.getClass().getName().equals(""org.apache.camel.language.simple.types.SimpleParserException"")) {&#010;+                    try {&#010;+                        // we need to grab the index field from those simple parser exceptions&#010;+                        Method method = cause.getClass().getMethod(""getIndex"");&#010;+                        Object result = method.invoke(cause);&#010;+                        if (result != null) {&#010;+                            int index = (int) result;&#010;+                            answer.setIndex(index);&#010;+                        }&#010;+                    } catch (Throwable i) {&#010;+                        // ignore&#010;+                    }&#010;+                }&#010;+&#010;+                // we need to grab the short message field from this simple syntax exception&#010;+                if (cause.getClass().getName().equals(""org.apache.camel.language.simple.types.SimpleIllegalSyntaxException"")) {&#010;+                    try {&#010;+                        Method method = cause.getClass().getMethod(""getShortMessage"");&#010;+                        Object result = method.invoke(cause);&#010;+                        if (result != null) {&#010;+                            String msg = (String) result;&#010;+                            answer.setShortError(msg);&#010;+                        }&#010;+                    } catch (Throwable i) {&#010;+                        // ignore&#010;+                    }&#010;+&#010;+                    if (answer.getShortError() == null) {&#010;+                        // fallback and try to make existing message short instead&#010;+                        String msg = answer.getError();&#010;+                        // grab everything before "" at location "" which would be regarded as the short message&#010;+                        int idx = msg.indexOf("" at location "");&#010;+                        if (idx &gt; 0) {&#010;+                            msg = msg.substring(0, idx);&#010;+                            answer.setShortError(msg);&#010;+                        }&#010;+                    }&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    public LanguageValidationResult validateLanguagePredicate(ClassLoader classLoader, String language, String text) {&#010;+        return doValidateLanguage(classLoader, language, text, true);&#010;+    }&#010;+&#010;+    public LanguageValidationResult validateLanguageExpression(ClassLoader classLoader, String language, String text) {&#010;+        return doValidateLanguage(classLoader, language, text, false);&#010;+    }&#010;+&#010;+    private LanguageValidationResult doValidateLanguage(ClassLoader classLoader, String language, String text, boolean predicate) {&#010;+        if (classLoader == null) {&#010;+            classLoader = getClass().getClassLoader();&#010;+        }&#010;+&#010;+        SimpleValidationResult answer = new SimpleValidationResult(text);&#010;+&#010;+        String json = jsonSchemaResolver.getLanguageJSonSchema(language);&#010;+        if (json == null) {&#010;+            answer.setError(""Unknown language "" + language);&#010;+            return answer;&#010;+        }&#010;+&#010;+        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""language"", json, false);&#010;+        String className = null;&#010;+        for (Map&lt;String, String&gt; row : rows) {&#010;+            if (row.containsKey(""javaType"")) {&#010;+                className = row.get(""javaType"");&#010;+            }&#010;+        }&#010;+&#010;+        if (className == null) {&#010;+            answer.setError(""Cannot find javaType for language "" + language);&#010;+            return answer;&#010;+        }&#010;+&#010;+        Object instance = null;&#010;+        Class clazz = null;&#010;+        try {&#010;+            clazz = classLoader.loadClass(className);&#010;+            instance = clazz.newInstance();&#010;+        } catch (Exception e) {&#010;+            // ignore&#010;+        }&#010;+&#010;+        if (clazz != null &amp;&amp; instance != null) {&#010;+            Throwable cause = null;&#010;+            try {&#010;+                if (predicate) {&#010;+                    instance.getClass().getMethod(""createPredicate"", String.class).invoke(instance, text);&#010;+                } else {&#010;+                    instance.getClass().getMethod(""createExpression"", String.class).invoke(instance, text);&#010;+                }&#010;+            } catch (InvocationTargetException e) {&#010;+                cause = e.getTargetException();&#010;+            } catch (Exception e) {&#010;+                cause = e;&#010;+            }&#010;+&#010;+            if (cause != null) {&#010;+                answer.setError(cause.getMessage());&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    /**&#010;+     * Special logic for log endpoints to deal when showAll=true&#010;+     */&#010;+    private Map&lt;String, String&gt; filterProperties(String scheme, Map&lt;String, String&gt; options) {&#010;+        if (""log"".equals(scheme)) {&#010;+            String showAll = options.get(""showAll"");&#010;+            if (""true"".equals(showAll)) {&#010;+                Map&lt;String, String&gt; filtered = new LinkedHashMap&lt;String, String&gt;();&#010;+                // remove all the other showXXX options when showAll=true&#010;+                for (Map.Entry&lt;String, String&gt; entry : options.entrySet()) {&#010;+                    String key = entry.getKey();&#010;+                    boolean skip = key.startsWith(""show"") &amp;&amp; !key.equals(""showAll"");&#010;+                    if (!skip) {&#010;+                        filtered.put(key, entry.getValue());&#010;+                    }&#010;+                }&#010;+                return filtered;&#010;+            }&#010;+        }&#010;+        // use as-is&#010;+        return options;&#010;+    }&#010;+&#010;+    private static boolean validateInteger(String value) {&#010;+        boolean valid = false;&#010;+        try {&#010;+            valid = Integer.valueOf(value) != null;&#010;+        } catch (Exception e) {&#010;+            // ignore&#010;+        }&#010;+        if (!valid) {&#010;+            // it may be a time pattern, such as 5s for 5 seconds = 5000&#010;+            try {&#010;+                TimePatternConverter.toMilliSeconds(value);&#010;+                valid = true;&#010;+            } catch (Exception e) {&#010;+                // ignore&#010;+            }&#010;+        }&#010;+        return valid;&#010;+    }&#010;+&#010;+    // CHECKSTYLE:ON&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java&#010;new file mode 100644&#010;index 0000000..d3a448c&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CamelContextJSonSchemaResolver.java&#010;@@ -0,0 +1,80 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.IOException;&#010;+&#010;+import org.apache.camel.CamelContext;&#010;+&#010;+/**&#010;+ * Uses runtime {@link CamelContext} to resolve the JSon schema files.&#010;+ */&#010;+public class CamelContextJSonSchemaResolver implements JSonSchemaResolver {&#010;+&#010;+    private final CamelContext camelContext;&#010;+&#010;+    public CamelContextJSonSchemaResolver(CamelContext camelContext) {&#010;+        this.camelContext = camelContext;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getComponentJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getComponentParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getDataFormatJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getDataFormatParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getLanguageJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getLanguageParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getOtherJSonSchema(String name) {&#010;+        // not supported&#010;+        return null;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String getModelJSonSchema(String name) {&#010;+        try {&#010;+            return camelContext.getEipParameterJsonSchema(name);&#010;+        } catch (IOException e) {&#010;+            // ignore&#010;+        }&#010;+        return null;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java&#010;new file mode 100644&#010;index 0000000..1b224df&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CatalogHelper.java&#010;@@ -0,0 +1,179 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.BufferedReader;&#010;+import java.io.IOException;&#010;+import java.io.InputStream;&#010;+import java.io.InputStreamReader;&#010;+import java.io.LineNumberReader;&#010;+import java.util.List;&#010;+&#010;+public final class CatalogHelper {&#010;+&#010;+    private CatalogHelper() {&#010;+    }&#010;+&#010;+    /**&#010;+     * Loads the entire stream into memory as a String and returns it.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Notice:&lt;/b&gt; This implementation appends a &lt;tt&gt;\n&lt;/tt&gt; as line&#010;+     * terminator at the of the text.&#010;+     * &lt;p/&gt;&#010;+     * Warning, don't use for crazy big streams :)&#010;+     */&#010;+    public static void loadLines(InputStream in, List&lt;String&gt; lines) throws IOException {&#010;+        try (final InputStreamReader isr = new InputStreamReader(in);&#010;+            final BufferedReader reader = new LineNumberReader(isr)) {&#010;+            String line;&#010;+            while ((line = reader.readLine()) != null) {&#010;+                lines.add(line);&#010;+            }&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Loads the entire stream into memory as a String and returns it.&#010;+     * &lt;p/&gt;&#010;+     * &lt;b&gt;Notice:&lt;/b&gt; This implementation appends a &lt;tt&gt;\n&lt;/tt&gt; as line&#010;+     * terminator at the of the text.&#010;+     * &lt;p/&gt;&#010;+     * Warning, don't use for crazy big streams :)&#010;+     */&#010;+    public static String loadText(InputStream in) throws IOException {&#010;+        StringBuilder builder = new StringBuilder();&#010;+        try (final InputStreamReader isr = new InputStreamReader(in);&#010;+            final BufferedReader reader = new LineNumberReader(isr)) {&#010;+            String line;&#010;+            while ((line = reader.readLine()) != null) {&#010;+                builder.append(line);&#010;+                builder.append(""\n"");&#010;+            }&#010;+            return builder.toString();&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Matches the name with the pattern.&#010;+     *&#010;+     * @param name  the name&#010;+     * @param pattern the pattern&#010;+     * @return &lt;tt&gt;true&lt;/tt&gt; if matched, or &lt;tt&gt;false&lt;/tt&gt; if not&#010;+     */&#010;+    public static boolean matchWildcard(String name, String pattern) {&#010;+        // we have wildcard support in that hence you can match with: file* to match any file endpoints&#010;+        if (pattern.endsWith(""*"") &amp;&amp; name.startsWith(pattern.substring(0, pattern.length() - 1))) {&#010;+            return true;&#010;+        }&#010;+        return false;&#010;+    }&#010;+&#010;+    /**&#010;+     * Returns the string after the given token&#010;+     *&#010;+     * @param text  the text&#010;+     * @param after the token&#010;+     * @return the text after the token, or &lt;tt&gt;null&lt;/tt&gt; if text does not contain the token&#010;+     */&#010;+    public static String after(String text, String after) {&#010;+        if (!text.contains(after)) {&#010;+            return null;&#010;+        }&#010;+        return text.substring(text.indexOf(after) + after.length());&#010;+    }&#010;+&#010;+    /**&#010;+     * Returns the string before the given token&#010;+     *&#010;+     * @param text  the text&#010;+     * @param before the token&#010;+     * @return the text before the token, or &lt;tt&gt;null&lt;/tt&gt; if text does not contain the token&#010;+     */&#010;+    public static String before(String text, String before) {&#010;+        if (!text.contains(before)) {&#010;+            return null;&#010;+        }&#010;+        return text.substring(0, text.indexOf(before));&#010;+    }&#010;+&#010;+    /**&#010;+     * Returns the string between the given tokens&#010;+     *&#010;+     * @param text  the text&#010;+     * @param after the before token&#010;+     * @param before the after token&#010;+     * @return the text between the tokens, or &lt;tt&gt;null&lt;/tt&gt; if text does not contain the tokens&#010;+     */&#010;+    public static String between(String text, String after, String before) {&#010;+        text = after(text, after);&#010;+        if (text == null) {&#010;+            return null;&#010;+        }&#010;+        return before(text, before);&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if empty&#010;+     */&#010;+    public static boolean isEmpty(Object value) {&#010;+        return !isNotEmpty(value);&#010;+    }&#010;+&#010;+    /**&#010;+     * Tests whether the value is &lt;b&gt;not&lt;/b&gt; &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;+     *&#010;+     * @param value  the value, if its a String it will be tested for text length as well&#010;+     * @return true if &lt;b&gt;not&lt;/b&gt; empty&#010;+     */&#010;+    public static boolean isNotEmpty(Object value) {&#010;+        if (value == null) {&#010;+            return false;&#010;+        } else if (value instanceof String) {&#010;+            String text = (String) value;&#010;+            return text.trim().length() &gt; 0;&#010;+        } else {&#010;+            return true;&#010;+        }&#010;+    }&#010;+&#010;+    /**&#010;+     * Removes all leading and ending quotes (single and double) from the string&#010;+     *&#010;+     * @param s  the string&#010;+     * @return the string without leading and ending quotes (single and double)&#010;+     */&#010;+    public static String removeLeadingAndEndingQuotes(String s) {&#010;+        if (isEmpty(s)) {&#010;+            return s;&#010;+        }&#010;+&#010;+        String copy = s.trim();&#010;+        if (copy.startsWith(""'"") &amp;&amp; copy.endsWith(""'"")) {&#010;+            return copy.substring(1, copy.length() - 1);&#010;+        }&#010;+        if (copy.startsWith(""\"""") &amp;&amp; copy.endsWith(""\"""")) {&#010;+            return copy.substring(1, copy.length() - 1);&#010;+        }&#010;+&#010;+        // no quotes, so return as-is&#010;+        return s;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java&#010;new file mode 100644&#010;index 0000000..f6484b8&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/CollectionStringBuffer.java&#010;@@ -0,0 +1,57 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+public class CollectionStringBuffer {&#010;+    private final StringBuilder buffer = new StringBuilder();&#010;+    private String separator;&#010;+    private boolean first = true;&#010;+&#010;+    public CollectionStringBuffer() {&#010;+        this("", "");&#010;+    }&#010;+&#010;+    public CollectionStringBuffer(String separator) {&#010;+        this.separator = separator;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String toString() {&#010;+        return buffer.toString();&#010;+    }&#010;+&#010;+    public void append(Object value) {&#010;+        if (first) {&#010;+            first = false;&#010;+        } else {&#010;+            buffer.append(separator);&#010;+        }&#010;+        buffer.append(value);&#010;+    }&#010;+&#010;+    public String getSeparator() {&#010;+        return separator;&#010;+    }&#010;+&#010;+    public void setSeparator(String separator) {&#010;+        this.separator = separator;&#010;+    }&#010;+&#010;+    public boolean isEmpty() {&#010;+        return first;&#010;+    }&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java&#010;new file mode 100644&#010;index 0000000..7648e64&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/DefaultRuntimeCamelCatalog.java&#010;@@ -0,0 +1,136 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.util.HashMap;&#010;+import java.util.Map;&#010;+&#010;+import org.apache.camel.CamelContext;&#010;+&#010;+/**&#010;+ * Default {@link RuntimeCamelCatalog}.&#010;+ */&#010;+public class DefaultRuntimeCamelCatalog extends AbstractCamelCatalog implements RuntimeCamelCatalog {&#010;+&#010;+    // cache of operation -&gt; result&#010;+    private final Map&lt;String, Object&gt; cache = new HashMap&lt;String, Object&gt;();&#010;+    private boolean caching;&#010;+&#010;+    /**&#010;+     * Creates the {@link RuntimeCamelCatalog} without caching enabled.&#010;+     *&#010;+     * @param camelContext  the camel context&#010;+     */&#010;+    public DefaultRuntimeCamelCatalog(CamelContext camelContext) {&#010;+        this(camelContext, false);&#010;+    }&#010;+&#010;+    /**&#010;+     * Creates the {@link RuntimeCamelCatalog}&#010;+     *&#010;+     * @param camelContext  the camel context&#010;+     * @param caching  whether to use cache&#010;+     */&#010;+    public DefaultRuntimeCamelCatalog(CamelContext camelContext, boolean caching) {&#010;+        this.caching = caching;&#010;+        setJSonSchemaResolver(new CamelContextJSonSchemaResolver(camelContext));&#010;+    }&#010;+&#010;+    @Override&#010;+    public void start() throws Exception {&#010;+        // noop&#010;+    }&#010;+&#010;+    @Override&#010;+    public void stop() throws Exception {&#010;+        cache.clear();&#010;+    }&#010;+&#010;+    @Override&#010;+    public String modelJSonSchema(String name) {&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""model-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getModelJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""model-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String componentJSonSchema(String name) {&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""component-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getComponentJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""component-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String dataFormatJSonSchema(String name) {&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""dataformat-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getDataFormatJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""dataformat-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+    @Override&#010;+    public String languageJSonSchema(String name) {&#010;+        // if we try to look method then its in the bean.json file&#010;+        if (""method"".equals(name)) {&#010;+            name = ""bean"";&#010;+        }&#010;+&#010;+        String answer = null;&#010;+        if (caching) {&#010;+            answer = (String) cache.get(""language-"" + name);&#010;+        }&#010;+&#010;+        if (answer == null) {&#010;+            answer = getJSonSchemaResolver().getLanguageJSonSchema(name);&#010;+            if (caching) {&#010;+                cache.put(""language-"" + name, answer);&#010;+            }&#010;+        }&#010;+&#010;+        return answer;&#010;+    }&#010;+&#010;+}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java b/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java&#010;new file mode 100644&#010;index 0000000..7d1c657&#010;--- /dev/null&#010;+++ b/camel-core/src/main/java/org/apache/camel/runtimecatalog/EndpointValidationResult.java&#010;@@ -0,0 +1,451 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.runtimecatalog;&#010;+&#010;+import java.io.Serializable;&#010;+import java.util.Arrays;&#010;+import java.util.Collections;&#010;+import java.util.LinkedHashMap;&#010;+import java.util.LinkedHashSet;&#010;+import java.util.List;&#010;+import java.util.Map;&#010;+import java.util.Set;&#010;+&#010;+import static org.apache.camel.runtimecatalog.URISupport.isEmpty;&#010;+&#010;+/**&#010;+ * Details result of validating endpoint uri.&#010;+ */&#010;+public class EndpointValidationResult implements Serializable {&#010;+&#010;+    private final String uri;&#010;+    private int errors;&#010;+&#010;+    // general&#010;+    private String syntaxError;&#010;+    private String unknownComponent;&#010;+    private String incapable;&#010;+&#010;+    // options&#010;+    private Set&lt;String&gt; unknown;&#010;+    private Map&lt;String, String[]&gt; unknownSuggestions;&#010;+    private Set&lt;String&gt; lenient;&#010;+    private Set&lt;String&gt; notConsumerOnly;&#010;+    private Set&lt;String&gt; notProducerOnly;&#010;+    private Set&lt;String&gt; required;&#010;+    private Map&lt;String, String&gt; invalidEnum;&#010;+    private Map&lt;String, String[]&gt; invalidEnumChoices;&#010;+    private Map&lt;String, String[]&gt; invalidEnumSuggestions;&#010;+    private Map&lt;String, String&gt; invalidReference;&#010;+    private Map&lt;String, String&gt; invalidBoolean;&#010;+    private Map&lt;String, String&gt; invalidInteger;&#010;+    private Map&lt;String, String&gt; invalidNumber;&#010;+    private Map&lt;String, String&gt; defaultValues;&#010;+&#010;+    public EndpointValidationResult() {&#010;+        this(null);&#010;+    }&#010;+&#010;+    public EndpointValidationResult(String uri) {&#010;+        this.uri = uri;&#010;+    }&#010;+&#010;+    public String getUri() {&#010;+        return uri;&#010;+    }&#010;+&#010;+    public boolean hasErrors() {&#010;+        return errors &gt; 0;&#010;+    }&#010;+&#010;+    public int getNumberOfErrors() {&#010;+        return errors;&#010;+    }&#010;+&#010;+    public boolean isSuccess() {&#010;+        boolean ok = syntaxError == null &amp;&amp; unknownComponent == null &amp;&amp; incapable == null&#010;+                &amp;&amp; unknown == null &amp;&amp; required == null;&#010;+        if (ok) {&#010;+            ok = notConsumerOnly == null &amp;&amp; notProducerOnly == null;&#010;+        }&#010;+        if (ok) {&#010;+            ok = invalidEnum == null &amp;&amp; invalidEnumChoices == null &amp;&amp; invalidReference == null&#010;+                &amp;&amp; invalidBoolean == null &amp;&amp; invalidInteger == null &amp;&amp; invalidNumber == null;&#010;+        }&#010;+        return ok;&#010;+    }&#010;+&#010;+    public void addSyntaxError(String syntaxError) {&#010;+        this.syntaxError = syntaxError;&#010;+        errors++;&#010;+    }&#010;+&#010;+    public void addIncapable(String uri) {&#010;+        this.incapable = uri;&#010;+        errors++;&#010;+    }&#010;+&#010;+    public void addUnknownComponent(String name) {&#010;+        this.unknownComponent = name;&#010;+        errors++;&#010;+    }&#010;+&#010;+    public void addUnknown(String name) {&#010;+        if (unknown == null) {&#010;+            unknown = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!unknown.contains(name)) {&#010;+            unknown.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addUnknownSuggestions(String name, String[] suggestions) {&#010;+        if (unknownSuggestions == null) {&#010;+            unknownSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;+        }&#010;+        unknownSuggestions.put(name, suggestions);&#010;+    }&#010;+&#010;+    public void addLenient(String name) {&#010;+        if (lenient == null) {&#010;+            lenient = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!lenient.contains(name)) {&#010;+            lenient.add(name);&#010;+        }&#010;+    }&#010;+&#010;+    public void addRequired(String name) {&#010;+        if (required == null) {&#010;+            required = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!required.contains(name)) {&#010;+            required.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidEnum(String name, String value) {&#010;+        if (invalidEnum == null) {&#010;+            invalidEnum = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidEnum.containsKey(name)) {&#010;+            invalidEnum.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidEnumChoices(String name, String[] choices) {&#010;+        if (invalidEnumChoices == null) {&#010;+            invalidEnumChoices = new LinkedHashMap&lt;String, String[]&gt;();&#010;+        }&#010;+        invalidEnumChoices.put(name, choices);&#010;+    }&#010;+&#010;+    public void addInvalidEnumSuggestions(String name, String[] suggestions) {&#010;+        if (invalidEnumSuggestions == null) {&#010;+            invalidEnumSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;+        }&#010;+        invalidEnumSuggestions.put(name, suggestions);&#010;+    }&#010;+&#010;+    public void addInvalidReference(String name, String value) {&#010;+        if (invalidReference == null) {&#010;+            invalidReference = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidReference.containsKey(name)) {&#010;+            invalidReference.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidBoolean(String name, String value) {&#010;+        if (invalidBoolean == null) {&#010;+            invalidBoolean = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidBoolean.containsKey(name)) {&#010;+            invalidBoolean.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidInteger(String name, String value) {&#010;+        if (invalidInteger == null) {&#010;+            invalidInteger = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidInteger.containsKey(name)) {&#010;+            invalidInteger.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addInvalidNumber(String name, String value) {&#010;+        if (invalidNumber == null) {&#010;+            invalidNumber = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        if (!invalidNumber.containsKey(name)) {&#010;+            invalidNumber.put(name, value);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addDefaultValue(String name, String value)  {&#010;+        if (defaultValues == null) {&#010;+            defaultValues = new LinkedHashMap&lt;String, String&gt;();&#010;+        }&#010;+        defaultValues.put(name, value);&#010;+    }&#010;+&#010;+    public void addNotConsumerOnly(String name) {&#010;+        if (notConsumerOnly == null) {&#010;+            notConsumerOnly = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!notConsumerOnly.contains(name)) {&#010;+            notConsumerOnly.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public void addNotProducerOnly(String name) {&#010;+        if (notProducerOnly == null) {&#010;+            notProducerOnly = new LinkedHashSet&lt;String&gt;();&#010;+        }&#010;+        if (!notProducerOnly.contains(name)) {&#010;+            notProducerOnly.add(name);&#010;+            errors++;&#010;+        }&#010;+    }&#010;+&#010;+    public String getSyntaxError() {&#010;+        return syntaxError;&#010;+    }&#010;+&#010;+    public String getIncapable() {&#010;+        return incapable;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getUnknown() {&#010;+        return unknown;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getLenient() {&#010;+        return lenient;&#010;+    }&#010;+&#010;+    public Map&lt;String, String[]&gt; getUnknownSuggestions() {&#010;+        return unknownSuggestions;&#010;+    }&#010;+&#010;+    public String getUnknownComponent() {&#010;+        return unknownComponent;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getRequired() {&#010;+        return required;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidEnum() {&#010;+        return invalidEnum;&#010;+    }&#010;+&#010;+    public Map&lt;String, String[]&gt; getInvalidEnumChoices() {&#010;+        return invalidEnumChoices;&#010;+    }&#010;+&#010;+    public List&lt;String&gt; getEnumChoices(String optionName) {&#010;+        if (invalidEnumChoices != null) {&#010;+            String[] enums = invalidEnumChoices.get(optionName);&#010;+            if (enums != null) {&#010;+                return Arrays.asList(enums);&#010;+            }&#010;+        }&#010;+&#010;+        return Collections.emptyList();&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidReference() {&#010;+        return invalidReference;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidBoolean() {&#010;+        return invalidBoolean;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidInteger() {&#010;+        return invalidInteger;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getInvalidNumber() {&#010;+        return invalidNumber;&#010;+    }&#010;+&#010;+    public Map&lt;String, String&gt; getDefaultValues() {&#010;+        return defaultValues;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getNotConsumerOnly() {&#010;+        return notConsumerOnly;&#010;+    }&#010;+&#010;+    public Set&lt;String&gt; getNotProducerOnly() {&#010;+        return notProducerOnly;&#010;+    }&#010;+&#010;+    /**&#010;+     * A human readable summary of the validation errors.&#010;+     *&#010;+     * @param includeHeader whether to include a header&#010;+     * @return the summary, or &lt;tt&gt;null&lt;/tt&gt; if no validation errors&#010;+     */&#010;+    public String summaryErrorMessage(boolean includeHeader) {&#010;+        if (isSuccess()) {&#010;+            return null;&#010;+        }&#010;+&#010;+        if (incapable != null) {&#010;+            return ""\tIncapable of parsing uri: "" + incapable;&#010;+        } else if (syntaxError != null) {&#010;+            return ""\tSyntax error: "" + syntaxError;&#010;+        } else if (unknownComponent != null) {&#010;+            return ""\tUnknown component: "" + unknownComponent;&#010;+        }&#010;+&#010;+        // for each invalid option build a reason message&#010;+        Map&lt;String, String&gt; options = new LinkedHashMap&lt;String, String&gt;();&#010;+        if (unknown != null) {&#010;+            for (String name : unknown) {&#010;+                if (unknownSuggestions != null &amp;&amp; unknownSuggestions.containsKey(name)) {&#010;+                    String[] suggestions = unknownSuggestions.get(name);&#010;+                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;+                        String str = Arrays.asList(suggestions).toString();&#010;+                        options.put(name, ""Unknown option. Did you mean: "" + str);&#010;+                    } else {&#010;+                        options.put(name, ""Unknown option"");&#010;+                    }&#010;+                } else {&#010;+                    options.put(name, ""Unknown option"");&#010;+                }&#010;+            }&#010;+        }&#010;+        if (notConsumerOnly != null) {&#010;+            for (String name : notConsumerOnly) {&#010;+                options.put(name, ""Option not applicable in consumer only mode"");&#010;+            }&#010;+        }&#010;+        if (notProducerOnly != null) {&#010;+            for (String name : notProducerOnly) {&#010;+                options.put(name, ""Option not applicable in producer only mode"");&#010;+            }&#010;+        }&#010;+        if (required != null) {&#010;+            for (String name : required) {&#010;+                options.put(name, ""Missing required option"");&#010;+            }&#010;+        }&#010;+        if (invalidEnum != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidEnum.entrySet()) {&#010;+                String name = entry.getKey();&#010;+                String[] choices = invalidEnumChoices.get(name);&#010;+                String defaultValue = defaultValues != null ? defaultValues.get(entry.getKey()) : null;&#010;+                String str = Arrays.asList(choices).toString();&#010;+                String msg = ""Invalid enum value: "" + entry.getValue() + "". Possible values: "" + str;&#010;+                if (invalidEnumSuggestions != null) {&#010;+                    String[] suggestions = invalidEnumSuggestions.get(name);&#010;+                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;+                        str = Arrays.asList(suggestions).toString();&#010;+                        msg += "". Did you mean: "" + str;&#010;+                    }&#010;+                }&#010;+                if (defaultValue != null) {&#010;+                    msg += "". Default value: "" + defaultValue;&#010;+                }&#010;+&#010;+                options.put(entry.getKey(), msg);&#010;+            }&#010;+        }&#010;+        if (invalidReference != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidReference.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty reference value"");&#010;+                } else if (!entry.getValue().startsWith(""#"")) {&#010;+                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue() + "" must start with #"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+        if (invalidBoolean != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidBoolean.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty boolean value"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid boolean value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+        if (invalidInteger != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidInteger.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty integer value"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid integer value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+        if (invalidNumber != null) {&#010;+            for (Map.Entry&lt;String, String&gt; entry : invalidNumber.entrySet()) {&#010;+                boolean empty = isEmpty(entry.getValue());&#010;+                if (empty) {&#010;+                    options.put(entry.getKey(), ""Empty number value"");&#010;+                } else {&#010;+                    options.put(entry.getKey(), ""Invalid number value: "" + entry.getValue());&#010;+                }&#010;+            }&#010;+        }&#010;+&#010;+        // build a table with the error summary nicely formatted&#010;+        // lets use 24 as min length&#010;+        int maxLen = 24;&#010;+        for (String key : options.keySet()) {&#010;+            maxLen = Math.max(maxLen, key.length());&#010;+        }&#010;+        String format = ""%"" + maxLen + ""s    %s"";&#010;+&#010;+        // build the human error summary&#010;+        StringBuilder sb = new StringBuilder();&#010;+        if (includeHeader) {&#010;+            sb.append(""Endpoint validator error\n"");&#010;+            sb.append(""---------------------------------------------------------------------------------------------------------------------------------------\n"");&#010;+            sb.append(""\n"");&#010;+        }&#010;+        if (uri != null) {&#010;+            sb.append(""\t"").append(uri).append(""\n"");&#010;+        } else {&#010;+            sb.append(""\n"");&#010;+        }&#010;+        for (Map.Entry&lt;String, String&gt; option : options.entrySet()) {&#010;+            String out = String.format(format, option.getKey(), option.getValue());&#010;+            sb.append(""\n\t"").append(out);&#010;+        }&#010;+&#010;+        return sb.toString();&#010;+    }&#010;+}&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C0ffd278dae9f48d5849d5bd0dc60655f%40git.apache.org%3E,2017-04-14 10:52,commits,6.0,325.0,  [4/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
25,326.0,davscl...@apache.org,"http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java b/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&#010;deleted file mode 100644&#010;index 9bb98f0..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/EndpointValidationResult.java&#010;+++ /dev/null&#010;@@ -1,451 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.io.Serializable;&#010;-import java.util.Arrays;&#010;-import java.util.Collections;&#010;-import java.util.LinkedHashMap;&#010;-import java.util.LinkedHashSet;&#010;-import java.util.List;&#010;-import java.util.Map;&#010;-import java.util.Set;&#010;-&#010;-import static org.apache.camel.catalog.URISupport.isEmpty;&#010;-&#010;-/**&#010;- * Details result of validating endpoint uri.&#010;- */&#010;-public class EndpointValidationResult implements Serializable {&#010;-&#010;-    private final String uri;&#010;-    private int errors;&#010;-&#010;-    // general&#010;-    private String syntaxError;&#010;-    private String unknownComponent;&#010;-    private String incapable;&#010;-&#010;-    // options&#010;-    private Set&lt;String&gt; unknown;&#010;-    private Map&lt;String, String[]&gt; unknownSuggestions;&#010;-    private Set&lt;String&gt; lenient;&#010;-    private Set&lt;String&gt; notConsumerOnly;&#010;-    private Set&lt;String&gt; notProducerOnly;&#010;-    private Set&lt;String&gt; required;&#010;-    private Map&lt;String, String&gt; invalidEnum;&#010;-    private Map&lt;String, String[]&gt; invalidEnumChoices;&#010;-    private Map&lt;String, String[]&gt; invalidEnumSuggestions;&#010;-    private Map&lt;String, String&gt; invalidReference;&#010;-    private Map&lt;String, String&gt; invalidBoolean;&#010;-    private Map&lt;String, String&gt; invalidInteger;&#010;-    private Map&lt;String, String&gt; invalidNumber;&#010;-    private Map&lt;String, String&gt; defaultValues;&#010;-&#010;-    public EndpointValidationResult() {&#010;-        this(null);&#010;-    }&#010;-&#010;-    public EndpointValidationResult(String uri) {&#010;-        this.uri = uri;&#010;-    }&#010;-&#010;-    public String getUri() {&#010;-        return uri;&#010;-    }&#010;-&#010;-    public boolean hasErrors() {&#010;-        return errors &gt; 0;&#010;-    }&#010;-&#010;-    public int getNumberOfErrors() {&#010;-        return errors;&#010;-    }&#010;-&#010;-    public boolean isSuccess() {&#010;-        boolean ok = syntaxError == null &amp;&amp; unknownComponent == null &amp;&amp; incapable == null&#010;-                &amp;&amp; unknown == null &amp;&amp; required == null;&#010;-        if (ok) {&#010;-            ok = notConsumerOnly == null &amp;&amp; notProducerOnly == null;&#010;-        }&#010;-        if (ok) {&#010;-            ok = invalidEnum == null &amp;&amp; invalidEnumChoices == null &amp;&amp; invalidReference == null&#010;-                &amp;&amp; invalidBoolean == null &amp;&amp; invalidInteger == null &amp;&amp; invalidNumber == null;&#010;-        }&#010;-        return ok;&#010;-    }&#010;-&#010;-    public void addSyntaxError(String syntaxError) {&#010;-        this.syntaxError = syntaxError;&#010;-        errors++;&#010;-    }&#010;-&#010;-    public void addIncapable(String uri) {&#010;-        this.incapable = uri;&#010;-        errors++;&#010;-    }&#010;-&#010;-    public void addUnknownComponent(String name) {&#010;-        this.unknownComponent = name;&#010;-        errors++;&#010;-    }&#010;-&#010;-    public void addUnknown(String name) {&#010;-        if (unknown == null) {&#010;-            unknown = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!unknown.contains(name)) {&#010;-            unknown.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addUnknownSuggestions(String name, String[] suggestions) {&#010;-        if (unknownSuggestions == null) {&#010;-            unknownSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;-        }&#010;-        unknownSuggestions.put(name, suggestions);&#010;-    }&#010;-&#010;-    public void addLenient(String name) {&#010;-        if (lenient == null) {&#010;-            lenient = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!lenient.contains(name)) {&#010;-            lenient.add(name);&#010;-        }&#010;-    }&#010;-&#010;-    public void addRequired(String name) {&#010;-        if (required == null) {&#010;-            required = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!required.contains(name)) {&#010;-            required.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidEnum(String name, String value) {&#010;-        if (invalidEnum == null) {&#010;-            invalidEnum = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidEnum.containsKey(name)) {&#010;-            invalidEnum.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidEnumChoices(String name, String[] choices) {&#010;-        if (invalidEnumChoices == null) {&#010;-            invalidEnumChoices = new LinkedHashMap&lt;String, String[]&gt;();&#010;-        }&#010;-        invalidEnumChoices.put(name, choices);&#010;-    }&#010;-&#010;-    public void addInvalidEnumSuggestions(String name, String[] suggestions) {&#010;-        if (invalidEnumSuggestions == null) {&#010;-            invalidEnumSuggestions = new LinkedHashMap&lt;String, String[]&gt;();&#010;-        }&#010;-        invalidEnumSuggestions.put(name, suggestions);&#010;-    }&#010;-&#010;-    public void addInvalidReference(String name, String value) {&#010;-        if (invalidReference == null) {&#010;-            invalidReference = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidReference.containsKey(name)) {&#010;-            invalidReference.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidBoolean(String name, String value) {&#010;-        if (invalidBoolean == null) {&#010;-            invalidBoolean = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidBoolean.containsKey(name)) {&#010;-            invalidBoolean.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidInteger(String name, String value) {&#010;-        if (invalidInteger == null) {&#010;-            invalidInteger = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidInteger.containsKey(name)) {&#010;-            invalidInteger.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addInvalidNumber(String name, String value) {&#010;-        if (invalidNumber == null) {&#010;-            invalidNumber = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        if (!invalidNumber.containsKey(name)) {&#010;-            invalidNumber.put(name, value);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addDefaultValue(String name, String value)  {&#010;-        if (defaultValues == null) {&#010;-            defaultValues = new LinkedHashMap&lt;String, String&gt;();&#010;-        }&#010;-        defaultValues.put(name, value);&#010;-    }&#010;-&#010;-    public void addNotConsumerOnly(String name) {&#010;-        if (notConsumerOnly == null) {&#010;-            notConsumerOnly = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!notConsumerOnly.contains(name)) {&#010;-            notConsumerOnly.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public void addNotProducerOnly(String name) {&#010;-        if (notProducerOnly == null) {&#010;-            notProducerOnly = new LinkedHashSet&lt;String&gt;();&#010;-        }&#010;-        if (!notProducerOnly.contains(name)) {&#010;-            notProducerOnly.add(name);&#010;-            errors++;&#010;-        }&#010;-    }&#010;-&#010;-    public String getSyntaxError() {&#010;-        return syntaxError;&#010;-    }&#010;-&#010;-    public String getIncapable() {&#010;-        return incapable;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getUnknown() {&#010;-        return unknown;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getLenient() {&#010;-        return lenient;&#010;-    }&#010;-&#010;-    public Map&lt;String, String[]&gt; getUnknownSuggestions() {&#010;-        return unknownSuggestions;&#010;-    }&#010;-&#010;-    public String getUnknownComponent() {&#010;-        return unknownComponent;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getRequired() {&#010;-        return required;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidEnum() {&#010;-        return invalidEnum;&#010;-    }&#010;-&#010;-    public Map&lt;String, String[]&gt; getInvalidEnumChoices() {&#010;-        return invalidEnumChoices;&#010;-    }&#010;-&#010;-    public List&lt;String&gt; getEnumChoices(String optionName) {&#010;-        if (invalidEnumChoices != null) {&#010;-            String[] enums = invalidEnumChoices.get(optionName);&#010;-            if (enums != null) {&#010;-                return Arrays.asList(enums);&#010;-            }&#010;-        }&#010;-&#010;-        return Collections.emptyList();&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidReference() {&#010;-        return invalidReference;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidBoolean() {&#010;-        return invalidBoolean;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidInteger() {&#010;-        return invalidInteger;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getInvalidNumber() {&#010;-        return invalidNumber;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; getDefaultValues() {&#010;-        return defaultValues;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getNotConsumerOnly() {&#010;-        return notConsumerOnly;&#010;-    }&#010;-&#010;-    public Set&lt;String&gt; getNotProducerOnly() {&#010;-        return notProducerOnly;&#010;-    }&#010;-&#010;-    /**&#010;-     * A human readable summary of the validation errors.&#010;-     *&#010;-     * @param includeHeader whether to include a header&#010;-     * @return the summary, or &lt;tt&gt;null&lt;/tt&gt; if no validation errors&#010;-     */&#010;-    public String summaryErrorMessage(boolean includeHeader) {&#010;-        if (isSuccess()) {&#010;-            return null;&#010;-        }&#010;-&#010;-        if (incapable != null) {&#010;-            return ""\tIncapable of parsing uri: "" + incapable;&#010;-        } else if (syntaxError != null) {&#010;-            return ""\tSyntax error: "" + syntaxError;&#010;-        } else if (unknownComponent != null) {&#010;-            return ""\tUnknown component: "" + unknownComponent;&#010;-        }&#010;-&#010;-        // for each invalid option build a reason message&#010;-        Map&lt;String, String&gt; options = new LinkedHashMap&lt;String, String&gt;();&#010;-        if (unknown != null) {&#010;-            for (String name : unknown) {&#010;-                if (unknownSuggestions != null &amp;&amp; unknownSuggestions.containsKey(name)) {&#010;-                    String[] suggestions = unknownSuggestions.get(name);&#010;-                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;-                        String str = Arrays.asList(suggestions).toString();&#010;-                        options.put(name, ""Unknown option. Did you mean: "" + str);&#010;-                    } else {&#010;-                        options.put(name, ""Unknown option"");&#010;-                    }&#010;-                } else {&#010;-                    options.put(name, ""Unknown option"");&#010;-                }&#010;-            }&#010;-        }&#010;-        if (notConsumerOnly != null) {&#010;-            for (String name : notConsumerOnly) {&#010;-                options.put(name, ""Option not applicable in consumer only mode"");&#010;-            }&#010;-        }&#010;-        if (notProducerOnly != null) {&#010;-            for (String name : notProducerOnly) {&#010;-                options.put(name, ""Option not applicable in producer only mode"");&#010;-            }&#010;-        }&#010;-        if (required != null) {&#010;-            for (String name : required) {&#010;-                options.put(name, ""Missing required option"");&#010;-            }&#010;-        }&#010;-        if (invalidEnum != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidEnum.entrySet()) {&#010;-                String name = entry.getKey();&#010;-                String[] choices = invalidEnumChoices.get(name);&#010;-                String defaultValue = defaultValues != null ? defaultValues.get(entry.getKey()) : null;&#010;-                String str = Arrays.asList(choices).toString();&#010;-                String msg = ""Invalid enum value: "" + entry.getValue() + "". Possible values: "" + str;&#010;-                if (invalidEnumSuggestions != null) {&#010;-                    String[] suggestions = invalidEnumSuggestions.get(name);&#010;-                    if (suggestions != null &amp;&amp; suggestions.length &gt; 0) {&#010;-                        str = Arrays.asList(suggestions).toString();&#010;-                        msg += "". Did you mean: "" + str;&#010;-                    }&#010;-                }&#010;-                if (defaultValue != null) {&#010;-                    msg += "". Default value: "" + defaultValue;&#010;-                }&#010;-&#010;-                options.put(entry.getKey(), msg);&#010;-            }&#010;-        }&#010;-        if (invalidReference != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidReference.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty reference value"");&#010;-                } else if (!entry.getValue().startsWith(""#"")) {&#010;-                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue() + "" must start with #"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid reference value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-        if (invalidBoolean != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidBoolean.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty boolean value"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid boolean value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-        if (invalidInteger != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidInteger.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty integer value"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid integer value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-        if (invalidNumber != null) {&#010;-            for (Map.Entry&lt;String, String&gt; entry : invalidNumber.entrySet()) {&#010;-                boolean empty = isEmpty(entry.getValue());&#010;-                if (empty) {&#010;-                    options.put(entry.getKey(), ""Empty number value"");&#010;-                } else {&#010;-                    options.put(entry.getKey(), ""Invalid number value: "" + entry.getValue());&#010;-                }&#010;-            }&#010;-        }&#010;-&#010;-        // build a table with the error summary nicely formatted&#010;-        // lets use 24 as min length&#010;-        int maxLen = 24;&#010;-        for (String key : options.keySet()) {&#010;-            maxLen = Math.max(maxLen, key.length());&#010;-        }&#010;-        String format = ""%"" + maxLen + ""s    %s"";&#010;-&#010;-        // build the human error summary&#010;-        StringBuilder sb = new StringBuilder();&#010;-        if (includeHeader) {&#010;-            sb.append(""Endpoint validator error\n"");&#010;-            sb.append(""---------------------------------------------------------------------------------------------------------------------------------------\n"");&#010;-            sb.append(""\n"");&#010;-        }&#010;-        if (uri != null) {&#010;-            sb.append(""\t"").append(uri).append(""\n"");&#010;-        } else {&#010;-            sb.append(""\n"");&#010;-        }&#010;-        for (Map.Entry&lt;String, String&gt; option : options.entrySet()) {&#010;-            String out = String.format(format, option.getKey(), option.getValue());&#010;-            sb.append(""\n\t"").append(out);&#010;-        }&#010;-&#010;-        return sb.toString();&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java b/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&#010;deleted file mode 100644&#010;index 774facd..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaHelper.java&#010;+++ /dev/null&#010;@@ -1,424 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.ArrayList;&#010;-import java.util.LinkedHashMap;&#010;-import java.util.LinkedHashSet;&#010;-import java.util.List;&#010;-import java.util.Map;&#010;-import java.util.Set;&#010;-import java.util.regex.Matcher;&#010;-import java.util.regex.Pattern;&#010;-&#010;-public final class JSonSchemaHelper {&#010;-&#010;-    // 0 = text, 1 = enum, 2 = boolean, 3 = integer or number&#010;-    private static final Pattern PATTERN = Pattern.compile(""\""(.+?)\""|\\[(.+)\\]|(true|false)|(-?\\d+\\.?\\d*)"");&#010;-    private static final String QUOT = ""&amp;quot;"";&#010;-&#010;-    private JSonSchemaHelper() {&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the json schema to split it into a list or rows, where each row contains key value pairs with the metadata&#010;-     *&#010;-     * @param group the group to parse from such as &lt;tt&gt;component&lt;/tt&gt;, &lt;tt&gt;componentProperties&lt;/tt&gt;, or &lt;tt&gt;properties&lt;/tt&gt;.&#010;-     * @param json the json&#010;-     * @return a list of all the rows, where each row is a set of key value pairs with metadata&#010;-     */&#010;-    public static List&lt;Map&lt;String, String&gt;&gt; parseJsonSchema(String group, String json, boolean parseProperties) {&#010;-        List&lt;Map&lt;String, String&gt;&gt; answer = new ArrayList&lt;Map&lt;String, String&gt;&gt;();&#010;-        if (json == null) {&#010;-            return answer;&#010;-        }&#010;-&#010;-        boolean found = false;&#010;-&#010;-        // parse line by line&#010;-        String[] lines = json.split(""\n"");&#010;-        for (String line : lines) {&#010;-            // we need to find the group first&#010;-            if (!found) {&#010;-                String s = line.trim();&#010;-                found = s.startsWith(""\"""" + group + ""\"":"") &amp;&amp; s.endsWith(""{"");&#010;-                continue;&#010;-            }&#010;-&#010;-            // we should stop when we end the group&#010;-            if (line.equals(""  },"") || line.equals(""  }"")) {&#010;-                break;&#010;-            }&#010;-&#010;-            // need to safe encode \"" so we can parse the line&#010;-            line = line.replaceAll(""\""\\\\\""\"""", '""' + QUOT + '""');&#010;-&#010;-            Map&lt;String, String&gt; row = new LinkedHashMap&lt;String, String&gt;();&#010;-            Matcher matcher = PATTERN.matcher(line);&#010;-&#010;-            String key;&#010;-            if (parseProperties) {&#010;-                // when parsing properties the first key is given as name, so the first parsed token is the value of the name&#010;-                key = ""name"";&#010;-            } else {&#010;-                key = null;&#010;-            }&#010;-            while (matcher.find()) {&#010;-                if (key == null) {&#010;-                    key = matcher.group(1);&#010;-                } else {&#010;-                    String value = matcher.group(1);&#010;-                    if (value != null) {&#010;-                        // its text based&#010;-                        value = value.trim();&#010;-                        // decode&#010;-                        value = value.replaceAll(QUOT, ""\"""");&#010;-                        value = decodeJson(value);&#010;-                    }&#010;-                    if (value == null) {&#010;-                        // not text then its maybe an enum?&#010;-                        value = matcher.group(2);&#010;-                        if (value != null) {&#010;-                            // its an enum so strip out "" and trim spaces after comma&#010;-                            value = value.replaceAll(""\"""", """");&#010;-                            value = value.replaceAll("", "", "","");&#010;-                            value = value.trim();&#010;-                        }&#010;-                    }&#010;-                    if (value == null) {&#010;-                        // not text then its maybe a boolean?&#010;-                        value = matcher.group(3);&#010;-                    }&#010;-                    if (value == null) {&#010;-                        // not text then its maybe a integer?&#010;-                        value = matcher.group(4);&#010;-                    }&#010;-                    if (value != null) {&#010;-                        row.put(key, value);&#010;-                    }&#010;-                    // reset&#010;-                    key = null;&#010;-                }&#010;-            }&#010;-            if (!row.isEmpty()) {&#010;-                answer.add(row);&#010;-            }&#010;-        }&#010;-&#010;-        return answer;&#010;-    }&#010;-&#010;-    private static String decodeJson(String value) {&#010;-        // json encodes a \ as \\ so we need to decode from \\ back to \&#010;-        if (""\\\\"".equals(value)) {&#010;-            value = ""\\"";&#010;-        }&#010;-        return value;&#010;-    }&#010;-&#010;-    public static boolean isComponentLenientProperties(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""lenientProperties"")) {&#010;-                return ""true"".equals(row.get(""lenientProperties""));&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isComponentConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""consumerOnly"")) {&#010;-                return ""true"".equals(row.get(""consumerOnly""));&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isComponentProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""producerOnly"")) {&#010;-                return ""true"".equals(row.get(""producerOnly""));&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyConsumerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String labels = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""label"")) {&#010;-                labels = row.get(""label"");&#010;-            }&#010;-            if (found) {&#010;-                return labels != null &amp;&amp; labels.contains(""consumer"");&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyProducerOnly(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String labels = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""label"")) {&#010;-                labels = row.get(""label"");&#010;-            }&#010;-            if (found) {&#010;-                return labels != null &amp;&amp; labels.contains(""producer"");&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyRequired(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            boolean required = false;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""required"")) {&#010;-                required = ""true"".equals(row.get(""required""));&#010;-            }&#010;-            if (found) {&#010;-                return required;&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static String getPropertyKind(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String kind = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""kind"")) {&#010;-                kind = row.get(""kind"");&#010;-            }&#010;-            if (found) {&#010;-                return kind;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static boolean isPropertyBoolean(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""boolean"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyInteger(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""integer"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyNumber(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""number"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static boolean isPropertyObject(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String type = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""type"")) {&#010;-                type = row.get(""type"");&#010;-            }&#010;-            if (found) {&#010;-                return ""object"".equals(type);&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static String getPropertyDefaultValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String defaultValue = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""defaultValue"")) {&#010;-                defaultValue = row.get(""defaultValue"");&#010;-            }&#010;-            if (found) {&#010;-                return defaultValue;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static String stripOptionalPrefixFromName(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String optionalPrefix = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""optionalPrefix"")) {&#010;-                optionalPrefix = row.get(""optionalPrefix"");&#010;-            }&#010;-            if (row.containsKey(""name"")) {&#010;-                if (optionalPrefix != null &amp;&amp; name.startsWith(optionalPrefix)) {&#010;-                    name = name.substring(optionalPrefix.length());&#010;-                    // try again&#010;-                    return stripOptionalPrefixFromName(rows, name);&#010;-                } else {&#010;-                    found = name.equals(row.get(""name""));&#010;-                }&#010;-            }&#010;-            if (found) {&#010;-                return name;&#010;-            }&#010;-        }&#010;-        return name;&#010;-    }&#010;-&#010;-    public static String getPropertyEnum(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String enums = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""enum"")) {&#010;-                enums = row.get(""enum"");&#010;-            }&#010;-            if (found) {&#010;-                return enums;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static String getPropertyPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String prefix = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""prefix"")) {&#010;-                prefix = row.get(""prefix"");&#010;-            }&#010;-            if (found) {&#010;-                return prefix;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static boolean isPropertyMultiValue(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            boolean multiValue = false;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                found = name.equals(row.get(""name""));&#010;-            }&#010;-            if (row.containsKey(""multiValue"")) {&#010;-                multiValue = ""true"".equals(row.get(""multiValue""));&#010;-            }&#010;-            if (found) {&#010;-                return multiValue;&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    public static String getPropertyNameFromNameWithPrefix(List&lt;Map&lt;String, String&gt;&gt; rows, String name) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String propertyName = null;&#010;-            boolean found = false;&#010;-            if (row.containsKey(""name"")) {&#010;-                propertyName = row.get(""name"");&#010;-            }&#010;-            if (row.containsKey(""prefix"")) {&#010;-                String preifx = row.get(""prefix"");&#010;-                found = name.startsWith(preifx);&#010;-            }&#010;-            if (found) {&#010;-                return propertyName;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static Map&lt;String, String&gt; getRow(List&lt;Map&lt;String, String&gt;&gt; rows, String key) {&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (key.equals(row.get(""name""))) {&#010;-                return row;&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public static Set&lt;String&gt; getNames(List&lt;Map&lt;String, String&gt;&gt; rows) {&#010;-        Set&lt;String&gt; answer = new LinkedHashSet&lt;String&gt;();&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""name"")) {&#010;-                answer.add(row.get(""name""));&#010;-            }&#010;-        }&#010;-        return answer;&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java b/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&#010;deleted file mode 100644&#010;index 9bf09cc..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/JSonSchemaResolver.java&#010;+++ /dev/null&#010;@@ -1,64 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-/**&#010;- * Pluggable resolver to load JSon schema files for components, data formats, languages etc.&#010;- */&#010;-public interface JSonSchemaResolver {&#010;-&#010;-    /**&#010;-     * Returns the component information as JSon format.&#010;-     *&#010;-     * @param name the component name&#010;-     * @return component details in JSon&#010;-     */&#010;-    String getComponentJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the data format information as JSon format.&#010;-     *&#010;-     * @param name the data format name&#010;-     * @return data format details in JSon&#010;-     */&#010;-    String getDataFormatJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the language information as JSon format.&#010;-     *&#010;-     * @param name the language name&#010;-     * @return language details in JSon&#010;-     */&#010;-    String getLanguageJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the other (miscellaneous) information as JSon format.&#010;-     *&#010;-     * @param name the other (miscellaneous) name&#010;-     * @return other (miscellaneous) details in JSon&#010;-     */&#010;-    String getOtherJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the model information as JSon format.&#010;-     *&#010;-     * @param name the model name&#010;-     * @return model details in JSon&#010;-     */&#010;-    String getModelJSonSchema(String name);&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java b/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&#010;deleted file mode 100644&#010;index 4a977eb..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/LanguageValidationResult.java&#010;+++ /dev/null&#010;@@ -1,65 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.io.Serializable;&#010;-&#010;-/**&#010;- * Validation result of parsing a language expression or predicate&#010;- */&#010;-public class LanguageValidationResult implements Serializable {&#010;-    private final String text;&#010;-    private String error;&#010;-    private String shortError;&#010;-    private int index;&#010;-&#010;-    public LanguageValidationResult(String text) {&#010;-        this.text = text;&#010;-    }&#010;-&#010;-    public String getText() {&#010;-        return text;&#010;-    }&#010;-&#010;-    public boolean isSuccess() {&#010;-        return error == null;&#010;-    }&#010;-&#010;-    public void setError(String error) {&#010;-        this.error = error;&#010;-    }&#010;-&#010;-    public String getError() {&#010;-        return error;&#010;-    }&#010;-&#010;-    public String getShortError() {&#010;-        return shortError;&#010;-    }&#010;-&#010;-    public void setShortError(String shortError) {&#010;-        this.shortError = shortError;&#010;-    }&#010;-&#010;-    public int getIndex() {&#010;-        return index;&#010;-    }&#010;-&#010;-    public void setIndex(int index) {&#010;-        this.index = index;&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java&#010;deleted file mode 100644&#010;index b46edab..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/RuntimeCamelCatalog.java&#010;+++ /dev/null&#010;@@ -1,234 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.net.URISyntaxException;&#010;-import java.util.Map;&#010;-&#010;-import org.apache.camel.StaticService;&#010;-&#010;-/**&#010;- * Runtime based CamelCatalog which are included in camel-core that can provided limit CamelCatalog capabilities&#010;- */&#010;-public interface RuntimeCamelCatalog extends StaticService {&#010;-&#010;-    /**&#010;-     * Returns the component information as JSon format.&#010;-     *&#010;-     * @param name the component name&#010;-     * @return component details in JSon&#010;-     */&#010;-    String componentJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the data format information as JSon format.&#010;-     *&#010;-     * @param name the data format name&#010;-     * @return data format details in JSon&#010;-     */&#010;-    String dataFormatJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the language information as JSon format.&#010;-     *&#010;-     * @param name the language name&#010;-     * @return language details in JSon&#010;-     */&#010;-    String languageJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Returns the model information as JSon format.&#010;-     *&#010;-     * @param name the model name&#010;-     * @return model details in JSon&#010;-     */&#010;-    String modelJSonSchema(String name);&#010;-&#010;-    /**&#010;-     * Parses the endpoint uri and constructs a key/value properties of each option&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return properties as key value pairs of each endpoint option&#010;-     */&#010;-    Map&lt;String, String&gt; endpointProperties(String uri) throws URISyntaxException;&#010;-&#010;-    /**&#010;-     * Parses the endpoint uri and constructs a key/value properties of only the lenient properties (eg custom options)&#010;-     * &lt;p/&gt;&#010;-     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return properties as key value pairs of each lenient properties&#010;-     */&#010;-    Map&lt;String, String&gt; endpointLenientProperties(String uri) throws URISyntaxException;&#010;-&#010;-    /**&#010;-     * Validates the pattern whether its a valid time pattern.&#010;-     *&#010;-     * @param pattern  the pattern such as 5000, 5s, 5sec, 4min, 4m30s, 1h, etc.&#010;-     * @return &lt;tt&gt;true&lt;/tt&gt; if valid, &lt;tt&gt;false&lt;/tt&gt; if invalid&#010;-     */&#010;-    boolean validateTimePattern(String pattern);&#010;-&#010;-    /**&#010;-     * Validates the properties for the given scheme against component and endpoint&#010;-     *&#010;-     * @param scheme  the endpoint scheme&#010;-     * @param properties  the endpoint properties&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateProperties(String scheme, Map&lt;String, String&gt; properties);&#010;-&#010;-    /**&#010;-     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateEndpointProperties(String uri);&#010;-&#010;-    /**&#010;-     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;-     * &lt;p/&gt;&#010;-     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;-     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;-     * but in the uri because of using lenient properties.&#010;-     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties);&#010;-&#010;-    /**&#010;-     * Parses and validates the endpoint uri and constructs a key/value properties of each option.&#010;-     * &lt;p/&gt;&#010;-     * The option ignoreLenientProperties can be used to ignore components that uses lenient properties.&#010;-     * When this is true, then the uri validation is stricter but would fail on properties that are not part of the component&#010;-     * but in the uri because of using lenient properties.&#010;-     * For example using the HTTP components to provide query parameters in the endpoint uri.&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @param ignoreLenientProperties  whether to ignore components that uses lenient properties.&#010;-     * @param consumerOnly whether the endpoint is only used as a consumer&#010;-     * @param producerOnly whether the endpoint is only used as a producer&#010;-     * @return validation result&#010;-     */&#010;-    EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties, boolean consumerOnly, boolean producerOnly);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple expression.&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param simple  the simple expression&#010;-     * @return validation result&#010;-     * @deprecated use {@link #validateSimpleExpression(ClassLoader, String)}&#010;-     */&#010;-    @Deprecated&#010;-    SimpleValidationResult validateSimpleExpression(String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple expression.&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param simple  the simple expression&#010;-     * @return validation result&#010;-     */&#010;-    SimpleValidationResult validateSimpleExpression(ClassLoader classLoader, String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple predicate&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param simple  the simple predicate&#010;-     * @return validation result&#010;-     * @deprecated use {@link #validateSimplePredicate(ClassLoader, String)}&#010;-     */&#010;-    @Deprecated&#010;-    SimpleValidationResult validateSimplePredicate(String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the simple predicate&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param simple  the simple predicate&#010;-     * @return validation result&#010;-     */&#010;-    SimpleValidationResult validateSimplePredicate(ClassLoader classLoader, String simple);&#010;-&#010;-    /**&#010;-     * Parses and validates the language as a predicate&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param language the name of the language&#010;-     * @param text  the predicate text&#010;-     * @return validation result&#010;-     */&#010;-    LanguageValidationResult validateLanguagePredicate(ClassLoader classLoader, String language, String text);&#010;-&#010;-    /**&#010;-     * Parses and validates the language as an expression&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Important:&lt;/b&gt; This requires having &lt;tt&gt;camel-core&lt;/tt&gt; and the language dependencies on the classpath&#010;-     *&#010;-     * @param classLoader a custom classloader to use for loading the language from the classpath, or &lt;tt&gt;null&lt;/tt&gt; for using default classloader&#010;-     * @param language the name of the language&#010;-     * @param text  the expression text&#010;-     * @return validation result&#010;-     */&#010;-    LanguageValidationResult validateLanguageExpression(ClassLoader classLoader, String language, String text);&#010;-&#010;-    /**&#010;-     * Returns the component name from the given endpoint uri&#010;-     *&#010;-     * @param uri  the endpoint uri&#010;-     * @return the component name (aka scheme), or &lt;tt&gt;null&lt;/tt&gt; if not possible to determine&#010;-     */&#010;-    String endpointComponentName(String uri);&#010;-&#010;-    /**&#010;-     * Creates an endpoint uri in Java style from the information from the properties&#010;-     *&#010;-     * @param scheme the endpoint schema&#010;-     * @param properties the properties as key value pairs&#010;-     * @param encode whether to URL encode the returned uri or not&#010;-     * @return the constructed endpoint uri&#010;-     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;-     */&#010;-    String asEndpointUri(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;-&#010;-    /**&#010;-     * Creates an endpoint uri in XML style (eg escape &amp; as &amp;ampl;) from the information from the properties&#010;-     *&#010;-     * @param scheme the endpoint schema&#010;-     * @param properties the properties as key value pairs&#010;-     * @param encode whether to URL encode the returned uri or not&#010;-     * @return the constructed endpoint uri&#010;-     * @throws java.net.URISyntaxException is thrown if there is encoding error&#010;-     */&#010;-    String asEndpointUriXml(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException;&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java b/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&#010;deleted file mode 100644&#010;index 5c86f23..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/SimpleValidationResult.java&#010;+++ /dev/null&#010;@@ -1,32 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-/**&#010;- * To be backwards compatible, but favor using {@link LanguageValidationResult} instead.&#010;- */&#010;-public class SimpleValidationResult extends LanguageValidationResult {&#010;-&#010;-    public SimpleValidationResult(String text) {&#010;-        super(text);&#010;-    }&#010;-&#010;-    public String getSimple() {&#010;-        return getText();&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java b/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&#010;deleted file mode 100644&#010;index 057d372..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/SuggestionStrategy.java&#010;+++ /dev/null&#010;@@ -1,34 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.Set;&#010;-&#010;-/**&#010;- * Strategy to provide suggestions for unknown endpoint options&#010;- */&#010;-public interface SuggestionStrategy {&#010;-&#010;-    /**&#010;-     * Provides a list of valid option names for a did you mean function.&#010;-     *&#010;-     * @param names         valid names&#010;-     * @param unknownOption unknown option name&#010;-     * @return a list of suggested names (did you mean)&#010;-     */&#010;-    String[] suggestEndpointOptions(Set&lt;String&gt; names, String unknownOption);&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java b/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&#010;deleted file mode 100644&#010;index 4ed843a..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/TimePatternConverter.java&#010;+++ /dev/null&#010;@@ -1,120 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.regex.Matcher;&#010;-import java.util.regex.Pattern;&#010;-&#010;-/**&#010;- * This class is a copy from camel-core so we can use it independent to validate uris with time patterns&#010;- */&#010;-public final class TimePatternConverter {&#010;-    private static final Pattern NUMBERS_ONLY_STRING_PATTERN = Pattern.compile(""^[-]?(\\d)+$"", Pattern.CASE_INSENSITIVE);&#010;-    private static final Pattern HOUR_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))h(our(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;-    private static final Pattern MINUTES_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))m(in(ute(s)?)?)?"", Pattern.CASE_INSENSITIVE);&#010;-    private static final Pattern SECONDS_REGEX_PATTERN = Pattern.compile(""((\\d)*(\\d))s(ec(ond)?(s)?)?"", Pattern.CASE_INSENSITIVE);&#010;-&#010;-    /**&#010;-     * Utility classes should not have a public constructor.&#010;-     */&#010;-    private TimePatternConverter() {&#010;-    }&#010;-&#010;-    public static long toMilliSeconds(String source) throws IllegalArgumentException {&#010;-        long milliseconds = 0;&#010;-        boolean foundFlag = false;&#010;-&#010;-        checkCorrectnessOfPattern(source);&#010;-        Matcher matcher;&#010;-&#010;-        matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;-        if (matcher.find()) {&#010;-            // Note: This will also be used for regular numeric strings.&#010;-            //       This String -&gt; long converter will be used for all strings.&#010;-            milliseconds = Long.valueOf(source);&#010;-        } else {&#010;-            matcher = createMatcher(HOUR_REGEX_PATTERN, source);&#010;-            if (matcher.find()) {&#010;-                milliseconds = milliseconds + (3600000 * Long.valueOf(matcher.group(1)));&#010;-                foundFlag = true;&#010;-            }&#010;-&#010;-            matcher = createMatcher(MINUTES_REGEX_PATTERN, source);&#010;-            if (matcher.find()) {&#010;-                long minutes = Long.valueOf(matcher.group(1));&#010;-                if ((minutes &gt; 59) &amp;&amp; foundFlag) {&#010;-                    throw new IllegalArgumentException(""Minutes should contain a valid value between 0 and 59: "" + source);&#010;-                }&#010;-                foundFlag = true;&#010;-                milliseconds = milliseconds + (60000 * minutes);&#010;-            }&#010;-&#010;-            matcher = createMatcher(SECONDS_REGEX_PATTERN, source);&#010;-            if (matcher.find()) {&#010;-                long seconds = Long.valueOf(matcher.group(1));&#010;-                if ((seconds &gt; 59) &amp;&amp; foundFlag) {&#010;-                    throw new IllegalArgumentException(""Seconds should contain a valid value between 0 and 59: "" + source);&#010;-                }&#010;-                foundFlag = true;&#010;-                milliseconds = milliseconds + (1000 * seconds);&#010;-            }&#010;-&#010;-            // No pattern matched... initiating fallback check and conversion (if required).&#010;-            // The source at this point may contain illegal values or special characters&#010;-            if (!foundFlag) {&#010;-                milliseconds = Long.valueOf(source);&#010;-            }&#010;-        }&#010;-&#010;-        return milliseconds;&#010;-    }&#010;-&#010;-    private static void checkCorrectnessOfPattern(String source) {&#010;-        //replace only numbers once&#010;-        Matcher matcher = createMatcher(NUMBERS_ONLY_STRING_PATTERN, source);&#010;-        String replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        //replace hour string once&#010;-        matcher = createMatcher(HOUR_REGEX_PATTERN, replaceSource);&#010;-        if (matcher.find() &amp;&amp; matcher.find()) {&#010;-            throw new IllegalArgumentException(""Hours should not be specified more then once: "" + source);&#010;-        }&#010;-        replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        //replace minutes once&#010;-        matcher = createMatcher(MINUTES_REGEX_PATTERN, replaceSource);&#010;-        if (matcher.find() &amp;&amp; matcher.find()) {&#010;-            throw new IllegalArgumentException(""Minutes should not be specified more then once: "" + source);&#010;-        }&#010;-        replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        //replace seconds once&#010;-        matcher = createMatcher(SECONDS_REGEX_PATTERN, replaceSource);&#010;-        if (matcher.find() &amp;&amp; matcher.find()) {&#010;-            throw new IllegalArgumentException(""Seconds should not be specified more then once: "" + source);&#010;-        }&#010;-        replaceSource = matcher.replaceFirst("""");&#010;-&#010;-        if (replaceSource.length() &gt; 0) {&#010;-            throw new IllegalArgumentException(""Illegal characters: "" + source);&#010;-        }&#010;-    }&#010;-&#010;-    private static Matcher createMatcher(Pattern pattern, String source) {&#010;-        return pattern.matcher(source);&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java b/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java&#010;deleted file mode 100644&#010;index ea1ecd5..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/URISupport.java&#010;+++ /dev/null&#010;@@ -1,392 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.io.UnsupportedEncodingException;&#010;-import java.net.URI;&#010;-import java.net.URISyntaxException;&#010;-import java.net.URLDecoder;&#010;-import java.net.URLEncoder;&#010;-import java.util.ArrayList;&#010;-import java.util.Iterator;&#010;-import java.util.LinkedHashMap;&#010;-import java.util.List;&#010;-import java.util.Map;&#010;-&#010;-/**&#010;- * Copied from org.apache.camel.util.URISupport&#010;- */&#010;-public final class URISupport {&#010;-&#010;-    public static final String RAW_TOKEN_START = ""RAW("";&#010;-    public static final String RAW_TOKEN_END = "")"";&#010;-&#010;-    private static final String CHARSET = ""UTF-8"";&#010;-&#010;-    private URISupport() {&#010;-        // Helper class&#010;-    }&#010;-&#010;-    /**&#010;-     * Normalizes the URI so unsafe characters is encoded&#010;-     *&#010;-     * @param uri the input uri&#010;-     * @return as URI instance&#010;-     * @throws URISyntaxException is thrown if syntax error in the input uri&#010;-     */&#010;-    public static URI normalizeUri(String uri) throws URISyntaxException {&#010;-        return new URI(UnsafeUriCharactersEncoder.encode(uri, true));&#010;-    }&#010;-&#010;-    public static Map&lt;String, Object&gt; extractProperties(Map&lt;String, Object&gt; properties, String optionPrefix) {&#010;-        Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;(properties.size());&#010;-&#010;-        for (Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; it = properties.entrySet().iterator(); it.hasNext();) {&#010;-            Map.Entry&lt;String, Object&gt; entry = it.next();&#010;-            String name = entry.getKey();&#010;-            if (name.startsWith(optionPrefix)) {&#010;-                Object value = properties.get(name);&#010;-                name = name.substring(optionPrefix.length());&#010;-                rc.put(name, value);&#010;-                it.remove();&#010;-            }&#010;-        }&#010;-&#010;-        return rc;&#010;-    }&#010;-&#010;-    /**&#010;-     * Strips the query parameters from the uri&#010;-     *&#010;-     * @param uri  the uri&#010;-     * @return the uri without the query parameter&#010;-     */&#010;-    public static String stripQuery(String uri) {&#010;-        int idx = uri.indexOf('?');&#010;-        if (idx &gt; -1) {&#010;-            uri = uri.substring(0, idx);&#010;-        }&#010;-        return uri;&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the query parameters of the uri (eg the query part).&#010;-     *&#010;-     * @param uri the uri&#010;-     * @return the parameters, or an empty map if no parameters (eg never null)&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     */&#010;-    public static Map&lt;String, Object&gt; parseParameters(URI uri) throws URISyntaxException {&#010;-        String query = uri.getQuery();&#010;-        if (query == null) {&#010;-            String schemeSpecificPart = uri.getSchemeSpecificPart();&#010;-            int idx = schemeSpecificPart.indexOf('?');&#010;-            if (idx &lt; 0) {&#010;-                // return an empty map&#010;-                return new LinkedHashMap&lt;String, Object&gt;(0);&#010;-            } else {&#010;-                query = schemeSpecificPart.substring(idx + 1);&#010;-            }&#010;-        } else {&#010;-            query = stripPrefix(query, ""?"");&#010;-        }&#010;-        return parseQuery(query);&#010;-    }&#010;-&#010;-    /**&#010;-     * Strips the prefix from the value.&#010;-     * &lt;p/&gt;&#010;-     * Returns the value as-is if not starting with the prefix.&#010;-     *&#010;-     * @param value  the value&#010;-     * @param prefix the prefix to remove from value&#010;-     * @return the value without the prefix&#010;-     */&#010;-    public static String stripPrefix(String value, String prefix) {&#010;-        if (value != null &amp;&amp; value.startsWith(prefix)) {&#010;-            return value.substring(prefix.length());&#010;-        }&#010;-        return value;&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the query part of the uri (eg the parameters).&#010;-     * &lt;p/&gt;&#010;-     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;-     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;-     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;-     *&#010;-     * @param uri the uri&#010;-     * @return the parameters, or an empty map if no parameters (eg never null)&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     * @see #RAW_TOKEN_START&#010;-     * @see #RAW_TOKEN_END&#010;-     */&#010;-    public static Map&lt;String, Object&gt; parseQuery(String uri) throws URISyntaxException {&#010;-        return parseQuery(uri, false);&#010;-    }&#010;-&#010;-    /**&#010;-     * Parses the query part of the uri (eg the parameters).&#010;-     * &lt;p/&gt;&#010;-     * The URI parameters will by default be URI encoded. However you can define a parameter&#010;-     * values with the syntax: &lt;tt&gt;key=RAW(value)&lt;/tt&gt; which tells Camel to not encode the value,&#010;-     * and use the value as is (eg key=value) and the value has &lt;b&gt;not&lt;/b&gt; been encoded.&#010;-     *&#010;-     * @param uri the uri&#010;-     * @param useRaw whether to force using raw values&#010;-     * @return the parameters, or an empty map if no parameters (eg never null)&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     * @see #RAW_TOKEN_START&#010;-     * @see #RAW_TOKEN_END&#010;-     */&#010;-    public static Map&lt;String, Object&gt; parseQuery(String uri, boolean useRaw) throws URISyntaxException {&#010;-        // must check for trailing &amp; as the uri.split(""&amp;"") will ignore those&#010;-        if (uri != null &amp;&amp; uri.endsWith(""&amp;"")) {&#010;-            throw new URISyntaxException(uri, ""Invalid uri syntax: Trailing &amp; marker found. ""&#010;-                    + ""Check the uri and remove the trailing &amp; marker."");&#010;-        }&#010;-&#010;-        if (isEmpty(uri)) {&#010;-            // return an empty map&#010;-            return new LinkedHashMap&lt;String, Object&gt;(0);&#010;-        }&#010;-&#010;-        // need to parse the uri query parameters manually as we cannot rely on splitting by &amp;,&#010;-        // as &amp; can be used in a parameter value as well.&#010;-&#010;-        try {&#010;-            // use a linked map so the parameters is in the same order&#010;-            Map&lt;String, Object&gt; rc = new LinkedHashMap&lt;String, Object&gt;();&#010;-&#010;-            boolean isKey = true;&#010;-            boolean isValue = false;&#010;-            boolean isRaw = false;&#010;-            StringBuilder key = new StringBuilder();&#010;-            StringBuilder value = new StringBuilder();&#010;-&#010;-            // parse the uri parameters char by char&#010;-            for (int i = 0; i &lt; uri.length(); i++) {&#010;-                // current char&#010;-                char ch = uri.charAt(i);&#010;-                // look ahead of the next char&#010;-                char next;&#010;-                if (i &lt;= uri.length() - 2) {&#010;-                    next = uri.charAt(i + 1);&#010;-                } else {&#010;-                    next = '\u0000';&#010;-                }&#010;-&#010;-                // are we a raw value&#010;-                isRaw = value.toString().startsWith(RAW_TOKEN_START);&#010;-&#010;-                // if we are in raw mode, then we keep adding until we hit the end marker&#010;-                if (isRaw) {&#010;-                    if (isKey) {&#010;-                        key.append(ch);&#010;-                    } else if (isValue) {&#010;-                        value.append(ch);&#010;-                    }&#010;-&#010;-                    // we only end the raw marker if its )&amp; or at the end of the value&#010;-&#010;-                    boolean end = ch == RAW_TOKEN_END.charAt(0) &amp;&amp; (next == '&amp;' || next == '\u0000');&#010;-                    if (end) {&#010;-                        // raw value end, so add that as a parameter, and reset flags&#010;-                        addParameter(key.toString(), value.toString(), rc, useRaw || isRaw);&#010;-                        key.setLength(0);&#010;-                        value.setLength(0);&#010;-                        isKey = true;&#010;-                        isValue = false;&#010;-                        isRaw = false;&#010;-                        // skip to next as we are in raw mode and have already added the value&#010;-                        i++;&#010;-                    }&#010;-                    continue;&#010;-                }&#010;-&#010;-                // if its a key and there is a = sign then the key ends and we are in value mode&#010;-                if (isKey &amp;&amp; ch == '=') {&#010;-                    isKey = false;&#010;-                    isValue = true;&#010;-                    isRaw = false;&#010;-                    continue;&#010;-                }&#010;-&#010;-                // the &amp; denote parameter is ended&#010;-                if (ch == '&amp;') {&#010;-                    // parameter is ended, as we hit &amp; separator&#010;-                    String aKey = key.toString();&#010;-                    // the key may be a placeholder of options which we then do not know what is&#010;-                    boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;-                    if (validKey) {&#010;-                        addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;-                    }&#010;-                    key.setLength(0);&#010;-                    value.setLength(0);&#010;-                    isKey = true;&#010;-                    isValue = false;&#010;-                    isRaw = false;&#010;-                    continue;&#010;-                }&#010;-&#010;-                // regular char so add it to the key or value&#010;-                if (isKey) {&#010;-                    key.append(ch);&#010;-                } else if (isValue) {&#010;-                    value.append(ch);&#010;-                }&#010;-            }&#010;-&#010;-            // any left over parameters, then add that&#010;-            if (key.length() &gt; 0) {&#010;-                String aKey = key.toString();&#010;-                // the key may be a placeholder of options which we then do not know what is&#010;-                boolean validKey = !aKey.startsWith(""{{"") &amp;&amp; !aKey.endsWith(""}}"");&#010;-                if (validKey) {&#010;-                    addParameter(aKey, value.toString(), rc, useRaw || isRaw);&#010;-                }&#010;-            }&#010;-&#010;-            return rc;&#010;-&#010;-        } catch (UnsupportedEncodingException e) {&#010;-            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;-            se.initCause(e);&#010;-            throw se;&#010;-        }&#010;-    }&#010;-&#010;-    @SuppressWarnings(""unchecked"")&#010;-    private static void addParameter(String name, String value, Map&lt;String, Object&gt; map, boolean isRaw) throws UnsupportedEncodingException {&#010;-        name = URLDecoder.decode(name, CHARSET);&#010;-        if (!isRaw) {&#010;-            // need to replace % with %25&#010;-            value = URLDecoder.decode(value.replaceAll(""%"", ""%25""), CHARSET);&#010;-        }&#010;-&#010;-        // does the key already exist?&#010;-        if (map.containsKey(name)) {&#010;-            // yes it does, so make sure we can support multiple values, but using a list&#010;-            // to hold the multiple values&#010;-            Object existing = map.get(name);&#010;-            List&lt;String&gt; list;&#010;-            if (existing instanceof List) {&#010;-                list = (List&lt;String&gt;) existing;&#010;-            } else {&#010;-                // create a new list to hold the multiple values&#010;-                list = new ArrayList&lt;String&gt;();&#010;-                String s = existing != null ? existing.toString() : null;&#010;-                if (s != null) {&#010;-                    list.add(s);&#010;-                }&#010;-            }&#010;-            list.add(value);&#010;-            map.put(name, list);&#010;-        } else {&#010;-            map.put(name, value);&#010;-        }&#010;-    }&#010;-&#010;-    /**&#010;-     * Assembles a query from the given map.&#010;-     *&#010;-     * @param options  the map with the options (eg key/value pairs)&#010;-     * @param ampersand to use &amp; for Java code, and &amp;amp; for XML&#010;-     * @return a query string with &lt;tt&gt;key1=value&amp;key2=value2&amp;...&lt;/tt&gt;, or an empty string if there is no options.&#010;-     * @throws URISyntaxException is thrown if uri has invalid syntax.&#010;-     */&#010;-    public static String createQueryString(Map&lt;String, String&gt; options, String ampersand, boolean encode) throws URISyntaxException {&#010;-        try {&#010;-            if (options.size() &gt; 0) {&#010;-                StringBuilder rc = new StringBuilder();&#010;-                boolean first = true;&#010;-                for (Object o : options.keySet()) {&#010;-                    if (first) {&#010;-                        first = false;&#010;-                    } else {&#010;-                        rc.append(ampersand);&#010;-                    }&#010;-&#010;-                    String key = (String) o;&#010;-                    Object value = options.get(key);&#010;-&#010;-                    // use the value as a String&#010;-                    String s = value != null ? value.toString() : null;&#010;-                    appendQueryStringParameter(key, s, rc, encode);&#010;-                }&#010;-                return rc.toString();&#010;-            } else {&#010;-                return """";&#010;-            }&#010;-        } catch (UnsupportedEncodingException e) {&#010;-            URISyntaxException se = new URISyntaxException(e.toString(), ""Invalid encoding"");&#010;-            se.initCause(e);&#010;-            throw se;&#010;-        }&#010;-    }&#010;-&#010;-    private static void appendQueryStringParameter(String key, String value, StringBuilder rc, boolean encode) throws UnsupportedEncodingException {&#010;-        if (encode) {&#010;-            rc.append(URLEncoder.encode(key, CHARSET));&#010;-        } else {&#010;-            rc.append(key);&#010;-        }&#010;-        // only append if value is not null&#010;-        if (value != null) {&#010;-            rc.append(""="");&#010;-            if (value.startsWith(RAW_TOKEN_START) &amp;&amp; value.endsWith(RAW_TOKEN_END)) {&#010;-                // do not encode RAW parameters&#010;-                rc.append(value);&#010;-            } else {&#010;-                if (encode) {&#010;-                    rc.append(URLEncoder.encode(value, CHARSET));&#010;-                } else {&#010;-                    rc.append(value);&#010;-                }&#010;-            }&#010;-        }&#010;-    }&#010;-&#010;-    /**&#010;-     * Tests whether the value is &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;-     *&#010;-     * @param value  the value, if its a String it will be tested for text length as well&#010;-     * @return true if empty&#010;-     */&#010;-    public static boolean isEmpty(Object value) {&#010;-        return !isNotEmpty(value);&#010;-    }&#010;-&#010;-    /**&#010;-     * Tests whether the value is &lt;b&gt;not&lt;/b&gt; &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;-     *&#010;-     * @param value  the value, if its a String it will be tested for text length as well&#010;-     * @return true if &lt;b&gt;not&lt;/b&gt; empty&#010;-     */&#010;-    public static boolean isNotEmpty(Object value) {&#010;-        if (value == null) {&#010;-            return false;&#010;-        } else if (value instanceof String) {&#010;-            String text = (String) value;&#010;-            return text.trim().length() &gt; 0;&#010;-        } else {&#010;-            return true;&#010;-        }&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java b/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&#010;deleted file mode 100644&#010;index 563bac2..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/UnsafeUriCharactersEncoder.java&#010;+++ /dev/null&#010;@@ -1,206 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.ArrayList;&#010;-import java.util.BitSet;&#010;-import java.util.List;&#010;-import java.util.regex.Matcher;&#010;-import java.util.regex.Pattern;&#010;-&#010;-/**&#010;- * Encoder for unsafe URI characters.&#010;- * &lt;p/&gt;&#010;- * A good source for details is &lt;a href=""http://en.wikipedia.org/wiki/Url_encode""&gt;wikipedia url encode&lt;/a&gt; article.&#010;- */&#010;-public final class UnsafeUriCharactersEncoder {&#010;-    private static BitSet unsafeCharactersRfc1738;&#010;-    private static BitSet unsafeCharactersHttp;&#010;-    private static final char[] HEX_DIGITS = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C',&#010;-        'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f'};&#010;-    private static final Pattern RAW_PATTERN = Pattern.compile(""RAW\\([^\\)]+\\)"");&#010;-&#010;-    static {&#010;-        unsafeCharactersRfc1738 = new BitSet(256);&#010;-        unsafeCharactersRfc1738.set(' ');&#010;-        unsafeCharactersRfc1738.set('""');&#010;-        unsafeCharactersRfc1738.set('&lt;');&#010;-        unsafeCharactersRfc1738.set('&gt;');&#010;-        unsafeCharactersRfc1738.set('#');&#010;-        unsafeCharactersRfc1738.set('%');&#010;-        unsafeCharactersRfc1738.set('{');&#010;-        unsafeCharactersRfc1738.set('}');&#010;-        unsafeCharactersRfc1738.set('|');&#010;-        unsafeCharactersRfc1738.set('\\');&#010;-        unsafeCharactersRfc1738.set('^');&#010;-        unsafeCharactersRfc1738.set('~');&#010;-        unsafeCharactersRfc1738.set('[');&#010;-        unsafeCharactersRfc1738.set(']');&#010;-        unsafeCharactersRfc1738.set('`');&#010;-    }&#010;-&#010;-    static {&#010;-        unsafeCharactersHttp = new BitSet(256);&#010;-        unsafeCharactersHttp.set(' ');&#010;-        unsafeCharactersHttp.set('""');&#010;-        unsafeCharactersHttp.set('&lt;');&#010;-        unsafeCharactersHttp.set('&gt;');&#010;-        unsafeCharactersHttp.set('#');&#010;-        unsafeCharactersHttp.set('%');&#010;-        unsafeCharactersHttp.set('{');&#010;-        unsafeCharactersHttp.set('}');&#010;-        unsafeCharactersHttp.set('|');&#010;-        unsafeCharactersHttp.set('\\');&#010;-        unsafeCharactersHttp.set('^');&#010;-        unsafeCharactersHttp.set('~');&#010;-        unsafeCharactersHttp.set('`');&#010;-    }&#010;-&#010;-    private UnsafeUriCharactersEncoder() {&#010;-        // util class&#010;-    }&#010;-&#010;-    public static String encode(String s) {&#010;-        return encode(s, unsafeCharactersRfc1738);&#010;-    }&#010;-&#010;-    public static String encodeHttpURI(String s) {&#010;-        return encode(s, unsafeCharactersHttp);&#010;-    }&#010;-&#010;-    public static String encode(String s, BitSet unsafeCharacters) {&#010;-        return encode(s, unsafeCharacters, false);&#010;-    }&#010;-&#010;-    public static String encode(String s, boolean checkRaw) {&#010;-        return encode(s, unsafeCharactersRfc1738, checkRaw);&#010;-    }&#010;-&#010;-    public static String encodeHttpURI(String s, boolean checkRaw) {&#010;-        return encode(s, unsafeCharactersHttp, checkRaw);&#010;-    }&#010;-&#010;-    private static List&lt;Pair&gt; checkRAW(String s) {&#010;-        Matcher matcher = RAW_PATTERN.matcher(s);&#010;-        List&lt;Pair&gt; answer = new ArrayList&lt;Pair&gt;();&#010;-        // Check all occurrences&#010;-        while (matcher.find()) {&#010;-            answer.add(new Pair(matcher.start(), matcher.end()));&#010;-        }&#010;-        return answer;&#010;-    }&#010;-&#010;-    private static boolean isRaw(int index, List&lt;Pair&gt; pairs) {&#010;-        for (Pair pair : pairs) {&#010;-            if (index &lt; pair.left) {&#010;-                return false;&#010;-            } else {&#010;-                if (index &gt;= pair.left) {&#010;-                    if (index &lt;= pair.right) {&#010;-                        return true;&#010;-                    } else {&#010;-                        continue;&#010;-                    }&#010;-                }&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    private static class Pair {&#010;-        int left;&#010;-        int right;&#010;-&#010;-        Pair(int left, int right) {&#010;-            this.left = left;&#010;-            this.right = right;&#010;-        }&#010;-    }&#010;-&#010;-    // Just skip the encode for isRAW part&#010;-    public static String encode(String s, BitSet unsafeCharacters, boolean checkRaw) {&#010;-        List&lt;Pair&gt; rawPairs;&#010;-        if (checkRaw) {&#010;-            rawPairs = checkRAW(s);&#010;-        } else {&#010;-            rawPairs = new ArrayList&lt;Pair&gt;();&#010;-        }&#010;-&#010;-        int n = s == null ? 0 : s.length();&#010;-        if (n == 0) {&#010;-            return s;&#010;-        }&#010;-&#010;-        // First check whether we actually need to encode&#010;-        char chars[] = s.toCharArray();&#010;-        for (int i = 0;;) {&#010;-            // just deal with the ascii character&#010;-            if (chars[i] &gt; 0 &amp;&amp; chars[i] &lt; 128) {&#010;-                if (unsafeCharacters.get(chars[i])) {&#010;-                    break;&#010;-                }&#010;-            }&#010;-            if (++i &gt;= chars.length) {&#010;-                return s;&#010;-            }&#010;-        }&#010;-&#010;-        // okay there are some unsafe characters so we do need to encode&#010;-        // see details at: http://en.wikipedia.org/wiki/Url_encode&#010;-        StringBuilder sb = new StringBuilder();&#010;-        for (int i = 0; i &lt; chars.length; i++) {&#010;-            char ch = chars[i];&#010;-            if (ch &gt; 0 &amp;&amp; ch &lt; 128 &amp;&amp; unsafeCharacters.get(ch)) {&#010;-                // special for % sign as it may be a decimal encoded value&#010;-                if (ch == '%') {&#010;-                    char next = i + 1 &lt; chars.length ? chars[i + 1] : ' ';&#010;-                    char next2 = i + 2 &lt; chars.length ? chars[i + 2] : ' ';&#010;-&#010;-                    if (isHexDigit(next) &amp;&amp; isHexDigit(next2) &amp;&amp; !isRaw(i, rawPairs)) {&#010;-                        // its already encoded (decimal encoded) so just append as is&#010;-                        sb.append(ch);&#010;-                    } else {&#010;-                        // must escape then, as its an unsafe character&#010;-                        appendEscape(sb, (byte) ch);&#010;-                    }&#010;-                } else {&#010;-                    // must escape then, as its an unsafe character&#010;-                    appendEscape(sb, (byte) ch);&#010;-                }&#010;-            } else {&#010;-                sb.append(ch);&#010;-            }&#010;-        }&#010;-        return sb.toString();&#010;-    }&#010;-&#010;-    private static void appendEscape(StringBuilder sb, byte b) {&#010;-        sb.append('%');&#010;-        sb.append(HEX_DIGITS[(b &gt;&gt; 4) &amp; 0x0f]);&#010;-        sb.append(HEX_DIGITS[(b &gt;&gt; 0) &amp; 0x0f]);&#010;-    }&#010;-&#010;-    private static boolean isHexDigit(char ch) {&#010;-        for (char hex : HEX_DIGITS) {&#010;-            if (hex == ch) {&#010;-                return true;&#010;-            }&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/package.html&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/package.html b/camel-core/src/main/java/org/apache/camel/catalog/package.html&#010;deleted file mode 100644&#010;index 98786d1..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/package.html&#010;+++ /dev/null&#010;@@ -1,25 +0,0 @@&#010;-&lt;!--&#010;-    Licensed to the Apache Software Foundation (ASF) under one or more&#010;-    contributor license agreements.  See the NOTICE file distributed with&#010;-    this work for additional information regarding copyright ownership.&#010;-    The ASF licenses this file to You under the Apache License, Version 2.0&#010;-    (the ""License""); you may not use this file except in compliance with&#010;-    the License.  You may obtain a copy of the License at&#010;-&#010;-    http://www.apache.org/licenses/LICENSE-2.0&#010;-&#010;-    Unless required by applicable law or agreed to in writing, software&#010;-    distributed under the License is distributed on an ""AS IS"" BASIS,&#010;-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;-    See the License for the specific language governing permissions and&#010;-    limitations under the License.&#010;---&gt;&#010;-&lt;html&gt;&#010;-&lt;head&gt;&#010;-&lt;/head&gt;&#010;-&lt;body&gt;&#010;-&#010;-Camel Catalog&#010;-&#010;-&lt;/body&gt;&#010;-&lt;/html&gt;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java b/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;index 5d19e0d..4013e5f 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/component/rest/RestComponentVerifier.java&#010;@@ -22,12 +22,12 @@ import java.util.Map;&#010; import org.apache.camel.Component;&#010; import org.apache.camel.ComponentVerifier;&#010; import org.apache.camel.VerifiableComponent;&#010;-import org.apache.camel.catalog.JSonSchemaHelper;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010; import org.apache.camel.impl.verifier.CatalogVerifierCustomizer;&#010; import org.apache.camel.impl.verifier.DefaultComponentVerifier;&#010; import org.apache.camel.impl.verifier.ResultBuilder;&#010; import org.apache.camel.impl.verifier.ResultErrorBuilder;&#010;+import org.apache.camel.runtimecatalog.JSonSchemaHelper;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.RestConsumerFactory;&#010; import org.apache.camel.spi.RestProducerFactory;&#010; import org.apache.camel.util.ObjectHelper;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;index c85ce8c..b53efc8 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/impl/DefaultCamelContext.java&#010;@@ -26,7 +26,6 @@ import java.util.Collections;&#010; import java.util.Comparator;&#010; import java.util.Date;&#010; import java.util.HashMap;&#010;-import java.util.HashSet;&#010; import java.util.Iterator;&#010; import java.util.LinkedHashMap;&#010; import java.util.LinkedHashSet;&#010;@@ -87,8 +86,6 @@ import org.apache.camel.api.management.mbean.ManagedRouteMBean;&#010; import org.apache.camel.builder.DefaultFluentProducerTemplate;&#010; import org.apache.camel.builder.ErrorHandlerBuilder;&#010; import org.apache.camel.builder.ErrorHandlerBuilderSupport;&#010;-import org.apache.camel.catalog.DefaultRuntimeCamelCatalog;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010; import org.apache.camel.component.properties.PropertiesComponent;&#010; import org.apache.camel.impl.converter.BaseTypeConverterRegistry;&#010; import org.apache.camel.impl.converter.DefaultTypeConverter;&#010;@@ -121,6 +118,8 @@ import org.apache.camel.processor.interceptor.Delayer;&#010; import org.apache.camel.processor.interceptor.HandleFault;&#010; import org.apache.camel.processor.interceptor.StreamCaching;&#010; import org.apache.camel.processor.interceptor.Tracer;&#010;+import org.apache.camel.runtimecatalog.DefaultRuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.AsyncProcessorAwaitManager;&#010; import org.apache.camel.spi.CamelContextNameStrategy;&#010; import org.apache.camel.spi.ClassResolver;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java b/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;index b9d9998..f05cdb1 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/impl/verifier/DefaultComponentVerifier.java&#010;@@ -25,8 +25,8 @@ import org.apache.camel.CamelContext;&#010; import org.apache.camel.ComponentVerifier;&#010; import org.apache.camel.NoSuchOptionException;&#010; import org.apache.camel.TypeConverter;&#010;-import org.apache.camel.catalog.EndpointValidationResult;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.EndpointValidationResult;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.util.CamelContextHelper;&#010; import org.apache.camel.util.EndpointHelper;&#010; import org.apache.camel.util.IntrospectionSupport;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;index a09ff7d..9a70390 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/management/DefaultManagementLifecycleStrategy.java&#010;@@ -46,12 +46,9 @@ import org.apache.camel.StartupListener;&#010; import org.apache.camel.TimerListener;&#010; import org.apache.camel.VetoCamelContextStartException;&#010; import org.apache.camel.api.management.PerformanceCounter;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010; import org.apache.camel.impl.ConsumerCache;&#010; import org.apache.camel.impl.DefaultCamelContext;&#010; import org.apache.camel.impl.DefaultEndpointRegistry;&#010;-import org.apache.camel.impl.DefaultTransformerRegistry;&#010;-import org.apache.camel.impl.DefaultValidatorRegistry;&#010; import org.apache.camel.impl.EventDrivenConsumerRoute;&#010; import org.apache.camel.impl.ProducerCache;&#010; import org.apache.camel.impl.ThrottlingExceptionRoutePolicy;&#010;@@ -89,6 +86,7 @@ import org.apache.camel.processor.CamelInternalProcessor;&#010; import org.apache.camel.processor.interceptor.BacklogDebugger;&#010; import org.apache.camel.processor.interceptor.BacklogTracer;&#010; import org.apache.camel.processor.interceptor.Tracer;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.AsyncProcessorAwaitManager;&#010; import org.apache.camel.spi.DataFormat;&#010; import org.apache.camel.spi.EventNotifier;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;index 20d3f28..6a99656 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/management/mbean/ManagedRuntimeCamelCatalog.java&#010;@@ -19,7 +19,7 @@ package org.apache.camel.management.mbean;&#010; import org.apache.camel.CamelContext;&#010; import org.apache.camel.api.management.ManagedResource;&#010; import org.apache.camel.api.management.mbean.ManagedRuntimeCamelCatalogMBean;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.ManagementStrategy;&#010; &#010; /**&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C6a3e7fae5cba4f918aede10c3ae6ef26%40git.apache.org%3E,2017-04-14 10:52,commits,6.0,326.0,  [5/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
26,327.0,davscl...@apache.org,"Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/c66be7a8&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/c66be7a8&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/c66be7a8&#010;&#010;Branch: refs/heads/master&#010;Commit: c66be7a8c21de8944fd86888a2cf039eb97a2ff1&#010;Parents: d726964&#010;Author: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Authored: Fri Apr 14 12:08:59 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:52:40 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; .../java/org/apache/camel/CamelContext.java     |    2 +-&#010; .../camel/catalog/AbstractCamelCatalog.java     | 1294 ------------------&#010; .../catalog/CamelContextJSonSchemaResolver.java |   80 --&#010; .../org/apache/camel/catalog/CatalogHelper.java |  179 ---&#010; .../camel/catalog/CollectionStringBuffer.java   |   57 -&#010; .../catalog/DefaultRuntimeCamelCatalog.java     |  136 --&#010; .../camel/catalog/EndpointValidationResult.java |  451 ------&#010; .../apache/camel/catalog/JSonSchemaHelper.java  |  424 ------&#010; .../camel/catalog/JSonSchemaResolver.java       |   64 -&#010; .../camel/catalog/LanguageValidationResult.java |   65 -&#010; .../camel/catalog/RuntimeCamelCatalog.java      |  234 ----&#010; .../camel/catalog/SimpleValidationResult.java   |   32 -&#010; .../camel/catalog/SuggestionStrategy.java       |   34 -&#010; .../camel/catalog/TimePatternConverter.java     |  120 --&#010; .../org/apache/camel/catalog/URISupport.java    |  392 ------&#010; .../catalog/UnsafeUriCharactersEncoder.java     |  206 ---&#010; .../java/org/apache/camel/catalog/package.html  |   25 -&#010; .../component/rest/RestComponentVerifier.java   |    4 +-&#010; .../apache/camel/impl/DefaultCamelContext.java  |    5 +-&#010; .../impl/verifier/DefaultComponentVerifier.java |    4 +-&#010; .../DefaultManagementLifecycleStrategy.java     |    4 +-&#010; .../mbean/ManagedRuntimeCamelCatalog.java       |    2 +-&#010; .../runtimecatalog/AbstractCamelCatalog.java    | 1294 ++++++++++++++++++&#010; .../CamelContextJSonSchemaResolver.java         |   80 ++&#010; .../camel/runtimecatalog/CatalogHelper.java     |  179 +++&#010; .../runtimecatalog/CollectionStringBuffer.java  |   57 +&#010; .../DefaultRuntimeCamelCatalog.java             |  136 ++&#010; .../EndpointValidationResult.java               |  451 ++++++&#010; .../camel/runtimecatalog/JSonSchemaHelper.java  |  424 ++++++&#010; .../runtimecatalog/JSonSchemaResolver.java      |   64 +&#010; .../LanguageValidationResult.java               |   65 +&#010; .../runtimecatalog/RuntimeCamelCatalog.java     |  234 ++++&#010; .../runtimecatalog/SimpleValidationResult.java  |   32 +&#010; .../runtimecatalog/SuggestionStrategy.java      |   34 +&#010; .../runtimecatalog/TimePatternConverter.java    |  120 ++&#010; .../apache/camel/runtimecatalog/URISupport.java |  392 ++++++&#010; .../UnsafeUriCharactersEncoder.java             |  206 +++&#010; .../apache/camel/runtimecatalog/package.html    |   25 +&#010; .../org/apache/camel/util/EndpointHelper.java   |    6 +-&#010; .../camel/catalog/AbstractCamelCatalogTest.java |  104 --&#010; .../camel/catalog/RuntimeCamelCatalogTest.java  |  393 ------&#010; .../AbstractCamelCatalogTest.java               |  104 ++&#010; .../runtimecatalog/RuntimeCamelCatalogTest.java |  393 ++++++&#010; 43 files changed, 4302 insertions(+), 4305 deletions(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/CamelContext.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/CamelContext.java b/camel-core/src/main/java/org/apache/camel/CamelContext.java&#010;index d4fd6ae..00702d1 100644&#010;--- a/camel-core/src/main/java/org/apache/camel/CamelContext.java&#010;+++ b/camel-core/src/main/java/org/apache/camel/CamelContext.java&#010;@@ -30,7 +30,6 @@ import org.apache.camel.api.management.mbean.ManagedCamelContextMBean;&#010; import org.apache.camel.api.management.mbean.ManagedProcessorMBean;&#010; import org.apache.camel.api.management.mbean.ManagedRouteMBean;&#010; import org.apache.camel.builder.ErrorHandlerBuilder;&#010;-import org.apache.camel.catalog.RuntimeCamelCatalog;&#010; import org.apache.camel.model.DataFormatDefinition;&#010; import org.apache.camel.model.HystrixConfigurationDefinition;&#010; import org.apache.camel.model.ProcessorDefinition;&#010;@@ -41,6 +40,7 @@ import org.apache.camel.model.rest.RestDefinition;&#010; import org.apache.camel.model.rest.RestsDefinition;&#010; import org.apache.camel.model.transformer.TransformerDefinition;&#010; import org.apache.camel.model.validator.ValidatorDefinition;&#010;+import org.apache.camel.runtimecatalog.RuntimeCamelCatalog;&#010; import org.apache.camel.spi.AsyncProcessorAwaitManager;&#010; import org.apache.camel.spi.CamelContextNameStrategy;&#010; import org.apache.camel.spi.ClassResolver;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/AbstractCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/AbstractCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/catalog/AbstractCamelCatalog.java&#010;deleted file mode 100644&#010;index 6511eff..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/AbstractCamelCatalog.java&#010;+++ /dev/null&#010;@@ -1,1294 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.lang.reflect.InvocationTargetException;&#010;-import java.lang.reflect.Method;&#010;-import java.net.URI;&#010;-import java.net.URISyntaxException;&#010;-import java.util.ArrayList;&#010;-import java.util.Arrays;&#010;-import java.util.HashMap;&#010;-import java.util.Iterator;&#010;-import java.util.LinkedHashMap;&#010;-import java.util.LinkedHashSet;&#010;-import java.util.List;&#010;-import java.util.Map;&#010;-import java.util.Objects;&#010;-import java.util.Set;&#010;-import java.util.TreeMap;&#010;-import java.util.regex.Matcher;&#010;-import java.util.regex.Pattern;&#010;-&#010;-import static org.apache.camel.catalog.CatalogHelper.after;&#010;-import static org.apache.camel.catalog.JSonSchemaHelper.getNames;&#010;-import static org.apache.camel.catalog.JSonSchemaHelper.getPropertyDefaultValue;&#010;-import static org.apache.camel.catalog.JSonSchemaHelper.getPropertyEnum;&#010;-import static org.apache.camel.catalog.JSonSchemaHelper.getPropertyKind;&#010;-import static org.apache.camel.catalog.JSonSchemaHelper.getPropertyNameFromNameWithPrefix;&#010;-import static org.apache.camel.catalog.JSonSchemaHelper.getPropertyPrefix;&#010;-import static org.apache.camel.catalog.JSonSchemaHelper.getRow;&#010;-import static org.apache.camel.catalog.JSonSchemaHelper.isComponentConsumerOnly;&#010;-import static org.apache.camel.catalog.JSonSchemaHelper.isComponentLenientProperties;&#010;-import static org.apache.camel.catalog.JSonSchemaHelper.isComponentProducerOnly;&#010;-import static org.apache.camel.catalog.JSonSchemaHelper.isPropertyBoolean;&#010;-import static org.apache.camel.catalog.JSonSchemaHelper.isPropertyConsumerOnly;&#010;-import static org.apache.camel.catalog.JSonSchemaHelper.isPropertyInteger;&#010;-import static org.apache.camel.catalog.JSonSchemaHelper.isPropertyMultiValue;&#010;-import static org.apache.camel.catalog.JSonSchemaHelper.isPropertyNumber;&#010;-import static org.apache.camel.catalog.JSonSchemaHelper.isPropertyObject;&#010;-import static org.apache.camel.catalog.JSonSchemaHelper.isPropertyProducerOnly;&#010;-import static org.apache.camel.catalog.JSonSchemaHelper.isPropertyRequired;&#010;-import static org.apache.camel.catalog.JSonSchemaHelper.stripOptionalPrefixFromName;&#010;-import static org.apache.camel.catalog.URISupport.createQueryString;&#010;-import static org.apache.camel.catalog.URISupport.isEmpty;&#010;-import static org.apache.camel.catalog.URISupport.normalizeUri;&#010;-import static org.apache.camel.catalog.URISupport.stripQuery;&#010;-&#010;-/**&#010;- * Base class for both the runtime RuntimeCamelCatalog from camel-core and the complete CamelCatalog from camel-catalog.&#010;- */&#010;-public abstract class AbstractCamelCatalog {&#010;-&#010;-    // CHECKSTYLE:OFF&#010;-&#010;-    private static final Pattern SYNTAX_PATTERN = Pattern.compile(""(\\w+)"");&#010;-&#010;-    private SuggestionStrategy suggestionStrategy;&#010;-    private JSonSchemaResolver jsonSchemaResolver;&#010;-&#010;-    public SuggestionStrategy getSuggestionStrategy() {&#010;-        return suggestionStrategy;&#010;-    }&#010;-&#010;-    public void setSuggestionStrategy(SuggestionStrategy suggestionStrategy) {&#010;-        this.suggestionStrategy = suggestionStrategy;&#010;-    }&#010;-&#010;-    public JSonSchemaResolver getJSonSchemaResolver() {&#010;-        return jsonSchemaResolver;&#010;-    }&#010;-&#010;-    public void setJSonSchemaResolver(JSonSchemaResolver resolver) {&#010;-        this.jsonSchemaResolver = resolver;&#010;-    }&#010;-&#010;-    public boolean validateTimePattern(String pattern) {&#010;-        return validateInteger(pattern);&#010;-    }&#010;-&#010;-    public EndpointValidationResult validateEndpointProperties(String uri) {&#010;-        return validateEndpointProperties(uri, false, false, false);&#010;-    }&#010;-&#010;-    public EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties) {&#010;-        return validateEndpointProperties(uri, ignoreLenientProperties, false, false);&#010;-    }&#010;-&#010;-    public EndpointValidationResult validateProperties(String scheme, Map&lt;String, String&gt; properties) {&#010;-        EndpointValidationResult result = new EndpointValidationResult(scheme);&#010;-&#010;-        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;-        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;-        List&lt;Map&lt;String, String&gt;&gt; componentProps = JSonSchemaHelper.parseJsonSchema(""componentProperties"", json, true);&#010;-&#010;-        // endpoint options have higher priority so remove those from component&#010;-        // that may clash&#010;-        componentProps.stream()&#010;-            .filter(c -&gt; rows.stream().noneMatch(e -&gt; Objects.equals(e.get(""name""), c.get(""name""))))&#010;-            .forEach(rows::add);&#010;-&#010;-        boolean lenient = Boolean.getBoolean(properties.getOrDefault(""lenient"", ""false""));&#010;-&#010;-        // the dataformat component refers to a data format so lets add the properties for the selected&#010;-        // data format to the list of rows&#010;-        if (""dataformat"".equals(scheme)) {&#010;-            String dfName = properties.get(""name"");&#010;-            if (dfName != null) {&#010;-                String dfJson = jsonSchemaResolver.getDataFormatJSonSchema(dfName);&#010;-                List&lt;Map&lt;String, String&gt;&gt; dfRows = JSonSchemaHelper.parseJsonSchema(""properties"", dfJson, true);&#010;-                if (dfRows != null &amp;&amp; !dfRows.isEmpty()) {&#010;-                    rows.addAll(dfRows);&#010;-                }&#010;-            }&#010;-        }&#010;-&#010;-        for (Map.Entry&lt;String, String&gt; property : properties.entrySet()) {&#010;-            String value = property.getValue();&#010;-            String originalName = property.getKey();&#010;-            String name = property.getKey();&#010;-            // the name may be using an optional prefix, so lets strip that because the options&#010;-            // in the schema are listed without the prefix&#010;-            name = stripOptionalPrefixFromName(rows, name);&#010;-            // the name may be using a prefix, so lets see if we can find the real property name&#010;-            String propertyName = getPropertyNameFromNameWithPrefix(rows, name);&#010;-            if (propertyName != null) {&#010;-                name = propertyName;&#010;-            }&#010;-&#010;-            String prefix = getPropertyPrefix(rows, name);&#010;-            String kind = getPropertyKind(rows, name);&#010;-            boolean namePlaceholder = name.startsWith(""{{"") &amp;&amp; name.endsWith(""}}"");&#010;-            boolean valuePlaceholder = value.startsWith(""{{"") || value.startsWith(""${"") || value.startsWith(""$simple{"");&#010;-            boolean lookup = value.startsWith(""#"") &amp;&amp; value.length() &gt; 1;&#010;-            // we cannot evaluate multi values as strict as the others, as we don't know their expected types&#010;-            boolean multiValue = prefix != null &amp;&amp; originalName.startsWith(prefix) &amp;&amp; isPropertyMultiValue(rows, name);&#010;-&#010;-            Map&lt;String, String&gt; row = getRow(rows, name);&#010;-            if (row == null) {&#010;-                // unknown option&#010;-&#010;-                // only add as error if the component is not lenient properties, or not stub component&#010;-                // and the name is not a property placeholder for one or more values&#010;-                if (!namePlaceholder &amp;&amp; !""stub"".equals(scheme)) {&#010;-                    if (lenient) {&#010;-                        // as if we are lenient then the option is a dynamic extra option which we cannot validate&#010;-                        result.addLenient(name);&#010;-                    } else {&#010;-                        // its unknown&#010;-                        result.addUnknown(name);&#010;-                        if (suggestionStrategy != null) {&#010;-                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(getNames(rows), name);&#010;-                            if (suggestions != null) {&#010;-                                result.addUnknownSuggestions(name, suggestions);&#010;-                            }&#010;-                        }&#010;-                    }&#010;-                }&#010;-            } else {&#010;-                /* TODO: we may need to add something in the properties to know if they are related to a producer or consumer&#010;-                if (""parameter"".equals(kind)) {&#010;-                    // consumer only or producer only mode for parameters&#010;-                    if (consumerOnly) {&#010;-                        boolean producer = isPropertyProducerOnly(rows, name);&#010;-                        if (producer) {&#010;-                            // the option is only for producer so you cannot use it in consumer mode&#010;-                            result.addNotConsumerOnly(name);&#010;-                        }&#010;-                    } else if (producerOnly) {&#010;-                        boolean consumer = isPropertyConsumerOnly(rows, name);&#010;-                        if (consumer) {&#010;-                            // the option is only for consumer so you cannot use it in producer mode&#010;-                            result.addNotProducerOnly(name);&#010;-                        }&#010;-                    }&#010;-                }&#010;-                */&#010;-&#010;-                // default value&#010;-                String defaultValue = getPropertyDefaultValue(rows, name);&#010;-                if (defaultValue != null) {&#010;-                    result.addDefaultValue(name, defaultValue);&#010;-                }&#010;-&#010;-                // is required but the value is empty&#010;-                boolean required = isPropertyRequired(rows, name);&#010;-                if (required &amp;&amp; isEmpty(value)) {&#010;-                    result.addRequired(name);&#010;-                }&#010;-&#010;-                // is enum but the value is not within the enum range&#010;-                // but we can only check if the value is not a placeholder&#010;-                String enums = getPropertyEnum(rows, name);&#010;-                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; enums != null) {&#010;-                    String[] choices = enums.split("","");&#010;-                    boolean found = false;&#010;-                    for (String s : choices) {&#010;-                        if (value.equalsIgnoreCase(s)) {&#010;-                            found = true;&#010;-                            break;&#010;-                        }&#010;-                    }&#010;-                    if (!found) {&#010;-                        result.addInvalidEnum(name, value);&#010;-                        result.addInvalidEnumChoices(name, choices);&#010;-                        if (suggestionStrategy != null) {&#010;-                            Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;();&#010;-                            names.addAll(Arrays.asList(choices));&#010;-                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(names, value);&#010;-                            if (suggestions != null) {&#010;-                                result.addInvalidEnumSuggestions(name, suggestions);&#010;-                            }&#010;-                        }&#010;-&#010;-                    }&#010;-                }&#010;-&#010;-                // is reference lookup of bean (not applicable for @UriPath, enums, or multi-valued)&#010;-                if (!multiValue &amp;&amp; enums == null &amp;&amp; !""path"".equals(kind) &amp;&amp; isPropertyObject(rows, name)) {&#010;-                    // must start with # and be at least 2 characters&#010;-                    if (!value.startsWith(""#"") || value.length() &lt;= 1) {&#010;-                        result.addInvalidReference(name, value);&#010;-                    }&#010;-                }&#010;-&#010;-                // is boolean&#010;-                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyBoolean(rows, name)) {&#010;-                    // value must be a boolean&#010;-                    boolean bool = ""true"".equalsIgnoreCase(value) || ""false"".equalsIgnoreCase(value);&#010;-                    if (!bool) {&#010;-                        result.addInvalidBoolean(name, value);&#010;-                    }&#010;-                }&#010;-&#010;-                // is integer&#010;-                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyInteger(rows, name)) {&#010;-                    // value must be an integer&#010;-                    boolean valid = validateInteger(value);&#010;-                    if (!valid) {&#010;-                        result.addInvalidInteger(name, value);&#010;-                    }&#010;-                }&#010;-&#010;-                // is number&#010;-                if (!multiValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyNumber(rows, name)) {&#010;-                    // value must be an number&#010;-                    boolean valid = false;&#010;-                    try {&#010;-                        valid = !Double.valueOf(value).isNaN() || !Float.valueOf(value).isNaN();&#010;-                    } catch (Exception e) {&#010;-                        // ignore&#010;-                    }&#010;-                    if (!valid) {&#010;-                        result.addInvalidNumber(name, value);&#010;-                    }&#010;-                }&#010;-            }&#010;-        }&#010;-&#010;-        // now check if all required values are there, and that a default value does not exists&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String name = row.get(""name"");&#010;-            boolean required = isPropertyRequired(rows, name);&#010;-            if (required) {&#010;-                String value = properties.get(name);&#010;-                if (isEmpty(value)) {&#010;-                    value = getPropertyDefaultValue(rows, name);&#010;-                }&#010;-                if (isEmpty(value)) {&#010;-                    result.addRequired(name);&#010;-                }&#010;-            }&#010;-        }&#010;-&#010;-        return result;&#010;-    }&#010;-&#010;-    public EndpointValidationResult validateEndpointProperties(String uri, boolean ignoreLenientProperties, boolean consumerOnly, boolean producerOnly) {&#010;-        EndpointValidationResult result = new EndpointValidationResult(uri);&#010;-&#010;-        Map&lt;String, String&gt; properties;&#010;-        List&lt;Map&lt;String, String&gt;&gt; rows;&#010;-        boolean lenientProperties;&#010;-        String scheme;&#010;-&#010;-        try {&#010;-            String json = null;&#010;-&#010;-            // parse the uri&#010;-            URI u = normalizeUri(uri);&#010;-            scheme = u.getScheme();&#010;-&#010;-            if (scheme != null) {&#010;-                json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;-            }&#010;-            if (json == null) {&#010;-                // if the uri starts with a placeholder then we are also incapable of parsing it as we wasn't able to resolve the component name&#010;-                if (uri.startsWith(""{{"")) {&#010;-                    result.addIncapable(uri);&#010;-                } else if (scheme != null) {&#010;-                    result.addUnknownComponent(scheme);&#010;-                } else {&#010;-                    result.addUnknownComponent(uri);&#010;-                }&#010;-                return result;&#010;-            }&#010;-&#010;-            rows = JSonSchemaHelper.parseJsonSchema(""component"", json, false);&#010;-&#010;-            // is the component capable of both consumer and producer?&#010;-            boolean canConsumeAndProduce = false;&#010;-            if (!isComponentConsumerOnly(rows) &amp;&amp; !isComponentProducerOnly(rows)) {&#010;-                canConsumeAndProduce = true;&#010;-            }&#010;-&#010;-            if (canConsumeAndProduce &amp;&amp; consumerOnly) {&#010;-                // lenient properties is not support in consumer only mode if the component can do both of them&#010;-                lenientProperties = false;&#010;-            } else {&#010;-                // only enable lenient properties if we should not ignore&#010;-                lenientProperties = !ignoreLenientProperties &amp;&amp; isComponentLenientProperties(rows);&#010;-            }&#010;-            rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;-            properties = endpointProperties(uri);&#010;-        } catch (URISyntaxException e) {&#010;-            if (uri.startsWith(""{{"")) {&#010;-                // if the uri starts with a placeholder then we are also incapable of parsing it as we wasn't able to resolve the component name&#010;-                result.addIncapable(uri);&#010;-            } else {&#010;-                result.addSyntaxError(e.getMessage());&#010;-            }&#010;-&#010;-            return result;&#010;-        }&#010;-&#010;-        // the dataformat component refers to a data format so lets add the properties for the selected&#010;-        // data format to the list of rows&#010;-        if (""dataformat"".equals(scheme)) {&#010;-            String dfName = properties.get(""name"");&#010;-            if (dfName != null) {&#010;-                String dfJson = jsonSchemaResolver.getDataFormatJSonSchema(dfName);&#010;-                List&lt;Map&lt;String, String&gt;&gt; dfRows = JSonSchemaHelper.parseJsonSchema(""properties"", dfJson, true);&#010;-                if (dfRows != null &amp;&amp; !dfRows.isEmpty()) {&#010;-                    rows.addAll(dfRows);&#010;-                }&#010;-            }&#010;-        }&#010;-&#010;-        for (Map.Entry&lt;String, String&gt; property : properties.entrySet()) {&#010;-            String value = property.getValue();&#010;-            String originalName = property.getKey();&#010;-            String name = property.getKey();&#010;-            // the name may be using an optional prefix, so lets strip that because the options&#010;-            // in the schema are listed without the prefix&#010;-            name = stripOptionalPrefixFromName(rows, name);&#010;-            // the name may be using a prefix, so lets see if we can find the real property name&#010;-            String propertyName = getPropertyNameFromNameWithPrefix(rows, name);&#010;-            if (propertyName != null) {&#010;-                name = propertyName;&#010;-            }&#010;-&#010;-            String prefix = getPropertyPrefix(rows, name);&#010;-            String kind = getPropertyKind(rows, name);&#010;-            boolean namePlaceholder = name.startsWith(""{{"") &amp;&amp; name.endsWith(""}}"");&#010;-            boolean valuePlaceholder = value.startsWith(""{{"") || value.startsWith(""${"") || value.startsWith(""$simple{"");&#010;-            boolean lookup = value.startsWith(""#"") &amp;&amp; value.length() &gt; 1;&#010;-            // we cannot evaluate multi values as strict as the others, as we don't know their expected types&#010;-            boolean mulitValue = prefix != null &amp;&amp; originalName.startsWith(prefix) &amp;&amp; isPropertyMultiValue(rows, name);&#010;-&#010;-            Map&lt;String, String&gt; row = getRow(rows, name);&#010;-            if (row == null) {&#010;-                // unknown option&#010;-&#010;-                // only add as error if the component is not lenient properties, or not stub component&#010;-                // and the name is not a property placeholder for one or more values&#010;-                if (!namePlaceholder &amp;&amp; !""stub"".equals(scheme)) {&#010;-                    if (lenientProperties) {&#010;-                        // as if we are lenient then the option is a dynamic extra option which we cannot validate&#010;-                        result.addLenient(name);&#010;-                    } else {&#010;-                        // its unknown&#010;-                        result.addUnknown(name);&#010;-                        if (suggestionStrategy != null) {&#010;-                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(getNames(rows), name);&#010;-                            if (suggestions != null) {&#010;-                                result.addUnknownSuggestions(name, suggestions);&#010;-                            }&#010;-                        }&#010;-                    }&#010;-                }&#010;-            } else {&#010;-                if (""parameter"".equals(kind)) {&#010;-                    // consumer only or producer only mode for parameters&#010;-                    if (consumerOnly) {&#010;-                        boolean producer = isPropertyProducerOnly(rows, name);&#010;-                        if (producer) {&#010;-                            // the option is only for producer so you cannot use it in consumer mode&#010;-                            result.addNotConsumerOnly(name);&#010;-                        }&#010;-                    } else if (producerOnly) {&#010;-                        boolean consumer = isPropertyConsumerOnly(rows, name);&#010;-                        if (consumer) {&#010;-                            // the option is only for consumer so you cannot use it in producer mode&#010;-                            result.addNotProducerOnly(name);&#010;-                        }&#010;-                    }&#010;-                }&#010;-&#010;-                // default value&#010;-                String defaultValue = getPropertyDefaultValue(rows, name);&#010;-                if (defaultValue != null) {&#010;-                    result.addDefaultValue(name, defaultValue);&#010;-                }&#010;-&#010;-                // is required but the value is empty&#010;-                boolean required = isPropertyRequired(rows, name);&#010;-                if (required &amp;&amp; isEmpty(value)) {&#010;-                    result.addRequired(name);&#010;-                }&#010;-&#010;-                // is enum but the value is not within the enum range&#010;-                // but we can only check if the value is not a placeholder&#010;-                String enums = getPropertyEnum(rows, name);&#010;-                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; enums != null) {&#010;-                    String[] choices = enums.split("","");&#010;-                    boolean found = false;&#010;-                    for (String s : choices) {&#010;-                        if (value.equalsIgnoreCase(s)) {&#010;-                            found = true;&#010;-                            break;&#010;-                        }&#010;-                    }&#010;-                    if (!found) {&#010;-                        result.addInvalidEnum(name, value);&#010;-                        result.addInvalidEnumChoices(name, choices);&#010;-                        if (suggestionStrategy != null) {&#010;-                            Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;();&#010;-                            names.addAll(Arrays.asList(choices));&#010;-                            String[] suggestions = suggestionStrategy.suggestEndpointOptions(names, value);&#010;-                            if (suggestions != null) {&#010;-                                result.addInvalidEnumSuggestions(name, suggestions);&#010;-                            }&#010;-                        }&#010;-&#010;-                    }&#010;-                }&#010;-&#010;-                // is reference lookup of bean (not applicable for @UriPath, enums, or multi-valued)&#010;-                if (!mulitValue &amp;&amp; enums == null &amp;&amp; !""path"".equals(kind) &amp;&amp; isPropertyObject(rows, name)) {&#010;-                    // must start with # and be at least 2 characters&#010;-                    if (!value.startsWith(""#"") || value.length() &lt;= 1) {&#010;-                        result.addInvalidReference(name, value);&#010;-                    }&#010;-                }&#010;-&#010;-                // is boolean&#010;-                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyBoolean(rows, name)) {&#010;-                    // value must be a boolean&#010;-                    boolean bool = ""true"".equalsIgnoreCase(value) || ""false"".equalsIgnoreCase(value);&#010;-                    if (!bool) {&#010;-                        result.addInvalidBoolean(name, value);&#010;-                    }&#010;-                }&#010;-&#010;-                // is integer&#010;-                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyInteger(rows, name)) {&#010;-                    // value must be an integer&#010;-                    boolean valid = validateInteger(value);&#010;-                    if (!valid) {&#010;-                        result.addInvalidInteger(name, value);&#010;-                    }&#010;-                }&#010;-&#010;-                // is number&#010;-                if (!mulitValue &amp;&amp; !valuePlaceholder &amp;&amp; !lookup &amp;&amp; isPropertyNumber(rows, name)) {&#010;-                    // value must be an number&#010;-                    boolean valid = false;&#010;-                    try {&#010;-                        valid = !Double.valueOf(value).isNaN() || !Float.valueOf(value).isNaN();&#010;-                    } catch (Exception e) {&#010;-                        // ignore&#010;-                    }&#010;-                    if (!valid) {&#010;-                        result.addInvalidNumber(name, value);&#010;-                    }&#010;-                }&#010;-            }&#010;-        }&#010;-&#010;-        // now check if all required values are there, and that a default value does not exists&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String name = row.get(""name"");&#010;-            boolean required = isPropertyRequired(rows, name);&#010;-            if (required) {&#010;-                String value = properties.get(name);&#010;-                if (isEmpty(value)) {&#010;-                    value = getPropertyDefaultValue(rows, name);&#010;-                }&#010;-                if (isEmpty(value)) {&#010;-                    result.addRequired(name);&#010;-                }&#010;-            }&#010;-        }&#010;-&#010;-        return result;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; endpointProperties(String uri) throws URISyntaxException {&#010;-        // need to normalize uri first&#010;-        URI u = normalizeUri(uri);&#010;-        String scheme = u.getScheme();&#010;-&#010;-        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;-        if (json == null) {&#010;-            throw new IllegalArgumentException(""Cannot find endpoint with scheme "" + scheme);&#010;-        }&#010;-&#010;-        // grab the syntax&#010;-        String syntax = null;&#010;-        String alternativeSyntax = null;&#010;-        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""component"", json, false);&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""syntax"")) {&#010;-                syntax = row.get(""syntax"");&#010;-            }&#010;-            if (row.containsKey(""alternativeSyntax"")) {&#010;-                alternativeSyntax = row.get(""alternativeSyntax"");&#010;-            }&#010;-        }&#010;-        if (syntax == null) {&#010;-            throw new IllegalArgumentException(""Endpoint with scheme "" + scheme + "" has no syntax defined in the json schema"");&#010;-        }&#010;-&#010;-        // only if we support alternative syntax, and the uri contains the username and password in the authority&#010;-        // part of the uri, then we would need some special logic to capture that information and strip those&#010;-        // details from the uri, so we can continue parsing the uri using the normal syntax&#010;-        Map&lt;String, String&gt; userInfoOptions = new LinkedHashMap&lt;String, String&gt;();&#010;-        if (alternativeSyntax != null &amp;&amp; alternativeSyntax.contains(""@"")) {&#010;-            // clip the scheme from the syntax&#010;-            alternativeSyntax = after(alternativeSyntax, "":"");&#010;-            // trim so only userinfo&#010;-            int idx = alternativeSyntax.indexOf(""@"");&#010;-            String fields = alternativeSyntax.substring(0, idx);&#010;-            String[] names = fields.split("":"");&#010;-&#010;-            // grab authority part and grab username and/or password&#010;-            String authority = u.getAuthority();&#010;-            if (authority != null &amp;&amp; authority.contains(""@"")) {&#010;-                String username = null;&#010;-                String password = null;&#010;-&#010;-                // grab unserinfo part before @&#010;-                String userInfo = authority.substring(0, authority.indexOf(""@""));&#010;-                String[] parts = userInfo.split("":"");&#010;-                if (parts.length == 2) {&#010;-                    username = parts[0];&#010;-                    password = parts[1];&#010;-                } else {&#010;-                    // only username&#010;-                    username = userInfo;&#010;-                }&#010;-&#010;-                // remember the username and/or password which we add later to the options&#010;-                if (names.length == 2) {&#010;-                    userInfoOptions.put(names[0], username);&#010;-                    if (password != null) {&#010;-                        // password is optional&#010;-                        userInfoOptions.put(names[1], password);&#010;-                    }&#010;-                }&#010;-            }&#010;-        }&#010;-&#010;-        // clip the scheme from the syntax&#010;-        syntax = after(syntax, "":"");&#010;-        // clip the scheme from the uri&#010;-        uri = after(uri, "":"");&#010;-        String uriPath = stripQuery(uri);&#010;-&#010;-        // strip user info from uri path&#010;-        if (!userInfoOptions.isEmpty()) {&#010;-            int idx = uriPath.indexOf('@');&#010;-            if (idx &gt; -1) {&#010;-                uriPath = uriPath.substring(idx + 1);&#010;-            }&#010;-        }&#010;-&#010;-        // strip double slash in the start&#010;-        if (uriPath != null &amp;&amp; uriPath.startsWith(""//"")) {&#010;-            uriPath = uriPath.substring(2);&#010;-        }&#010;-&#010;-        // parse the syntax and find the names of each option&#010;-        Matcher matcher = SYNTAX_PATTERN.matcher(syntax);&#010;-        List&lt;String&gt; word = new ArrayList&lt;String&gt;();&#010;-        while (matcher.find()) {&#010;-            String s = matcher.group(1);&#010;-            if (!scheme.equals(s)) {&#010;-                word.add(s);&#010;-            }&#010;-        }&#010;-        // parse the syntax and find each token between each option&#010;-        String[] tokens = SYNTAX_PATTERN.split(syntax);&#010;-&#010;-        // find the position where each option start/end&#010;-        List&lt;String&gt; word2 = new ArrayList&lt;String&gt;();&#010;-        int prev = 0;&#010;-        int prevPath = 0;&#010;-&#010;-        // special for activemq/jms where the enum for destinationType causes a token issue as it includes a colon&#010;-        // for 'temp:queue' and 'temp:topic' values&#010;-        if (""activemq"".equals(scheme) || ""jms"".equals(scheme)) {&#010;-            if (uriPath.startsWith(""temp:"")) {&#010;-                prevPath = 5;&#010;-            }&#010;-        }&#010;-&#010;-        for (String token : tokens) {&#010;-            if (token.isEmpty()) {&#010;-                continue;&#010;-            }&#010;-&#010;-            // special for some tokens where :// can be used also, eg http://foo&#010;-            int idx = -1;&#010;-            int len = 0;&#010;-            if ("":"".equals(token)) {&#010;-                idx = uriPath.indexOf(""://"", prevPath);&#010;-                len = 3;&#010;-            }&#010;-            if (idx == -1) {&#010;-                idx = uriPath.indexOf(token, prevPath);&#010;-                len = token.length();&#010;-            }&#010;-&#010;-            if (idx &gt; 0) {&#010;-                String option = uriPath.substring(prev, idx);&#010;-                word2.add(option);&#010;-                prev = idx + len;&#010;-                prevPath = prev;&#010;-            }&#010;-        }&#010;-        // special for last or if we did not add anyone&#010;-        if (prev &gt; 0 || word2.isEmpty()) {&#010;-            String option = uriPath.substring(prev);&#010;-            word2.add(option);&#010;-        }&#010;-&#010;-        rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;-&#010;-        boolean defaultValueAdded = false;&#010;-&#010;-        // now parse the uri to know which part isw what&#010;-        Map&lt;String, String&gt; options = new LinkedHashMap&lt;String, String&gt;();&#010;-&#010;-        // include the username and password from the userinfo section&#010;-        if (!userInfoOptions.isEmpty()) {&#010;-            options.putAll(userInfoOptions);&#010;-        }&#010;-&#010;-        // word contains the syntax path elements&#010;-        Iterator&lt;String&gt; it = word2.iterator();&#010;-        for (int i = 0; i &lt; word.size(); i++) {&#010;-            String key = word.get(i);&#010;-&#010;-            boolean allOptions = word.size() == word2.size();&#010;-            boolean required = isPropertyRequired(rows, key);&#010;-            String defaultValue = getPropertyDefaultValue(rows, key);&#010;-&#010;-            // we have all options so no problem&#010;-            if (allOptions) {&#010;-                String value = it.next();&#010;-                options.put(key, value);&#010;-            } else {&#010;-                // we have a little problem as we do not not have all options&#010;-                if (!required) {&#010;-                    String value = null;&#010;-&#010;-                    boolean last = i == word.size() - 1;&#010;-                    if (last) {&#010;-                        // if its the last value then use it instead of the default value&#010;-                        value = it.hasNext() ? it.next() : null;&#010;-                        if (value != null) {&#010;-                            options.put(key, value);&#010;-                        } else {&#010;-                            value = defaultValue;&#010;-                        }&#010;-                    }&#010;-                    if (value != null) {&#010;-                        options.put(key, value);&#010;-                        defaultValueAdded = true;&#010;-                    }&#010;-                } else {&#010;-                    String value = it.hasNext() ? it.next() : null;&#010;-                    if (value != null) {&#010;-                        options.put(key, value);&#010;-                    }&#010;-                }&#010;-            }&#010;-        }&#010;-&#010;-        Map&lt;String, String&gt; answer = new LinkedHashMap&lt;String, String&gt;();&#010;-&#010;-        // remove all options which are using default values and are not required&#010;-        for (Map.Entry&lt;String, String&gt; entry : options.entrySet()) {&#010;-            String key = entry.getKey();&#010;-            String value = entry.getValue();&#010;-&#010;-            if (defaultValueAdded) {&#010;-                boolean required = isPropertyRequired(rows, key);&#010;-                String defaultValue = getPropertyDefaultValue(rows, key);&#010;-&#010;-                if (!required &amp;&amp; defaultValue != null) {&#010;-                    if (defaultValue.equals(value)) {&#010;-                        continue;&#010;-                    }&#010;-                }&#010;-            }&#010;-&#010;-            // we should keep this in the answer&#010;-            answer.put(key, value);&#010;-        }&#010;-&#010;-        // now parse the uri parameters&#010;-        Map&lt;String, Object&gt; parameters = URISupport.parseParameters(u);&#010;-&#010;-        // and covert the values to String so its JMX friendly&#010;-        while (!parameters.isEmpty()) {&#010;-            Map.Entry&lt;String, Object&gt; entry = parameters.entrySet().iterator().next();&#010;-            String key = entry.getKey();&#010;-            String value = entry.getValue() != null ? entry.getValue().toString() : """";&#010;-&#010;-            boolean multiValued = isPropertyMultiValue(rows, key);&#010;-            if (multiValued) {&#010;-                String prefix = getPropertyPrefix(rows, key);&#010;-                // extra all the multi valued options&#010;-                Map&lt;String, Object&gt; values = URISupport.extractProperties(parameters, prefix);&#010;-                // build a string with the extra multi valued options with the prefix and &amp; as separator&#010;-                CollectionStringBuffer csb = new CollectionStringBuffer(""&amp;"");&#010;-                for (Map.Entry&lt;String, Object&gt; multi : values.entrySet()) {&#010;-                    String line = prefix + multi.getKey() + ""="" + (multi.getValue() != null ? multi.getValue().toString() : """");&#010;-                    csb.append(line);&#010;-                }&#010;-                // append the extra multi-values to the existing (which contains the first multi value)&#010;-                if (!csb.isEmpty()) {&#010;-                    value = value + ""&amp;"" + csb.toString();&#010;-                }&#010;-            }&#010;-&#010;-            answer.put(key, value);&#010;-            // remove the parameter as we run in a while loop until no more parameters&#010;-            parameters.remove(key);&#010;-        }&#010;-&#010;-        return answer;&#010;-    }&#010;-&#010;-    public Map&lt;String, String&gt; endpointLenientProperties(String uri) throws URISyntaxException {&#010;-        // need to normalize uri first&#010;-&#010;-        // parse the uri&#010;-        URI u = normalizeUri(uri);&#010;-        String scheme = u.getScheme();&#010;-&#010;-        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;-        if (json == null) {&#010;-            throw new IllegalArgumentException(""Cannot find endpoint with scheme "" + scheme);&#010;-        }&#010;-&#010;-        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;-&#010;-        // now parse the uri parameters&#010;-        Map&lt;String, Object&gt; parameters = URISupport.parseParameters(u);&#010;-&#010;-        // all the known options&#010;-        Set&lt;String&gt; names = getNames(rows);&#010;-&#010;-        Map&lt;String, String&gt; answer = new LinkedHashMap&lt;&gt;();&#010;-&#010;-        // and covert the values to String so its JMX friendly&#010;-        parameters.forEach((k, v) -&gt; {&#010;-            String key = k;&#010;-            String value = v != null ? v.toString() : """";&#010;-&#010;-            // is the key a prefix property&#010;-            int dot = key.indexOf('.');&#010;-            if (dot != -1) {&#010;-                String prefix = key.substring(0, dot + 1); // include dot in prefix&#010;-                String option = getPropertyNameFromNameWithPrefix(rows, prefix);&#010;-                if (option == null || !isPropertyMultiValue(rows, option)) {&#010;-                    answer.put(key, value);&#010;-                }&#010;-            } else if (!names.contains(key)) {&#010;-                answer.put(key, value);&#010;-            }&#010;-        });&#010;-&#010;-        return answer;&#010;-    }&#010;-&#010;-    public String endpointComponentName(String uri) {&#010;-        if (uri != null) {&#010;-            int idx = uri.indexOf("":"");&#010;-            if (idx &gt; 0) {&#010;-                return uri.substring(0, idx);&#010;-            }&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    public String asEndpointUri(String scheme, String json, boolean encode) throws URISyntaxException {&#010;-        return doAsEndpointUri(scheme, json, ""&amp;"", encode);&#010;-    }&#010;-&#010;-    public String asEndpointUriXml(String scheme, String json, boolean encode) throws URISyntaxException {&#010;-        return doAsEndpointUri(scheme, json, ""&amp;amp;"", encode);&#010;-    }&#010;-&#010;-    private String doAsEndpointUri(String scheme, String json, String ampersand, boolean encode) throws URISyntaxException {&#010;-        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;-&#010;-        Map&lt;String, String&gt; copy = new HashMap&lt;String, String&gt;();&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            String name = row.get(""name"");&#010;-            String required = row.get(""required"");&#010;-            String value = row.get(""value"");&#010;-            String defaultValue = row.get(""defaultValue"");&#010;-&#010;-            // only add if either required, or the value is != default value&#010;-            String valueToAdd = null;&#010;-            if (""true"".equals(required)) {&#010;-                valueToAdd = value != null ? value : defaultValue;&#010;-                if (valueToAdd == null) {&#010;-                    valueToAdd = """";&#010;-                }&#010;-            } else {&#010;-                // if we have a value and no default then add it&#010;-                if (value != null &amp;&amp; defaultValue == null) {&#010;-                    valueToAdd = value;&#010;-                }&#010;-                // otherwise only add if the value is != default value&#010;-                if (value != null &amp;&amp; defaultValue != null &amp;&amp; !value.equals(defaultValue)) {&#010;-                    valueToAdd = value;&#010;-                }&#010;-            }&#010;-&#010;-            if (valueToAdd != null) {&#010;-                copy.put(name, valueToAdd);&#010;-            }&#010;-        }&#010;-&#010;-        return doAsEndpointUri(scheme, copy, ampersand, encode);&#010;-    }&#010;-&#010;-    public String asEndpointUri(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException {&#010;-        return doAsEndpointUri(scheme, properties, ""&amp;"", encode);&#010;-    }&#010;-&#010;-    public String asEndpointUriXml(String scheme, Map&lt;String, String&gt; properties, boolean encode) throws URISyntaxException {&#010;-        return doAsEndpointUri(scheme, properties, ""&amp;amp;"", encode);&#010;-    }&#010;-&#010;-    String doAsEndpointUri(String scheme, Map&lt;String, String&gt; properties, String ampersand, boolean encode) throws URISyntaxException {&#010;-        String json = jsonSchemaResolver.getComponentJSonSchema(scheme);&#010;-        if (json == null) {&#010;-            throw new IllegalArgumentException(""Cannot find endpoint with scheme "" + scheme);&#010;-        }&#010;-&#010;-        // grab the syntax&#010;-        String syntax = null;&#010;-        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""component"", json, false);&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""syntax"")) {&#010;-                syntax = row.get(""syntax"");&#010;-                break;&#010;-            }&#010;-        }&#010;-        if (syntax == null) {&#010;-            throw new IllegalArgumentException(""Endpoint with scheme "" + scheme + "" has no syntax defined in the json schema"");&#010;-        }&#010;-&#010;-        // do any properties filtering which can be needed for some special components&#010;-        properties = filterProperties(scheme, properties);&#010;-&#010;-        rows = JSonSchemaHelper.parseJsonSchema(""properties"", json, true);&#010;-&#010;-        // clip the scheme from the syntax&#010;-        syntax = after(syntax, "":"");&#010;-&#010;-        String originalSyntax = syntax;&#010;-&#010;-        // build at first according to syntax (use a tree map as we want the uri options sorted)&#010;-        Map&lt;String, String&gt; copy = new TreeMap&lt;String, String&gt;();&#010;-        for (Map.Entry&lt;String, String&gt; entry : properties.entrySet()) {&#010;-            String key = entry.getKey();&#010;-            String value = entry.getValue() != null ? entry.getValue() : """";&#010;-            if (syntax != null &amp;&amp; syntax.contains(key)) {&#010;-                syntax = syntax.replace(key, value);&#010;-            } else {&#010;-                copy.put(key, value);&#010;-            }&#010;-        }&#010;-&#010;-        // do we have all the options the original syntax needs (easy way)&#010;-        String[] keys = syntaxKeys(originalSyntax);&#010;-        boolean hasAllKeys = properties.keySet().containsAll(Arrays.asList(keys));&#010;-&#010;-        // build endpoint uri&#010;-        StringBuilder sb = new StringBuilder();&#010;-        sb.append(scheme);&#010;-        sb.append("":"");&#010;-&#010;-        if (hasAllKeys) {&#010;-            // we have all the keys for the syntax so we can build the uri the easy way&#010;-            sb.append(syntax);&#010;-&#010;-            if (!copy.isEmpty()) {&#010;-                boolean hasQuestionmark = sb.toString().contains(""?"");&#010;-                // the last option may already contain a ? char, if so we should use &amp; instead of ?&#010;-                sb.append(hasQuestionmark ? ampersand : '?');&#010;-                String query = createQueryString(copy, ampersand, encode);&#010;-                sb.append(query);&#010;-            }&#010;-        } else {&#010;-            // TODO: revisit this and see if we can do this in another way&#010;-            // oh darn some options is missing, so we need a complex way of building the uri&#010;-&#010;-            // the tokens between the options in the path&#010;-            String[] tokens = syntax.split(""\\w+"");&#010;-&#010;-            // parse the syntax into each options&#010;-            Matcher matcher = SYNTAX_PATTERN.matcher(originalSyntax);&#010;-            List&lt;String&gt; options = new ArrayList&lt;String&gt;();&#010;-            while (matcher.find()) {&#010;-                String s = matcher.group(1);&#010;-                options.add(s);&#010;-            }&#010;-&#010;-            // need to preserve {{ and }} from the syntax&#010;-            // (we need to use words only as its provisional placeholders)&#010;-            syntax = syntax.replaceAll(""\\{\\{"", ""BEGINCAMELPLACEHOLDER"");&#010;-            syntax = syntax.replaceAll(""\\}\\}"", ""ENDCAMELPLACEHOLDER"");&#010;-&#010;-            // parse the syntax into each options&#010;-            Matcher matcher2 = SYNTAX_PATTERN.matcher(syntax);&#010;-            List&lt;String&gt; options2 = new ArrayList&lt;String&gt;();&#010;-            while (matcher2.find()) {&#010;-                String s = matcher2.group(1);&#010;-                s = s.replaceAll(""BEGINCAMELPLACEHOLDER"", ""\\{\\{"");&#010;-                s = s.replaceAll(""ENDCAMELPLACEHOLDER"", ""\\}\\}"");&#010;-                options2.add(s);&#010;-            }&#010;-&#010;-            // build the endpoint&#010;-            int range = 0;&#010;-            boolean first = true;&#010;-            boolean hasQuestionmark = false;&#010;-            for (int i = 0; i &lt; options.size(); i++) {&#010;-                String key = options.get(i);&#010;-                String key2 = options2.get(i);&#010;-                String token = null;&#010;-                if (tokens.length &gt; i) {&#010;-                    token = tokens[i];&#010;-                }&#010;-&#010;-                boolean contains = properties.containsKey(key);&#010;-                if (!contains) {&#010;-                    // if the key are similar we have no explicit value and can try to find a default value if the option is required&#010;-                    if (isPropertyRequired(rows, key)) {&#010;-                        String value = getPropertyDefaultValue(rows, key);&#010;-                        if (value != null) {&#010;-                            properties.put(key, value);&#010;-                            key2 = value;&#010;-                        }&#010;-                    }&#010;-                }&#010;-&#010;-                // was the option provided?&#010;-                if (properties.containsKey(key)) {&#010;-                    if (!first &amp;&amp; token != null) {&#010;-                        sb.append(token);&#010;-                    }&#010;-                    hasQuestionmark |= key.contains(""?"") || (token != null &amp;&amp; token.contains(""?""));&#010;-                    sb.append(key2);&#010;-                    first = false;&#010;-                }&#010;-                range++;&#010;-            }&#010;-            // append any extra options that was in surplus for the last&#010;-            while (range &lt; options2.size()) {&#010;-                String token = null;&#010;-                if (tokens.length &gt; range) {&#010;-                    token = tokens[range];&#010;-                }&#010;-                String key2 = options2.get(range);&#010;-                sb.append(token);&#010;-                sb.append(key2);&#010;-                hasQuestionmark |= key2.contains(""?"") || (token != null &amp;&amp; token.contains(""?""));&#010;-                range++;&#010;-            }&#010;-&#010;-&#010;-            if (!copy.isEmpty()) {&#010;-                // the last option may already contain a ? char, if so we should use &amp; instead of ?&#010;-                sb.append(hasQuestionmark ? ampersand : '?');&#010;-                String query = createQueryString(copy, ampersand, encode);&#010;-                sb.append(query);&#010;-            }&#010;-        }&#010;-&#010;-        return sb.toString();&#010;-    }&#010;-&#010;-    @Deprecated&#010;-    private static String[] syntaxTokens(String syntax) {&#010;-        // build tokens between the words&#010;-        List&lt;String&gt; tokens = new ArrayList&lt;&gt;();&#010;-        // preserve backwards behavior which had an empty token first&#010;-        tokens.add("""");&#010;-&#010;-        String current = """";&#010;-        for (int i = 0; i &lt; syntax.length(); i++) {&#010;-            char ch = syntax.charAt(i);&#010;-            if (Character.isLetterOrDigit(ch)) {&#010;-                // reset for new current tokens&#010;-                if (current.length() &gt; 0) {&#010;-                    tokens.add(current);&#010;-                    current = """";&#010;-                }&#010;-            } else {&#010;-                current += ch;&#010;-            }&#010;-        }&#010;-        // anything left over?&#010;-        if (current.length() &gt; 0) {&#010;-            tokens.add(current);&#010;-        }&#010;-&#010;-        return tokens.toArray(new String[tokens.size()]);&#010;-    }&#010;-&#010;-    private static String[] syntaxKeys(String syntax) {&#010;-        // build tokens between the separators&#010;-        List&lt;String&gt; tokens = new ArrayList&lt;&gt;();&#010;-&#010;-        String current = """";&#010;-        for (int i = 0; i &lt; syntax.length(); i++) {&#010;-            char ch = syntax.charAt(i);&#010;-            if (Character.isLetterOrDigit(ch)) {&#010;-                current += ch;&#010;-            } else {&#010;-                // reset for new current tokens&#010;-                if (current.length() &gt; 0) {&#010;-                    tokens.add(current);&#010;-                    current = """";&#010;-                }&#010;-            }&#010;-        }&#010;-        // anything left over?&#010;-        if (current.length() &gt; 0) {&#010;-            tokens.add(current);&#010;-        }&#010;-&#010;-        return tokens.toArray(new String[tokens.size()]);&#010;-    }&#010;-&#010;-    public SimpleValidationResult validateSimpleExpression(String simple) {&#010;-        return doValidateSimple(null, simple, false);&#010;-    }&#010;-&#010;-    public SimpleValidationResult validateSimpleExpression(ClassLoader classLoader, String simple) {&#010;-        return doValidateSimple(classLoader, simple, false);&#010;-    }&#010;-&#010;-    public SimpleValidationResult validateSimplePredicate(String simple) {&#010;-        return doValidateSimple(null, simple, true);&#010;-    }&#010;-&#010;-    public SimpleValidationResult validateSimplePredicate(ClassLoader classLoader, String simple) {&#010;-        return doValidateSimple(classLoader, simple, true);&#010;-    }&#010;-&#010;-    private SimpleValidationResult doValidateSimple(ClassLoader classLoader, String simple, boolean predicate) {&#010;-        if (classLoader == null) {&#010;-            classLoader = getClass().getClassLoader();&#010;-        }&#010;-&#010;-        // if there are {{ }}} property placeholders then we need to resolve them to something else&#010;-        // as the simple parse cannot resolve them before parsing as we dont run the actual Camel application&#010;-        // with property placeholders setup so we need to dummy this by replace the {{ }} to something else&#010;-        // therefore we use an more unlikely character: {{XXX}} to ~^XXX^~&#010;-        String resolved = simple.replaceAll(""\\{\\{(.+)\\}\\}"", ""~^$1^~"");&#010;-&#010;-        SimpleValidationResult answer = new SimpleValidationResult(simple);&#010;-&#010;-        Object instance = null;&#010;-        Class clazz = null;&#010;-        try {&#010;-            clazz = classLoader.loadClass(""org.apache.camel.language.simple.SimpleLanguage"");&#010;-            instance = clazz.newInstance();&#010;-        } catch (Exception e) {&#010;-            // ignore&#010;-        }&#010;-&#010;-        if (clazz != null &amp;&amp; instance != null) {&#010;-            Throwable cause = null;&#010;-            try {&#010;-                if (predicate) {&#010;-                    instance.getClass().getMethod(""createPredicate"", String.class).invoke(instance, resolved);&#010;-                } else {&#010;-                    instance.getClass().getMethod(""createExpression"", String.class).invoke(instance, resolved);&#010;-                }&#010;-            } catch (InvocationTargetException e) {&#010;-                cause = e.getTargetException();&#010;-            } catch (Exception e) {&#010;-                cause = e;&#010;-            }&#010;-&#010;-            if (cause != null) {&#010;-&#010;-                // reverse ~^XXX^~ back to {{XXX}}&#010;-                String errMsg = cause.getMessage();&#010;-                errMsg = errMsg.replaceAll(""\\~\\^(.+)\\^\\~"", ""{{$1}}"");&#010;-&#010;-                answer.setError(errMsg);&#010;-&#010;-                // is it simple parser exception then we can grab the index where the problem is&#010;-                if (cause.getClass().getName().equals(""org.apache.camel.language.simple.types.SimpleIllegalSyntaxException"")&#010;-                    || cause.getClass().getName().equals(""org.apache.camel.language.simple.types.SimpleParserException"")) {&#010;-                    try {&#010;-                        // we need to grab the index field from those simple parser exceptions&#010;-                        Method method = cause.getClass().getMethod(""getIndex"");&#010;-                        Object result = method.invoke(cause);&#010;-                        if (result != null) {&#010;-                            int index = (int) result;&#010;-                            answer.setIndex(index);&#010;-                        }&#010;-                    } catch (Throwable i) {&#010;-                        // ignore&#010;-                    }&#010;-                }&#010;-&#010;-                // we need to grab the short message field from this simple syntax exception&#010;-                if (cause.getClass().getName().equals(""org.apache.camel.language.simple.types.SimpleIllegalSyntaxException"")) {&#010;-                    try {&#010;-                        Method method = cause.getClass().getMethod(""getShortMessage"");&#010;-                        Object result = method.invoke(cause);&#010;-                        if (result != null) {&#010;-                            String msg = (String) result;&#010;-                            answer.setShortError(msg);&#010;-                        }&#010;-                    } catch (Throwable i) {&#010;-                        // ignore&#010;-                    }&#010;-&#010;-                    if (answer.getShortError() == null) {&#010;-                        // fallback and try to make existing message short instead&#010;-                        String msg = answer.getError();&#010;-                        // grab everything before "" at location "" which would be regarded as the short message&#010;-                        int idx = msg.indexOf("" at location "");&#010;-                        if (idx &gt; 0) {&#010;-                            msg = msg.substring(0, idx);&#010;-                            answer.setShortError(msg);&#010;-                        }&#010;-                    }&#010;-                }&#010;-            }&#010;-        }&#010;-&#010;-        return answer;&#010;-    }&#010;-&#010;-    public LanguageValidationResult validateLanguagePredicate(ClassLoader classLoader, String language, String text) {&#010;-        return doValidateLanguage(classLoader, language, text, true);&#010;-    }&#010;-&#010;-    public LanguageValidationResult validateLanguageExpression(ClassLoader classLoader, String language, String text) {&#010;-        return doValidateLanguage(classLoader, language, text, false);&#010;-    }&#010;-&#010;-    private LanguageValidationResult doValidateLanguage(ClassLoader classLoader, String language, String text, boolean predicate) {&#010;-        if (classLoader == null) {&#010;-            classLoader = getClass().getClassLoader();&#010;-        }&#010;-&#010;-        SimpleValidationResult answer = new SimpleValidationResult(text);&#010;-&#010;-        String json = jsonSchemaResolver.getLanguageJSonSchema(language);&#010;-        if (json == null) {&#010;-            answer.setError(""Unknown language "" + language);&#010;-            return answer;&#010;-        }&#010;-&#010;-        List&lt;Map&lt;String, String&gt;&gt; rows = JSonSchemaHelper.parseJsonSchema(""language"", json, false);&#010;-        String className = null;&#010;-        for (Map&lt;String, String&gt; row : rows) {&#010;-            if (row.containsKey(""javaType"")) {&#010;-                className = row.get(""javaType"");&#010;-            }&#010;-        }&#010;-&#010;-        if (className == null) {&#010;-            answer.setError(""Cannot find javaType for language "" + language);&#010;-            return answer;&#010;-        }&#010;-&#010;-        Object instance = null;&#010;-        Class clazz = null;&#010;-        try {&#010;-            clazz = classLoader.loadClass(className);&#010;-            instance = clazz.newInstance();&#010;-        } catch (Exception e) {&#010;-            // ignore&#010;-        }&#010;-&#010;-        if (clazz != null &amp;&amp; instance != null) {&#010;-            Throwable cause = null;&#010;-            try {&#010;-                if (predicate) {&#010;-                    instance.getClass().getMethod(""createPredicate"", String.class).invoke(instance, text);&#010;-                } else {&#010;-                    instance.getClass().getMethod(""createExpression"", String.class).invoke(instance, text);&#010;-                }&#010;-            } catch (InvocationTargetException e) {&#010;-                cause = e.getTargetException();&#010;-            } catch (Exception e) {&#010;-                cause = e;&#010;-            }&#010;-&#010;-            if (cause != null) {&#010;-                answer.setError(cause.getMessage());&#010;-            }&#010;-        }&#010;-&#010;-        return answer;&#010;-    }&#010;-&#010;-    /**&#010;-     * Special logic for log endpoints to deal when showAll=true&#010;-     */&#010;-    private Map&lt;String, String&gt; filterProperties(String scheme, Map&lt;String, String&gt; options) {&#010;-        if (""log"".equals(scheme)) {&#010;-            String showAll = options.get(""showAll"");&#010;-            if (""true"".equals(showAll)) {&#010;-                Map&lt;String, String&gt; filtered = new LinkedHashMap&lt;String, String&gt;();&#010;-                // remove all the other showXXX options when showAll=true&#010;-                for (Map.Entry&lt;String, String&gt; entry : options.entrySet()) {&#010;-                    String key = entry.getKey();&#010;-                    boolean skip = key.startsWith(""show"") &amp;&amp; !key.equals(""showAll"");&#010;-                    if (!skip) {&#010;-                        filtered.put(key, entry.getValue());&#010;-                    }&#010;-                }&#010;-                return filtered;&#010;-            }&#010;-        }&#010;-        // use as-is&#010;-        return options;&#010;-    }&#010;-&#010;-    private static boolean validateInteger(String value) {&#010;-        boolean valid = false;&#010;-        try {&#010;-            valid = Integer.valueOf(value) != null;&#010;-        } catch (Exception e) {&#010;-            // ignore&#010;-        }&#010;-        if (!valid) {&#010;-            // it may be a time pattern, such as 5s for 5 seconds = 5000&#010;-            try {&#010;-                TimePatternConverter.toMilliSeconds(value);&#010;-                valid = true;&#010;-            } catch (Exception e) {&#010;-                // ignore&#010;-            }&#010;-        }&#010;-        return valid;&#010;-    }&#010;-&#010;-    // CHECKSTYLE:ON&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/CamelContextJSonSchemaResolver.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/CamelContextJSonSchemaResolver.java b/camel-core/src/main/java/org/apache/camel/catalog/CamelContextJSonSchemaResolver.java&#010;deleted file mode 100644&#010;index 8d95488..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/CamelContextJSonSchemaResolver.java&#010;+++ /dev/null&#010;@@ -1,80 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.io.IOException;&#010;-&#010;-import org.apache.camel.CamelContext;&#010;-&#010;-/**&#010;- * Uses runtime {@link CamelContext} to resolve the JSon schema files.&#010;- */&#010;-public class CamelContextJSonSchemaResolver implements JSonSchemaResolver {&#010;-&#010;-    private final CamelContext camelContext;&#010;-&#010;-    public CamelContextJSonSchemaResolver(CamelContext camelContext) {&#010;-        this.camelContext = camelContext;&#010;-    }&#010;-&#010;-    @Override&#010;-    public String getComponentJSonSchema(String name) {&#010;-        try {&#010;-            return camelContext.getComponentParameterJsonSchema(name);&#010;-        } catch (IOException e) {&#010;-            // ignore&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    @Override&#010;-    public String getDataFormatJSonSchema(String name) {&#010;-        try {&#010;-            return camelContext.getDataFormatParameterJsonSchema(name);&#010;-        } catch (IOException e) {&#010;-            // ignore&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    @Override&#010;-    public String getLanguageJSonSchema(String name) {&#010;-        try {&#010;-            return camelContext.getLanguageParameterJsonSchema(name);&#010;-        } catch (IOException e) {&#010;-            // ignore&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-    @Override&#010;-    public String getOtherJSonSchema(String name) {&#010;-        // not supported&#010;-        return null;&#010;-    }&#010;-&#010;-    @Override&#010;-    public String getModelJSonSchema(String name) {&#010;-        try {&#010;-            return camelContext.getEipParameterJsonSchema(name);&#010;-        } catch (IOException e) {&#010;-            // ignore&#010;-        }&#010;-        return null;&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/CatalogHelper.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/CatalogHelper.java b/camel-core/src/main/java/org/apache/camel/catalog/CatalogHelper.java&#010;deleted file mode 100644&#010;index caba4a3..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/CatalogHelper.java&#010;+++ /dev/null&#010;@@ -1,179 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.io.BufferedReader;&#010;-import java.io.IOException;&#010;-import java.io.InputStream;&#010;-import java.io.InputStreamReader;&#010;-import java.io.LineNumberReader;&#010;-import java.util.List;&#010;-&#010;-public final class CatalogHelper {&#010;-&#010;-    private CatalogHelper() {&#010;-    }&#010;-&#010;-    /**&#010;-     * Loads the entire stream into memory as a String and returns it.&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Notice:&lt;/b&gt; This implementation appends a &lt;tt&gt;\n&lt;/tt&gt; as line&#010;-     * terminator at the of the text.&#010;-     * &lt;p/&gt;&#010;-     * Warning, don't use for crazy big streams :)&#010;-     */&#010;-    public static void loadLines(InputStream in, List&lt;String&gt; lines) throws IOException {&#010;-        try (final InputStreamReader isr = new InputStreamReader(in);&#010;-            final BufferedReader reader = new LineNumberReader(isr)) {&#010;-            String line;&#010;-            while ((line = reader.readLine()) != null) {&#010;-                lines.add(line);&#010;-            }&#010;-        }&#010;-    }&#010;-&#010;-    /**&#010;-     * Loads the entire stream into memory as a String and returns it.&#010;-     * &lt;p/&gt;&#010;-     * &lt;b&gt;Notice:&lt;/b&gt; This implementation appends a &lt;tt&gt;\n&lt;/tt&gt; as line&#010;-     * terminator at the of the text.&#010;-     * &lt;p/&gt;&#010;-     * Warning, don't use for crazy big streams :)&#010;-     */&#010;-    public static String loadText(InputStream in) throws IOException {&#010;-        StringBuilder builder = new StringBuilder();&#010;-        try (final InputStreamReader isr = new InputStreamReader(in);&#010;-            final BufferedReader reader = new LineNumberReader(isr)) {&#010;-            String line;&#010;-            while ((line = reader.readLine()) != null) {&#010;-                builder.append(line);&#010;-                builder.append(""\n"");&#010;-            }&#010;-            return builder.toString();&#010;-        }&#010;-    }&#010;-&#010;-    /**&#010;-     * Matches the name with the pattern.&#010;-     *&#010;-     * @param name  the name&#010;-     * @param pattern the pattern&#010;-     * @return &lt;tt&gt;true&lt;/tt&gt; if matched, or &lt;tt&gt;false&lt;/tt&gt; if not&#010;-     */&#010;-    public static boolean matchWildcard(String name, String pattern) {&#010;-        // we have wildcard support in that hence you can match with: file* to match any file endpoints&#010;-        if (pattern.endsWith(""*"") &amp;&amp; name.startsWith(pattern.substring(0, pattern.length() - 1))) {&#010;-            return true;&#010;-        }&#010;-        return false;&#010;-    }&#010;-&#010;-    /**&#010;-     * Returns the string after the given token&#010;-     *&#010;-     * @param text  the text&#010;-     * @param after the token&#010;-     * @return the text after the token, or &lt;tt&gt;null&lt;/tt&gt; if text does not contain the token&#010;-     */&#010;-    public static String after(String text, String after) {&#010;-        if (!text.contains(after)) {&#010;-            return null;&#010;-        }&#010;-        return text.substring(text.indexOf(after) + after.length());&#010;-    }&#010;-&#010;-    /**&#010;-     * Returns the string before the given token&#010;-     *&#010;-     * @param text  the text&#010;-     * @param before the token&#010;-     * @return the text before the token, or &lt;tt&gt;null&lt;/tt&gt; if text does not contain the token&#010;-     */&#010;-    public static String before(String text, String before) {&#010;-        if (!text.contains(before)) {&#010;-            return null;&#010;-        }&#010;-        return text.substring(0, text.indexOf(before));&#010;-    }&#010;-&#010;-    /**&#010;-     * Returns the string between the given tokens&#010;-     *&#010;-     * @param text  the text&#010;-     * @param after the before token&#010;-     * @param before the after token&#010;-     * @return the text between the tokens, or &lt;tt&gt;null&lt;/tt&gt; if text does not contain the tokens&#010;-     */&#010;-    public static String between(String text, String after, String before) {&#010;-        text = after(text, after);&#010;-        if (text == null) {&#010;-            return null;&#010;-        }&#010;-        return before(text, before);&#010;-    }&#010;-&#010;-    /**&#010;-     * Tests whether the value is &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;-     *&#010;-     * @param value  the value, if its a String it will be tested for text length as well&#010;-     * @return true if empty&#010;-     */&#010;-    public static boolean isEmpty(Object value) {&#010;-        return !isNotEmpty(value);&#010;-    }&#010;-&#010;-    /**&#010;-     * Tests whether the value is &lt;b&gt;not&lt;/b&gt; &lt;tt&gt;null&lt;/tt&gt; or an empty string.&#010;-     *&#010;-     * @param value  the value, if its a String it will be tested for text length as well&#010;-     * @return true if &lt;b&gt;not&lt;/b&gt; empty&#010;-     */&#010;-    public static boolean isNotEmpty(Object value) {&#010;-        if (value == null) {&#010;-            return false;&#010;-        } else if (value instanceof String) {&#010;-            String text = (String) value;&#010;-            return text.trim().length() &gt; 0;&#010;-        } else {&#010;-            return true;&#010;-        }&#010;-    }&#010;-&#010;-    /**&#010;-     * Removes all leading and ending quotes (single and double) from the string&#010;-     *&#010;-     * @param s  the string&#010;-     * @return the string without leading and ending quotes (single and double)&#010;-     */&#010;-    public static String removeLeadingAndEndingQuotes(String s) {&#010;-        if (isEmpty(s)) {&#010;-            return s;&#010;-        }&#010;-&#010;-        String copy = s.trim();&#010;-        if (copy.startsWith(""'"") &amp;&amp; copy.endsWith(""'"")) {&#010;-            return copy.substring(1, copy.length() - 1);&#010;-        }&#010;-        if (copy.startsWith(""\"""") &amp;&amp; copy.endsWith(""\"""")) {&#010;-            return copy.substring(1, copy.length() - 1);&#010;-        }&#010;-&#010;-        // no quotes, so return as-is&#010;-        return s;&#010;-    }&#010;-&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/CollectionStringBuffer.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/CollectionStringBuffer.java b/camel-core/src/main/java/org/apache/camel/catalog/CollectionStringBuffer.java&#010;deleted file mode 100644&#010;index 2844ca9..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/CollectionStringBuffer.java&#010;+++ /dev/null&#010;@@ -1,57 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-public class CollectionStringBuffer {&#010;-    private final StringBuilder buffer = new StringBuilder();&#010;-    private String separator;&#010;-    private boolean first = true;&#010;-&#010;-    public CollectionStringBuffer() {&#010;-        this("", "");&#010;-    }&#010;-&#010;-    public CollectionStringBuffer(String separator) {&#010;-        this.separator = separator;&#010;-    }&#010;-&#010;-    @Override&#010;-    public String toString() {&#010;-        return buffer.toString();&#010;-    }&#010;-&#010;-    public void append(Object value) {&#010;-        if (first) {&#010;-            first = false;&#010;-        } else {&#010;-            buffer.append(separator);&#010;-        }&#010;-        buffer.append(value);&#010;-    }&#010;-&#010;-    public String getSeparator() {&#010;-        return separator;&#010;-    }&#010;-&#010;-    public void setSeparator(String separator) {&#010;-        this.separator = separator;&#010;-    }&#010;-&#010;-    public boolean isEmpty() {&#010;-        return first;&#010;-    }&#010;-}&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/c66be7a8/camel-core/src/main/java/org/apache/camel/catalog/DefaultRuntimeCamelCatalog.java&#010;----------------------------------------------------------------------&#010;diff --git a/camel-core/src/main/java/org/apache/camel/catalog/DefaultRuntimeCamelCatalog.java b/camel-core/src/main/java/org/apache/camel/catalog/DefaultRuntimeCamelCatalog.java&#010;deleted file mode 100644&#010;index dd66c55..0000000&#010;--- a/camel-core/src/main/java/org/apache/camel/catalog/DefaultRuntimeCamelCatalog.java&#010;+++ /dev/null&#010;@@ -1,136 +0,0 @@&#010;-/**&#010;- * Licensed to the Apache Software Foundation (ASF) under one or more&#010;- * contributor license agreements.  See the NOTICE file distributed with&#010;- * this work for additional information regarding copyright ownership.&#010;- * The ASF licenses this file to You under the Apache License, Version 2.0&#010;- * (the ""License""); you may not use this file except in compliance with&#010;- * the License.  You may obtain a copy of the License at&#010;- *&#010;- *      http://www.apache.org/licenses/LICENSE-2.0&#010;- *&#010;- * Unless required by applicable law or agreed to in writing, software&#010;- * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;- * See the License for the specific language governing permissions and&#010;- * limitations under the License.&#010;- */&#010;-package org.apache.camel.catalog;&#010;-&#010;-import java.util.HashMap;&#010;-import java.util.Map;&#010;-&#010;-import org.apache.camel.CamelContext;&#010;-&#010;-/**&#010;- * Default {@link RuntimeCamelCatalog}.&#010;- */&#010;-public class DefaultRuntimeCamelCatalog extends AbstractCamelCatalog implements RuntimeCamelCatalog {&#010;-&#010;-    // cache of operation -&gt; result&#010;-    private final Map&lt;String, Object&gt; cache = new HashMap&lt;String, Object&gt;();&#010;-    private boolean caching;&#010;-&#010;-    /**&#010;-     * Creates the {@link RuntimeCamelCatalog} without caching enabled.&#010;-     *&#010;-     * @param camelContext  the camel context&#010;-     */&#010;-    public DefaultRuntimeCamelCatalog(CamelContext camelContext) {&#010;-        this(camelContext, false);&#010;-    }&#010;-&#010;-    /**&#010;-     * Creates the {@link RuntimeCamelCatalog}&#010;-     *&#010;-     * @param camelContext  the camel context&#010;-     * @param caching  whether to use cache&#010;-     */&#010;-    public DefaultRuntimeCamelCatalog(CamelContext camelContext, boolean caching) {&#010;-        this.caching = caching;&#010;-        setJSonSchemaResolver(new CamelContextJSonSchemaResolver(camelContext));&#010;-    }&#010;-&#010;-    @Override&#010;-    public void start() throws Exception {&#010;-        // noop&#010;-    }&#010;-&#010;-    @Override&#010;-    public void stop() throws Exception {&#010;-        cache.clear();&#010;-    }&#010;-&#010;-    @Override&#010;-    public String modelJSonSchema(String name) {&#010;-        String answer = null;&#010;-        if (caching) {&#010;-            answer = (String) cache.get(""model-"" + name);&#010;-        }&#010;-&#010;-        if (answer == null) {&#010;-            answer = getJSonSchemaResolver().getModelJSonSchema(name);&#010;-            if (caching) {&#010;-                cache.put(""model-"" + name, answer);&#010;-            }&#010;-        }&#010;-&#010;-        return answer;&#010;-    }&#010;-&#010;-    @Override&#010;-    public String componentJSonSchema(String name) {&#010;-        String answer = null;&#010;-        if (caching) {&#010;-            answer = (String) cache.get(""component-"" + name);&#010;-        }&#010;-&#010;-        if (answer == null) {&#010;-            answer = getJSonSchemaResolver().getComponentJSonSchema(name);&#010;-            if (caching) {&#010;-                cache.put(""component-"" + name, answer);&#010;-            }&#010;-        }&#010;-&#010;-        return answer;&#010;-    }&#010;-&#010;-    @Override&#010;-    public String dataFormatJSonSchema(String name) {&#010;-        String answer = null;&#010;-        if (caching) {&#010;-            answer = (String) cache.get(""dataformat-"" + name);&#010;-        }&#010;-&#010;-        if (answer == null) {&#010;-            answer = getJSonSchemaResolver().getDataFormatJSonSchema(name);&#010;-            if (caching) {&#010;-                cache.put(""dataformat-"" + name, answer);&#010;-            }&#010;-        }&#010;-&#010;-        return answer;&#010;-    }&#010;-&#010;-    @Override&#010;-    public String languageJSonSchema(String name) {&#010;-        // if we try to look method then its in the bean.json file&#010;-        if (""method"".equals(name)) {&#010;-            name = ""bean"";&#010;-        }&#010;-&#010;-        String answer = null;&#010;-        if (caching) {&#010;-            answer = (String) cache.get(""language-"" + name);&#010;-        }&#010;-&#010;-        if (answer == null) {&#010;-            answer = getJSonSchemaResolver().getLanguageJSonSchema(name);&#010;-            if (caching) {&#010;-                cache.put(""language-"" + name, answer);&#010;-            }&#010;-        }&#010;-&#010;-        return answer;&#010;-    }&#010;-&#010;-}&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C8bc1b1e9d91243898c3083596a1d02a5%40git.apache.org%3E,2017-04-14 10:53,commits,7.0,327.0,  [6/6] camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
27,352.0,davscl...@apache.org,"Repository: camel&#010;Updated Branches:&#010;  refs/heads/master cd84f3857 -&gt; 49e1c0111&#010;&#010;&#010;Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/49e1c011&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/49e1c011&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/49e1c011&#010;&#010;Branch: refs/heads/master&#010;Commit: 49e1c011126df57f41987e432cf0566a523e9ffd&#010;Parents: cd84f38&#010;Author: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Authored: Fri Apr 14 16:41:58 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 16:42:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; .../camel/commands/AbstractCamelController.java |  9 +++---&#010; .../camel/commands/internal/MatchUtil.java      | 31 ++++++++++++++++++++&#010; 2 files changed, 36 insertions(+), 4 deletions(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/49e1c011/platforms/commands/commands-core/src/main/java/org/apache/camel/commands/AbstractCamelController.java&#010;----------------------------------------------------------------------&#010;diff --git a/platforms/commands/commands-core/src/main/java/org/apache/camel/commands/AbstractCamelController.java&#010;b/platforms/commands/commands-core/src/main/java/org/apache/camel/commands/AbstractCamelController.java&#010;index 3036d46..2937d10 100644&#010;--- a/platforms/commands/commands-core/src/main/java/org/apache/camel/commands/AbstractCamelController.java&#010;+++ b/platforms/commands/commands-core/src/main/java/org/apache/camel/commands/AbstractCamelController.java&#010;@@ -21,11 +21,12 @@ import java.util.LinkedHashMap;&#010; import java.util.List;&#010; import java.util.Map;&#010; &#010;-import org.apache.camel.catalog.CatalogHelper;&#010;-import org.apache.camel.commands.internal.RegexUtil;&#010; import org.apache.camel.util.JsonSchemaHelper;&#010; import org.apache.camel.util.ObjectHelper;&#010; &#010;+import static org.apache.camel.commands.internal.MatchUtil.matchWildcard;&#010;+import static org.apache.camel.commands.internal.RegexUtil.wildcardAsRegex;&#010;+&#010; /**&#010;  * Abstract {@link org.apache.camel.commands.CamelController} that implementators should&#010;extend.&#010;  */&#010;@@ -37,13 +38,13 @@ public abstract class AbstractCamelController implements CamelController&#010;{&#010; &#010;         List&lt;Map&lt;String, String&gt;&gt; context = getCamelContexts();&#010;         if (filter != null) {&#010;-            filter = RegexUtil.wildcardAsRegex(filter);&#010;+            filter = wildcardAsRegex(filter);&#010;         } else {&#010;             filter = ""*"";&#010;         }&#010;         for (Map&lt;String, String&gt; entry : context) {&#010;             String name = entry.get(""name"");&#010;-            if (name.equalsIgnoreCase(filter) || CatalogHelper.matchWildcard(name, filter)&#010;|| name.matches(filter)) {&#010;+            if (name.equalsIgnoreCase(filter) || matchWildcard(name, filter) || name.matches(filter))&#010;{&#010;                 answer.add(entry);&#010;             }&#010;         }&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/49e1c011/platforms/commands/commands-core/src/main/java/org/apache/camel/commands/internal/MatchUtil.java&#010;----------------------------------------------------------------------&#010;diff --git a/platforms/commands/commands-core/src/main/java/org/apache/camel/commands/internal/MatchUtil.java&#010;b/platforms/commands/commands-core/src/main/java/org/apache/camel/commands/internal/MatchUtil.java&#010;new file mode 100644&#010;index 0000000..874276e&#010;--- /dev/null&#010;+++ b/platforms/commands/commands-core/src/main/java/org/apache/camel/commands/internal/MatchUtil.java&#010;@@ -0,0 +1,31 @@&#010;+/**&#010;+ * Licensed to the Apache Software Foundation (ASF) under one or more&#010;+ * contributor license agreements.  See the NOTICE file distributed with&#010;+ * this work for additional information regarding copyright ownership.&#010;+ * The ASF licenses this file to You under the Apache License, Version 2.0&#010;+ * (the ""License""); you may not use this file except in compliance with&#010;+ * the License.  You may obtain a copy of the License at&#010;+ *&#010;+ *      http://www.apache.org/licenses/LICENSE-2.0&#010;+ *&#010;+ * Unless required by applicable law or agreed to in writing, software&#010;+ * distributed under the License is distributed on an ""AS IS"" BASIS,&#010;+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&#010;+ * See the License for the specific language governing permissions and&#010;+ * limitations under the License.&#010;+ */&#010;+package org.apache.camel.commands.internal;&#010;+&#010;+/**&#010;+ * Util class.&#010;+ */&#010;+public final class MatchUtil {&#010;+&#010;+    private MatchUtil() {&#010;+    }&#010;+&#010;+    public static boolean matchWildcard(String name, String pattern) {&#010;+        return pattern.endsWith(""*"") &amp;&amp; name.startsWith(pattern.substring(0, pattern.length()&#010;- 1));&#010;+    }&#010;+&#010;+}&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C0a03a23cc44e4ff9933d9f3be0bacc36%40git.apache.org%3E,2017-04-14 14:42,commits,39.0,352.0,camel git commit: Rename catalog to runtimecatalog to avoid clash with same package name in camel-catalog.
28,328.0,davscl...@apache.org,"Repository: camel&#010;Updated Branches:&#010;  refs/heads/master 6b42a3534 -&gt; 6a02de123&#010;&#010;&#010;CAMEL-10843 Ported camel-ignite wiki doc into adoc&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/6a02de12&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/6a02de12&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/6a02de12&#010;&#010;Branch: refs/heads/master&#010;Commit: 6a02de123f22dc8367dee3a0a9a73ac1314c6505&#010;Parents: 6b42a35&#010;Author: Tomohisa Igarashi &lt;tm.igarashi@gmail.com&gt;&#010;Authored: Fri Apr 14 16:02:12 2017 +0900&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:55:49 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; .../src/main/docs/ignite-component.adoc         | 498 +++++++++++++++++++&#010; components/readme.adoc                          |   3 +&#010; docs/user-manual/en/SUMMARY.md                  |   1 +&#010; 3 files changed, 502 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/6a02de12/components/camel-ignite/src/main/docs/ignite-component.adoc&#010;----------------------------------------------------------------------&#010;diff --git a/components/camel-ignite/src/main/docs/ignite-component.adoc b/components/camel-ignite/src/main/docs/ignite-component.adoc&#010;new file mode 100644&#010;index 0000000..a721719&#010;--- /dev/null&#010;+++ b/components/camel-ignite/src/main/docs/ignite-component.adoc&#010;@@ -0,0 +1,498 @@&#010;+[[Ignite-Component]]&#010;+## Ignite Component&#010;+&#010;+*Available as of Camel version 2.17*&#010;+&#010;+https://ignite.apache.org/[Apache Ignite] In-Memory Data Fabric is a high-performance, integrated&#010;and distributed in-memory platform for computing and transacting on large-scale data sets&#010;in real-time, orders of magnitude faster than possible with traditional disk-based or flash&#010;technologies. It is designed to deliver uncompromised performance for a wide set of in-memory&#010;computing use cases from high performance computing, to the industry most advanced data grid,&#010;highly available service grid, and streaming. See all https://ignite.apache.org/features.html[features].&#010;+&#010;+image:https://ignite.apache.org/images/apache-ignite.png[]&#010;+&#010;+This component offers seven endpoints to cover much of Ignite's functionality:&#010;+&#010;+* &lt;&lt;Ignite-Cache,Ignite Cache&gt;&gt;.&#010;+* &lt;&lt;Ignite-Compute,Ignite Compute&gt;&gt;.&#010;+* &lt;&lt;Ignite-Messaging,Ignite Messaging&gt;&gt;.&#010;+* &lt;&lt;Ignite-Events,Ignite Events&gt;&gt;.&#010;+* &lt;&lt;Ignite-Sets,Ignite Sets&gt;&gt;.&#010;+* &lt;&lt;Ignite-Queues,Ignite Queues&gt;&gt;.&#010;+* &lt;&lt;Ignite-IDGenerator,Ignite ID Generator&gt;&gt;.&#010;+&#010;+To use this component, add the following dependency to your pom.xml:&#010;+&#010;+[source,xml]&#010;+----&#010;+&lt;dependency&gt;&#010;+    &lt;groupId&gt;org.apache.camel&lt;/groupId&gt;&#010;+    &lt;artifactId&gt;camel-ignite&lt;/artifactId&gt;&#010;+    &lt;version&gt;${camel.version}&lt;/version&gt; &lt;!-- use the same version as your&#010;Camel core version --&gt;&#010;+&lt;/dependency&gt;&#010;+----&#010;+&#010;+[IMPORTANT,title=Running in OSGi]&#010;+====&#010;+If running in an OSGi container, please don't miss the &lt;&lt;Ignite-OsgiSupport,OSGi Support&gt;&gt;&#010;section below.&#010;+====&#010;+&#010;+// component options: START&#010;+// component options: END&#010;+&#010;+// endpoint options: START&#010;+// endpoint options: END&#010;+&#010;+&#010;+[[Ignite-Cache]]&#010;+CACHE: Ignite Cache Endpoint&#010;+^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#010;+This endpoint allows you to interact with an https://apacheignite.readme.io/docs/data-grid[Ignite&#010;Cache]:&#010;+&#010;+[source,text]&#010;+----&#010;+ignite:cache:cacheName?option1=value1&amp;option2=value2...&#010;+----&#010;+&#010;+Offers both a Producer (to invoke cache operations on an Ignite cache) and a Consumer (to&#010;consume changes from a continuous query).&#010;+&#010;+The cache value is always the body of the message, whereas the cache key is always stored&#010;in the `IgniteConstants.IGNITE_CACHE_KEY` message header.&#010;+&#010;+Even if you configure a fixed operation in the endpoint URI, you can vary it per-exchange&#010;by setting the `IgniteConstants.IGNITE_CACHE_OPERATION` message header.&#010;+&#010;+Options&#010;+++++++&#010;+[width=""100%"",cols=""1,1,1,4,1,1"",options=""header""]&#010;+|=======================================================================&#010;+| Option | Type | Default value | Description | Compulsory | Consumer/producer&#010;+| operation | IgniteCacheOperation enum | --- |&#010;+Cache operation to perform.&#010;+Possible values: GET, PUT, REMOVE, SIZE, REBALANCE, QUERY, CLEAR. |&#010;+N | Producer&#010;+&#010;+| failIfInexistentCache | boolean | false |&#010;+Whether to fail the initialization if the cache doesn't exist.  |&#010;+N | Producer&#010;+&#010;+| cachePeekMode | CachePeekMode (Ignite) enum | ALL |&#010;+The cache peek mode used for SIZE operations. |&#010;+N | Producer&#010;+&#010;+| query | Query | --- |&#010;+The query used for QUERY operations (as a producer) or to launch the continuous query (as&#010;a consumer). You can use a reference to a registry bean with a syntax like: ?query=#myQuery.&#010;|&#010;+Y for the consumer / N for the producer | Producer (for QUERY operation) and Consumer&#010;+&#010;+|remoteFilter | CacheEntryEventSerializableFilter | --- |&#010;+An optional remote filter for the continuous query consumer. You can use a reference to a&#010;registry bean with a syntax like: ?remoteFilter=#myRemoteFilter. |&#010;+N | Consumer&#010;+&#010;+| oneExchangePerUpdate | boolean | true |&#010;+Whether to send one exchange per cache update, even if multiple changes arrive in a group.&#010;|&#010;+N | Consumer&#010;+&#010;+| fireExistingQueryResults | boolean | false |&#010;+When starting the continuous query consumer, whether to fire existing cache results. |&#010;+N  | Consumer&#010;+&#010;+| autoUnsubscribe | boolean | ContinuousQuery.DFLT_AUTO_UNSUBSCRIBE |&#010;+Auto-unsubscribe flag on the Continuous Query (see Ignite docs). |&#010;+N | Consumer&#010;+&#010;+| pageSize | int | ContinuousQuery.DFLT_PAGE_SIZE |&#010;+Page size on the Continuous Query (see Ignite docs). |&#010;+N | Consumer&#010;+&#010;+| timeInterval | long | ContinuousQuery.DFLT_TIME_INTERVAL |&#010;+Time interval in millis on the Continuous Query (see Ignite docs). | N | Consumer&#010;+|=======================================================================&#010;+&#010;+Headers used&#010;++++++++++++&#010;+This endpoint uses the following headers:&#010;+[width=""100%"",cols=""1,1,1,4"",options=""header""]&#010;+|=======================================================================&#010;+| Header name | Constant | Expected type | Description&#010;+| CamelIgniteCacheKey | IgniteConstants.IGNITE_CACHE_KEY | String |&#010;+The cache key for the entry value in the message body.&#010;+&#010;+| CamelIgniteCacheQuery | IgniteConstants.IGNITE_CACHE_QUERY | Query |&#010;+The query to run (producer) when invoking the QUERY operation.&#010;+&#010;+| CamelIgniteCacheOperation | IgniteConstants.IGNITE_CACHE_OPERATION | IgniteCacheOperation&#010;enum |&#010;+Allows you to dynamically change the cache operation to execute (producer).&#010;+&#010;+| CamelIgniteCachePeekMode | IgniteConstants.IGNITE_CACHE_PEEK_MODE | CachePeekMode enum&#010;|&#010;+Allows you to dynamically change the cache peek mode when running the SIZE operation.&#010;+&#010;+| CamelIgniteCacheEventType | IgniteConstants.IGNITE_CACHE_EVENT_TYPE | int (EventType constants)&#010;|&#010;+This header carries the received event type when using the continuous query consumer.&#010;+&#010;+| CamelIgniteCacheName | IgniteConstants.IGNITE_CACHE_NAME | String |&#010;+This header carries the cache name for which a continuous query event was received (consumer).&#010;+It does not allow you to dynamically change the cache against which a producer operation&#010;is performed. Use EIPs for that (e.g. recipient list, dynamic router).&#010;+&#010;+| CamelIgniteCacheOldValue | IgniteConstants.IGNITE_CACHE_OLD_VALUE | Object |&#010;+This header carries the old cache value when passed in the incoming cache event (consumer).&#010;+|=======================================================================&#010;+&#010;+&#010;+[[Ignite-Compute]]&#010;+COMPUTE: Ignite Compute Endpoint&#010;+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#010;+This endpoint allows you to run https://apacheignite.readme.io/docs/compute-grid[compute&#010;operations] on the cluster by passing in an IgniteCallable, an IgniteRunnable, an IgniteClosure,&#010;or collections of them, along with their parameters if necessary. &#010;+&#010;+[source,text]&#010;+----&#010;+ignite:compute:endpointId?executionType=...&amp;option1=value1&amp;option2=value2...&#010;+----&#010;+&#010;+This endpoint only supports producers.&#010;+&#010;+The host part of the endpoint URI is a symbolic endpoint ID, it is not used for any purposes.&#010;+&#010;+The endpoint tries to run the object passed in the body of the IN message as the compute&#010;job. It expects different payload types depending on the execution type.&#010;+&#010;+Expected payload types&#010;++++++++++++++++++++++&#010;+Each operation expects the indicated types:&#010;+[width=""100%"",cols=""1,4"",options=""header""]&#010;+|=======================================================================&#010;+| Operation | Expected payloads&#010;+| CALL | Collection of IgniteCallable, or a single IgniteCallable.&#010;+| BROADCAST | IgniteCallable, IgniteRunnable, IgniteClosure.&#010;+| APPLY | IgniteClosure.&#010;+| EXECUTE | ComputeTask, Class&lt;? extends ComputeTask&gt; or an object representing parameters&#010;if the taskName option is not null.&#010;+| RUN | A Collection of IgniteRunnables, or a single IgniteRunnable.&#010;+| AFFINITY_CALL | IgniteCallable.&#010;+| AFFINITY_RUN | IgniteRunnable.&#010;+|=======================================================================&#010;+&#010;+Options&#010;+++++++&#010;+[width=""100%"",cols=""1,1,1,4,1,1"",options=""header""]&#010;+|=======================================================================&#010;+| Option | Type | Default value | Description | Compulsory | Consumer/producer&#010;+| executionType | IgniteComputeExecutionType enum | --- |&#010;+The compute operation to perform. Possible values: CALL, BROADCAST, APPLY, EXECUTE, RUN,&#010;AFFINITY_CALL, AFFINITY_RUN.&#010;+The component expects different payload types depending on the operation. See above. |&#010;+Y | Producer&#010;+&#010;+| clusterGroupExpression | ClusterGroupExpression | --- |&#010;+An expression that returns the Cluster Group for the IgniteCompute instance. |&#010;+N | Producer&#010;+&#010;+| taskName | String | --- | The task name, only used when performing the EXECUTE if a ComputeTask&#010;is not passed in the payload. |&#010;+N | Producer&#010;+&#010;+| computeName | String | --- | The name for the IgniteCompute instances produced by this&#010;endpoint. |&#010;+N | Producer&#010;+&#010;+| timeoutMillis | Long | --- | The timeout for the compute job. | N | Producer&#010;+|=======================================================================&#010;+&#010;+Headers used&#010;++++++++++++&#010;+This endpoint uses the following headers:&#010;+[width=""100%"",cols=""1,1,1,4"",options=""header""]&#010;+|=======================================================================&#010;+| Header name | Constant | Expected type | Description&#010;+| CamelIgniteComputeExecutionType | IgniteConstants.IGNITE_COMPUTE_EXECUTION_TYPE | IgniteComputeExecutionType&#010;enum |&#010;+ Allows you to dynamically change the compute operation to perform.&#010;+&#010;+| CamelIgniteComputeParameters | IgniteConstants.IGNITE_COMPUTE_PARAMS | Any object or Collection&#010;of objects. |&#010;+Parameters for APPLY, BROADCAST and EXECUTE operations.&#010;+&#010;+| CamelIgniteComputeReducer | IgniteConstants.IGNITE_COMPUTE_REDUCER | IgniteReducer |&#010;+Reducer for the APPLY and CALL operations.&#010;+&#010;+| CamelIgniteComputeAffinityCacheName | IgniteConstants.IGNITE_COMPUTE_AFFINITY_CACHE_NAME&#010;| String |&#010;+Affinity cache name for the AFFINITY_CALL and AFFINITY_RUN operations.&#010;+&#010;+| CamelIgniteComputeAffinityKey | IgniteConstants.IGNITE_COMPUTE_AFFINITY_KEY | Object |&#010;+Affinity key for the AFFINITY_CALL and AFFINITY_RUN operations.&#010;+|=======================================================================&#010;+&#010;+&#010;+[[Ignite-Messaging]]&#010;+MESSAGING: Ignite Messaging Endpoint&#010;+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#010;+The Ignite Messaging endpoint allows you to send and consume messages from an https://apacheignite.readme.io/docs/messaging[Ignite&#010;topic].&#010;+&#010;+[source,text]&#010;+----&#010;+ignite:messaging:topicName?option1=value1&amp;option2=value2...&#010;+----&#010;+&#010;+This endpoint supports producers (to send messages) and consumers (to receive messages).&#010;+&#010;+Options&#010;+++++++&#010;+[width=""100%"",cols=""1,1,1,4,1,1"",options=""header""]&#010;+|=======================================================================&#010;+| Option | Type | Default value | Description | Compulsory | Consumer/producer&#010;+| clusterGroupExpression | ClusterGroupExpression | --- |&#010;+An expression that returns the Cluster Group for the IgniteMessaging instance. |&#010;+N |Consumer and Producer&#010;+&#010;+| sendMode | IgniteMessagingSendMode enum | UNORDERED |&#010;+The send mode to use.&#010;+Possible values: UNORDERED, ORDERED. |&#010;+N | Producer&#010;+&#010;+| timeout | Long | --- | The timeout for the send operation when using ordered messages.&#010;|&#010;+N | Producer&#010;+|=======================================================================&#010;+&#010;+Headers used&#010;++++++++++++&#010;+This endpoint uses the following headers:&#010;+[width=""100%"",cols=""1,1,1,4"",options=""header""]&#010;+|=======================================================================&#010;+| Header name | Constant | Expected type | Description&#010;+| CamelIgniteMessagingTopic | IgniteConstants.IGNITE_MESSAGING_TOPIC | String |&#010;+Allows you to dynamically change the topic to send messages to (producer). &#010;+It also carries the topic on which a message was received (consumer).&#010;+&#010;+| CamelIgniteMessagingUUID | IgniteConstants.IGNITE_MESSAGING_UUID | UUID |&#010;+This header is filled in with the UUID of the subscription when a message arrives (consumer).&#010;+|=======================================================================&#010;+&#010;+&#010;+[[Ignite-Events]]&#010;+EVENTS: Ignite Events Endpoint&#010;+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#010;+The Ignite Events endpoint allows you to https://apacheignite.readme.io/docs/events[receive&#010;events] from the Ignite cluster by creating a local event listener.&#010;+&#010;+[source,text]&#010;+----&#010;+ignite:events:endpointId?option1=value1&amp;option2=value2...&#010;+----&#010;+&#010;+This endpoint only supports consumers.&#010;+The Exchanges created by this consumer put the received Event object into the body of the&#010;IN message.&#010;+&#010;+Options&#010;+++++++&#010;+[width=""100%"",cols=""1,1,1,4,1,1"",options=""header""]&#010;+|=======================================================================&#010;+| Option | Type | Default value | Description | Compulsory | Consumer/producer&#010;+| events | Set&lt;Integer&gt; or String | EventType.EVTS_ALL |&#010;+The event IDs to subscribe to. You can set a Set&lt;Integer&gt; directly where the IDs are&#010;the different constants in org.apache.ignite.events.EventType, or you can specify a comma-separated&#010;list of constant names.&#010;+For example: EVT_CACHE_ENTRY_CREATED,EVT_CACHE_OBJECT_REMOVED,EVT_IGFS_DIR_CREATED. |&#010;+N | Consumer&#010;+| clusterGroupExpression | ClusterGroupExpression | --- |&#010;+An expression that returns the Cluster Group to be used by the IgniteEvents instance. |&#010;+N | Consumer&#010;+|=======================================================================&#010;+&#010;+&#010;+&#010;+[[Ignite-Sets]]&#010;+SETS: Ignite Sets Endpoint&#010;+^^^^^^^^^^^^^^^^^^^^^^^^^^^&#010;+The Ignite Sets endpoint allows you to interact with https://apacheignite.readme.io/docs/queue-and-set[Ignite&#010;Set data structures].&#010;+&#010;+[source,text]&#010;+----&#010;+ignite:sets:setName?option1=value1&amp;option2=value2...&#010;+----&#010;+&#010;+This endpoint only supports producers.&#010;+&#010;+Options&#010;+++++++&#010;+[width=""100%"",cols=""1,1,1,4,1,1"",options=""header""]&#010;+|=======================================================================&#010;+| Option | Type | Default value | Description | Compulsory | Consumer/producer&#010;+| operation | IgniteSetOperation enum | --- |&#010;+The operation to invoke on the Ignite Set.&#010;+Superseded by the IgniteConstants.IGNITE_SETS_OPERATION header in the IN message.&#010;+Possible values: CONTAINS, ADD, SIZE, REMOVE, ITERATOR, CLEAR, RETAIN_ALL, ARRAY. |&#010;+N | Producer&#010;+&#010;+| configuration | CollectionConfiguration | empty CollectionConfiguration |&#010;+The configuration for this data structure. You can also specify inner properties by using&#010;the config. prefix.&#010;+For example: ?config.backups=4 |&#010;+N | Producer&#010;+|=======================================================================&#010;+&#010;+Headers used&#010;++++++++++++&#010;+This endpoint uses the following headers:&#010;+[width=""100%"",cols=""1,1,1,4"",options=""header""]&#010;+|=======================================================================&#010;+| Header name | Constant | Expected type | Description&#010;+| CamelIgniteSetsOperation | IgniteConstants.IGNITE_SETS_OPERATION | IgniteSetOperation enum&#010;|&#010;+Allows you to dynamically change the set operation.&#010;+|=======================================================================&#010;+&#010;+&#010;+[[Ignite-Queues]]&#010;+QUEUES: Ignite Queue Endpoint&#010;+^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#010;+The Ignite Queue endpoint allows you to interact with https://apacheignite.readme.io/docs/queue-and-set[Ignite&#010;Queue data structures].&#010;+&#010;+[source,text]&#010;+----&#010;+ignite:queue:queueName?option1=value1&amp;option2=value2...&#010;+----&#010;+&#010;+This endpoint only supports producers.&#010;+&#010;+Options&#010;+++++++&#010;+[width=""100%"",cols=""1,1,1,4,1,1"",options=""header""]&#010;+|=======================================================================&#010;+| Option | Type | Default value | Description | Compulsory | Consumer/producer&#010;+| operation | IgniteQueueOperation enum | --- |&#010;+The operation to invoke on the Ignite Queue.&#010;+Superseded by the IgniteConstants.IGNITE_QUEUE_OPERATION header in the IN message.&#010;+Possible values: CONTAINS, ADD, SIZE, REMOVE, ITERATOR, CLEAR, RETAIN_ALL, ARRAY, DRAIN,&#010;ELEMENT, PEEK, OFFER, POLL, TAKE, PUT. |&#010;+N | Producer&#010;+&#010;+| configuration | CollectionConfiguration | empty CollectionConfiguration |&#010;+The configuration for this data structure. You can also specify inner properties by using&#010;the config. prefix.&#010;+For example: ?config.backups=4 |&#010;+N | Producer&#010;+&#010;+| timeoutMillis | Long | | --- |&#010;+The timeout in milliseconds to use when invoking the OFFER or POLL operations. |&#010;+N | Producer&#010;+&#010;+| capacity | int | --- (unbounded) |&#010;+The queue capacity if you'd like to use a bounded queue. |&#010;+N | Producer&#010;+|=======================================================================&#010;+&#010;+Headers used&#010;++++++++++++&#010;+This endpoint uses the following headers:&#010;+[width=""100%"",cols=""1,1,1,4"",options=""header""]&#010;+|=======================================================================&#010;+| Header name | Constant | Expected type | Description&#010;+| CamelIgniteQueueOperation | IgniteConstants.IGNITE_QUEUE_OPERATION | IgniteQueueOperation&#010;enum |&#010;+Allows you to dynamically change the queue operation.&#010;+&#010;+| CamelIgniteQueueMaxElements | IgniteConstants.IGNITE_QUEUE_MAX_ELEMENTS | Integer or int&#010;|&#010;+When invoking the DRAIN operation, the amount of items to drain.&#010;+&#010;+| CamelIgniteQueueTransferredCount | IgniteConstants.IGNITE_QUEUE_TRANSFERRED_COUNT | Integer&#010;or int |&#010;+The amount of items transferred as the result of the DRAIN operation.&#010;+&#010;+| CamelIgniteQueueTimeoutMillis | IgniteConstants.IGNITE_QUEUE_TIMEOUT_MILLIS | Long or long&#010;|&#010;+Dynamically sets the timeout in milliseconds to use when invoking the OFFER or POLL operations.&#010;&#010;+|=======================================================================&#010;+&#010;+&#010;+[[Ignite-IDGenerator]]&#010;+IDGEN: Ignite ID Generator Endpoint&#010;+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#010;+The Ignite ID Generator endpoint allows you to interact with https://apacheignite.readme.io/docs/id-generator[Ignite&#010;Atomic Sequences and ID Generators].&#010;+&#010;+[source,text]&#010;+----&#010;+ignite:idgen:sequenceName?option1=value1&amp;option2=value2...&#010;+----&#010;+&#010;+This endpoint only supports producers.&#010;+&#010;+Options&#010;+++++++&#010;+[width=""100%"",cols=""1,1,1,4,1,1"",options=""header""]&#010;+|=======================================================================&#010;+| Option | Type | Default value | Description | Compulsory | Consumer/producer&#010;+| operation | IgniteIdGenOperation enum | --- |&#010;+The operation to invoke on the Ignite ID Generator.&#010;+Superseded by the IgniteConstants.IGNITE_IDGEN_OPERATION header in the IN message.&#010;+Possible values: ADD_AND_GET, GET, GET_AND_ADD, GET_AND_INCREMENT, INCREMENT_AND_GET. |&#010;+N | Producer&#010;+&#010;+| configuration | CollectionConfiguration | empty CollectionConfiguration |&#010;+The configuration for this data structure. You can also specify inner properties by using&#010;the config. prefix.&#010;+For example: ?config.backups=4 |&#010;+N | Producer&#010;+|=======================================================================&#010;+&#010;+&#010;+&#010;+[[Ignite-InitializeComponent]]&#010;+Initializing the Ignite component&#010;+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&#010;+Each instance of the Ignite component is associated with an underlying org.apache.ignite.Ignite&#010;instance. You can interact with two Ignite clusters by initializing two instances of the Ignite&#010;component and binding them to different IgniteConfigurations. There are 3 ways to initialize&#010;the Ignite component:&#010;+&#010;+* By passing in an existing org.apache.ignite.Ignite instance. Here's an example using Spring&#010;config:&#010;+&#010;+[source,xml]&#010;+------------------------------------------------------------&#010;+&lt;bean name=""ignite"" class=""org.apache.camel.component.ignite.IgniteComponent""&gt;&#010;+   &lt;property name=""ignite"" ref=""ignite"" /&gt;&#010;+&lt;/bean&gt;&#010;+------------------------------------------------------------&#010;+&#010;+* By passing in an IgniteConfiguration, either constructed programmatically or through inversion&#010;of control (e.g. Spring, Blueprint, etc.). Here's an example using Spring config:&#010;+&#010;+[source,xml]&#010;+-------------------------------------------------------------------&#010;+&lt;bean name=""ignite"" class=""org.apache.camel.component.ignite.IgniteComponent""&gt;&#010;+   &lt;property name=""igniteConfiguration""&gt;&#010;+      &lt;bean class=""org.apache.ignite.configuration.IgniteConfiguration""&gt;&#010;+         [...]&#010;+      &lt;/bean&gt;&#010;+   &lt;/property&gt;&#010;+&lt;/bean&gt;&#010;+-------------------------------------------------------------------&#010;+&#010;+* By passing in a URL, InputStream or String URL to a Spring-based configuration file. In&#010;all three cases, you inject them in the same property called configurationResource. Here's&#010;an example using Spring config:&#010;+&#010;+[source,xml]&#010;+-------------------------------------------------------------------&#010;+&lt;bean name=""ignite"" class=""org.apache.camel.component.ignite.IgniteComponent""&gt;&#010;+   &lt;property name=""configurationResource"" value=""file:[...]/ignite-config.xml"" /&gt;&#010;+&lt;/bean&gt;&#010;+-------------------------------------------------------------------&#010;+&#010;+Additionally, if using Camel programmatically, there are several convenience static methods&#010;in IgniteComponent that return a component out of any of these configuration options:&#010;+&#010;+* IgniteComponent#fromIgnite(Ignite)&#010;+* IgniteComponent#fromConfiguration(IgniteConfiguration)&#010;+* IgniteComponent#fromInputStream(InputStream)&#010;+* IgniteComponent#fromUrl(URL)&#010;+* IgniteComponent#fromLocation(String)&#010;+&#010;+You may use those methods to quickly create an IgniteComponent with your chosen configuration&#010;technique.&#010;+&#010;+General options&#010;+^^^^^^^^^^^^^^&#010;+&#010;+All endpoints share the following options:&#010;+[width=""100%"",cols=""1,1,1,4,1,1"",options=""header""]&#010;+|=======================================================================&#010;+| Option | Type | Default value | Description&#010;+| propagateIncomingBodyIfNoReturnValue | boolean | true |&#010;+If the underlying Ignite operation returns void (no return type), this flag determines whether&#010;the producer will copy the IN body into the OUT body.&#010;+&#010;+| treatCollectionsAsCacheObjects | boolean | false |&#010;+Some Ignite operations can deal with multiple elements at once, if passed a Collection. Enabling&#010;this option will treat Collections as a single object, invoking the operation variant for&#010;cardinality 1.&#010;+|=======================================================================&#010;+&#010;+OSGi Support&#010;+^^^^^^^^^^^&#010;+&#010;+[TIP]&#010;+====&#010;+Apache Ignite supports OSGi from version 1.5.0.final onwards.&#010;+====&#010;+&#010;+&#010;+[NOTE,title=when installing on Apache Karaf]&#010;+====&#010;+1. Installing the camel-ignite feature will require the Ignite feature repository to be present.&#010;+1. You must have exported from the JRE (system bundle) some low-level, non-standard packages&#010;that Ignite requires.&#010;+====&#010;+Please refer to the OSGi section in the Ignite documentation for more information.&#010;+&#010;+&#010;+&#010;+See Also&#010;+^^^^^^^&#010;+&#010;+* http://camel.apache.org/configuring-camel.html[Configuring Camel]&#010;+* http://camel.apache.org/component.html[Component]&#010;+* http://camel.apache.org/endpoint.html[Endpoint]&#010;+* http://camel.apache.org/getting-started.html[Getting Started]&#010;\ No newline at end of file&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/6a02de12/components/readme.adoc&#010;----------------------------------------------------------------------&#010;diff --git a/components/readme.adoc b/components/readme.adoc&#010;index 2909fcb..f5734d4 100644&#010;--- a/components/readme.adoc&#010;+++ b/components/readme.adoc&#010;@@ -293,6 +293,9 @@ Number of Components: 231 in 184 JAR artifacts (14 deprecated)&#010; | link:camel-ibatis/src/main/docs/ibatis-component.adoc[iBatis] (camel-ibatis) +&#010; `ibatis:statement` | 1.2 | *deprecated* Performs a query poll insert update or delete in&#010;a relational database using Apache iBATIS.&#010; &#010;+| link:camel-ignite/src/main/docs/ignite-component.adoc[Ignite] (camel-ignite) +&#010;+`ignite:endpointName` | 1.17 | The Ignite Component integrates Apache Camel with Apache Ignite&#010;+&#010; | link:camel-infinispan/src/main/docs/infinispan-component.adoc[Infinispan] (camel-infinispan)&#010;+&#010; `infinispan:cacheName` | 2.13 | For reading/writing from/to Infinispan distributed key/value&#010;store and data grid.&#010; &#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/6a02de12/docs/user-manual/en/SUMMARY.md&#010;----------------------------------------------------------------------&#010;diff --git a/docs/user-manual/en/SUMMARY.md b/docs/user-manual/en/SUMMARY.md&#010;index 96955c4..a1bbc02 100644&#010;--- a/docs/user-manual/en/SUMMARY.md&#010;+++ b/docs/user-manual/en/SUMMARY.md&#010;@@ -209,6 +209,7 @@&#010; &#009;* [HTTP](http-component.adoc)&#010; &#009;* [HTTP4](http4-component.adoc)&#010; &#009;* [iBatis](ibatis-component.adoc)&#010;+&#009;* [Ignite](ignite-component.adoc)&#010; &#009;* [IMAP](imap-component.adoc)&#010; &#009;* [Infinispan](infinispan-component.adoc)&#010; &#009;* [InfluxDB](influxdb-component.adoc)&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C3ecfaacf3d8e4820a231f68340f2ef0d%40git.apache.org%3E,2017-04-14 10:55,commits,8.0,328.0,camel git commit: CAMEL-10843 Ported camel-ignite wiki doc into adoc
29,191.0,igarashitm,"Github user igarashitm closed the pull request at:&#010;&#010;    https://github.com/apache/camel/pull/1631&#010;&#010;&#010;---&#010;If your project is set up for it, you can reply to this email and have your&#010;reply appear on GitHub as well. If your project does not have this feature&#010;enabled and wishes so, or if the feature is enabled but not working, please&#010;contact infrastructure at infrastructure@apache.org or file a JIRA ticket&#010;with INFRA.&#010;---&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-dev/201704.mbox/ajax/%3C20170414112311.A7379DFF36%40git1-us-west.apache.org%3E,2017-04-14 11:23,mails,29.0,191.0,  [GitHub] camel pull request #1631: CAMEL-10843 Ported camel-ignite wiki doc into adoc
30,447.0,ASF GitHub Bot (JIRA),&#010;    [ https://issues.apache.org/jira/browse/CAMEL-10843?page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel&amp;focusedCommentId=15968912#comment-15968912&#010;] &#010;&#010;ASF GitHub Bot commented on CAMEL-10843:&#010;----------------------------------------&#010;&#010;Github user igarashitm closed the pull request at:&#010;&#010;    https://github.com/apache/camel/pull/1631&#010;&#010;&#010;&gt; Add readme.adoc files for other components&#010;&gt; ------------------------------------------&#010;&gt;&#010;&gt;                 Key: CAMEL-10843&#010;&gt;                 URL: https://issues.apache.org/jira/browse/CAMEL-10843&#010;&gt;             Project: Camel&#010;&gt;          Issue Type: Improvement&#010;&gt;          Components: documentation&#010;&gt;            Reporter: Claus Ibsen&#010;&gt;             Fix For: 2.19.0&#010;&gt;&#010;&gt;&#010;&gt; We need a little bit of documentation for these&#010;&gt; [INFO]&#010;&gt; [WARNING] &#009;Missing .adoc other documentation  : 11&#010;&gt; [WARNING] &#009;&#009;hystrix&#010;&gt; [WARNING] &#009;&#009;ribbon&#010;&gt; [WARNING] &#009;&#009;scala&#010;&gt; [WARNING] &#009;&#009;scr&#010;&gt; [WARNING] &#009;&#009;shiro&#010;&gt; [WARNING] &#009;&#009;spring-dm&#010;&gt; [WARNING] &#009;&#009;spring-javaconfig&#010;&gt; [WARNING] &#009;&#009;test-cdi&#010;&gt; [WARNING] &#009;&#009;test-karaf&#010;&gt; [WARNING] &#009;&#009;test-spring&#010;&gt; [WARNING] &#009;&#009;testng&#010;&#010;&#010;&#010;--&#010;This message was sent by Atlassian JIRA&#010;(v6.3.15#6346)&#010;&#010;,http://mail-archives.apache.org/mod_mbox/camel-issues/201704.mbox/ajax/%3CJIRA.13043545.1487234039000.283682.1492169022005%40Atlassian.JIRA%3E,2017-04-14 11:23,issues,30.0,450.0,  [jira] [Commented] (CAMEL-10843) Add readme.adoc files for other components
31,191.0,igarashitm,"Github user igarashitm closed the pull request at:&#010;&#010;    https://github.com/apache/camel/pull/1631&#010;&#010;&#010;---&#010;If your project is set up for it, you can reply to this email and have your&#010;reply appear on GitHub as well. If your project does not have this feature&#010;enabled and wishes so, or if the feature is enabled but not working, please&#010;contact infrastructure at infrastructure@apache.org or file a JIRA ticket&#010;with INFRA.&#010;---&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-dev/201704.mbox/ajax/%3C20170414112311.A7379DFF36%40git1-us-west.apache.org%3E,2017-04-14 11:23,mails,30.0,191.0,  [GitHub] camel pull request #1631: CAMEL-10843 Ported camel-ignite wiki doc into adoc
32,329.0,davscl...@apache.org,"Repository: camel&#010;Updated Branches:&#010;  refs/heads/master 6a02de123 -&gt; ddd2347d9&#010;&#010;&#010;CAMEL-10968: make camel-example-cxf-blueprint tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/ddd2347d&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/ddd2347d&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/ddd2347d&#010;&#010;Branch: refs/heads/master&#010;Commit: ddd2347d92c723557cbfc2143bfd648db48ed484&#010;Parents: 1ca0ec4&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:56:58 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cxf-blueprint/pom.xml | 20 +++++++++++++++++++-&#010; 1 file changed, 19 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/ddd2347d/examples/camel-example-cxf-blueprint/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cxf-blueprint/pom.xml b/examples/camel-example-cxf-blueprint/pom.xml&#010;index 6000401..acf9a11 100644&#010;--- a/examples/camel-example-cxf-blueprint/pom.xml&#010;+++ b/examples/camel-example-cxf-blueprint/pom.xml&#010;@@ -97,5 +97,23 @@&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;-&#010;+  &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.activation,java.xml.bind,java.xml.ws,jdk.xml.bind&#010;--add-opens java.base/java.lang=ALL-UNNAMED --add-exports=java.naming/com.sun.jndi.ldap=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime.reflect=ALL-UNNAMED --add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap.impl=ALL-UNNAMED&#010;--add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap=ALL-UNNAMED --add-opens&#010;java.base/java.net=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cb50b5147c8eb4ac9b023dca40545901b%40git.apache.org%3E,2017-04-14 10:57,commits,9.0,329.0,[01/20] camel git commit: CAMEL-10968: make camel-example-cxf-blueprint tests pass on Java 9
33,330.0,davscl...@apache.org,"CAMEL-10968: make camel-example-cxf-tomcat tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/8a23104b&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/8a23104b&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/8a23104b&#010;&#010;Branch: refs/heads/master&#010;Commit: 8a23104b554fcc9113a1913f49a4082c67d28acc&#010;Parents: 44d333f&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:54:47 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cxf-tomcat/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/8a23104b/examples/camel-example-cxf-tomcat/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cxf-tomcat/pom.xml b/examples/camel-example-cxf-tomcat/pom.xml&#010;index 8f1c898..6336aa9 100755&#010;--- a/examples/camel-example-cxf-tomcat/pom.xml&#010;+++ b/examples/camel-example-cxf-tomcat/pom.xml&#010;@@ -137,6 +137,22 @@&#010;         &lt;tomcat.url&gt;http://localhost:8080/manager&lt;/tomcat.url&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.activation,java.xml.bind,java.xml.ws,jdk.xml.bind&#010;--add-opens java.base/java.lang=ALL-UNNAMED --add-exports=java.naming/com.sun.jndi.ldap=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime.reflect=ALL-UNNAMED --add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap.impl=ALL-UNNAMED&#010;--add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap=ALL-UNNAMED --add-opens&#010;java.base/java.net=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ce9859842f13443f6b7ce077840356411%40git.apache.org%3E,2017-04-14 10:57,commits,9.0,330.0,  [02/20] camel git commit: CAMEL-10968: make camel-example-cxf-tomcat tests pass on Java 9
34,331.0,davscl...@apache.org,"CAMEL-10968: make camel-cxf-transport tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/a01f14cd&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/a01f14cd&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/a01f14cd&#010;&#010;Branch: refs/heads/master&#010;Commit: a01f14cdda7b576e42be4357625fec374555f6ae&#010;Parents: 7b2d32e&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:06:00 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; components/camel-cxf-transport/pom.xml | 20 ++++++++++++++++++++&#010; 1 file changed, 20 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/a01f14cd/components/camel-cxf-transport/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/components/camel-cxf-transport/pom.xml b/components/camel-cxf-transport/pom.xml&#010;index 93d650b..bc76a6a 100644&#010;--- a/components/camel-cxf-transport/pom.xml&#010;+++ b/components/camel-cxf-transport/pom.xml&#010;@@ -215,5 +215,25 @@&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;+  &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;reuseForks&gt;true&lt;/reuseForks&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C8944f48bb72241b994053539c7e0edf4%40git.apache.org%3E,2017-04-14 10:57,commits,9.0,331.0,  [03/20] camel git commit: CAMEL-10968: make camel-cxf-transport tests pass on Java 9
35,332.0,davscl...@apache.org,"CAMEL-10141: make camel-example-loan-broker-jms tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/e6964f1e&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/e6964f1e&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/e6964f1e&#010;&#010;Branch: refs/heads/master&#010;Commit: e6964f1e74bc2a2f9d76450447332ce03570cf53&#010;Parents: 3f9ebd5&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:48:15 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-loan-broker-jms/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/e6964f1e/examples/camel-example-loan-broker-jms/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-loan-broker-jms/pom.xml b/examples/camel-example-loan-broker-jms/pom.xml&#010;index 186036b..0668ecf 100644&#010;--- a/examples/camel-example-loan-broker-jms/pom.xml&#010;+++ b/examples/camel-example-loan-broker-jms/pom.xml&#010;@@ -177,6 +177,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.loanbroker.Client&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C9940ce4909db4f58bedb1ca432783218%40git.apache.org%3E,2017-04-14 10:57,commits,9.0,332.0,  [04/20] camel git commit: CAMEL-10141: make camel-example-loan-broker-jms tests pass on Java 9
36,333.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-example tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/1e31f1e4&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/1e31f1e4&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/1e31f1e4&#010;&#010;Branch: refs/heads/master&#010;Commit: 1e31f1e4265f4271d82f54f86cb0ba85f426f54d&#010;Parents: 6a02de1&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Thu Apr 13 18:35:07 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-xml/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/1e31f1e4/examples/camel-example-cdi-xml/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-xml/pom.xml b/examples/camel-example-cdi-xml/pom.xml&#010;index e365cc2..9758b4a 100755&#010;--- a/examples/camel-example-cdi-xml/pom.xml&#010;+++ b/examples/camel-example-cdi-xml/pom.xml&#010;@@ -114,4 +114,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ce4eb9713620046ea85a7803fdcaefd90%40git.apache.org%3E,2017-04-14 10:57,commits,9.0,333.0,  [05/20] camel git commit: CAMEL-10141: make camel-example-cdi-example tests pass on Java 9
37,334.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-test tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/d590e921&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/d590e921&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/d590e921&#010;&#010;Branch: refs/heads/master&#010;Commit: d590e92118a20b07c8a7d136d754a26e5055af86&#010;Parents: 1e31f1e&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:45:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-test/pom.xml | 19 ++++++++++++++++++-&#010; 1 file changed, 18 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/d590e921/examples/camel-example-cdi-test/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-test/pom.xml b/examples/camel-example-cdi-test/pom.xml&#010;index d1b5765..697847c 100644&#010;--- a/examples/camel-example-cdi-test/pom.xml&#010;+++ b/examples/camel-example-cdi-test/pom.xml&#010;@@ -106,7 +106,24 @@&#010;         &lt;/dependencies&gt;&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;-&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C17603fa71f9f4446851fd50f33bc248a%40git.apache.org%3E,2017-04-14 10:57,commits,9.0,334.0,  [06/20] camel git commit: CAMEL-10141: make camel-example-cdi-test tests pass on Java 9
38,335.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-metrics tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/73b61ef3&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/73b61ef3&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/73b61ef3&#010;&#010;Branch: refs/heads/master&#010;Commit: 73b61ef32533aac448fe5c31d2f28f0373ad5d90&#010;Parents: d590e92&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:46:37 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-metrics/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/73b61ef3/examples/camel-example-cdi-metrics/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-metrics/pom.xml b/examples/camel-example-cdi-metrics/pom.xml&#010;index 08401f7..5f09f7c 100755&#010;--- a/examples/camel-example-cdi-metrics/pom.xml&#010;+++ b/examples/camel-example-cdi-metrics/pom.xml&#010;@@ -127,4 +127,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C17d5bb4af9784983a8ac362b3e589ea3%40git.apache.org%3E,2017-04-14 10:57,commits,9.0,335.0,  [07/20] camel git commit: CAMEL-10141: make camel-example-cdi-metrics tests pass on Java 9
39,336.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-properties tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/061eb241&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/061eb241&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/061eb241&#010;&#010;Branch: refs/heads/master&#010;Commit: 061eb2416cd5863cf845b330740cacaed83321cd&#010;Parents: 73b61ef&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:46:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-properties/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/061eb241/examples/camel-example-cdi-properties/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-properties/pom.xml b/examples/camel-example-cdi-properties/pom.xml&#010;index 24adc77..ae2ae06 100755&#010;--- a/examples/camel-example-cdi-properties/pom.xml&#010;+++ b/examples/camel-example-cdi-properties/pom.xml&#010;@@ -124,4 +124,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C4901736312b14536a40a9ab29e998af5%40git.apache.org%3E,2017-04-14 10:57,commits,9.0,336.0,  [08/20] camel git commit: CAMEL-10141: make camel-example-cdi-properties tests pass on Java 9
40,337.0,davscl...@apache.org,"CAMEL-10141: make camel-example-reportincident tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/1b8949f5&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/1b8949f5&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/1b8949f5&#010;&#010;Branch: refs/heads/master&#010;Commit: 1b8949f593eed1fb0b97bcf0d138f2be113d0d2e&#010;Parents: e6964f1&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:59:57 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-reportincident/pom.xml | 2 +-&#010; 1 file changed, 1 insertion(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/1b8949f5/examples/camel-example-reportincident/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-reportincident/pom.xml b/examples/camel-example-reportincident/pom.xml&#010;index 92091d7..b820ac1 100755&#010;--- a/examples/camel-example-reportincident/pom.xml&#010;+++ b/examples/camel-example-reportincident/pom.xml&#010;@@ -208,7 +208,7 @@&#010;           &lt;plugin&gt;&#010;             &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;             &lt;configuration&gt;&#010;-              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.base/java.lang.invoke=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED&lt;/argLine&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.base/java.lang.invoke=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED&#010;--add-opens java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;             &lt;/configuration&gt;&#010;           &lt;/plugin&gt;&#010;         &lt;/plugins&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C4b84d50cca2f408189db81727d97a39f%40git.apache.org%3E,2017-04-14 10:57,commits,9.0,337.0,  [09/20] camel git commit: CAMEL-10141: make camel-example-reportincident tests pass on Java 9
41,338.0,davscl...@apache.org,"CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3f9ebd5a&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3f9ebd5a&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3f9ebd5a&#010;&#010;Branch: refs/heads/master&#010;Commit: 3f9ebd5a0a9e23e5b8c2f10abdf0c1c6ca4eda90&#010;Parents: 061eb24&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:47:16 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-rest-servlet/pom.xml | 43 +++++++++++++++++++-&#010; 1 file changed, 42 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3f9ebd5a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-rest-servlet/pom.xml b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;index 260d778..aac0973 100755&#010;--- a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;+++ b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;@@ -163,6 +163,48 @@&#010;         &lt;/dependency&gt;&#010;       &lt;/dependencies&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build-jetty&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;dependencies&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;arquillian-jetty-embedded-9&lt;/artifactId&gt;&#010;+          &lt;version&gt;1.0.0.CR2&lt;/version&gt;&#010;+          &lt;scope&gt;test&lt;/scope&gt;&#010;+          &lt;exclusions&gt;&#010;+            &lt;exclusion&gt;&#010;+              &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+              &lt;artifactId&gt;arquillian-container-spi&lt;/artifactId&gt;&#010;+            &lt;/exclusion&gt;&#010;+          &lt;/exclusions&gt;&#010;+        &lt;/dependency&gt;&#010;+      &lt;/dependencies&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;@@ -175,5 +217,4 @@&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cd0654af72ef94f628420b970c145ccf5%40git.apache.org%3E,2017-04-14 10:57,commits,9.0,338.0,  [10/20] camel git commit: CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9
42,339.0,davscl...@apache.org,"CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/fdeb3475&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/fdeb3475&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/fdeb3475&#010;&#010;Branch: refs/heads/master&#010;Commit: fdeb34752943b2bf4723407b99da875708fae852&#010;Parents: 1b8949f&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-pojo-messaging/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/fdeb3475/examples/camel-example-pojo-messaging/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-pojo-messaging/pom.xml b/examples/camel-example-pojo-messaging/pom.xml&#010;index f71b3b7..34b1bd6 100644&#010;--- a/examples/camel-example-pojo-messaging/pom.xml&#010;+++ b/examples/camel-example-pojo-messaging/pom.xml&#010;@@ -140,4 +140,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C7bc5feb92c534ce9a2bf51de8ce26017%40git.apache.org%3E,2017-04-14 10:57,commits,9.0,339.0,  [11/20] camel git commit: CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9
43,340.0,davscl...@apache.org,"CAMEL-10141: make camel-example-management tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/9e7b6c6c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/9e7b6c6c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/9e7b6c6c&#010;&#010;Branch: refs/heads/master&#010;Commit: 9e7b6c6c7bb423f36dd3a6db98635e2a95a98acc&#010;Parents: fdeb347&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-management/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/9e7b6c6c/examples/camel-example-management/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-management/pom.xml b/examples/camel-example-management/pom.xml&#010;index 66f0b1f..d8db087 100644&#010;--- a/examples/camel-example-management/pom.xml&#010;+++ b/examples/camel-example-management/pom.xml&#010;@@ -129,4 +129,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C30204927025749bbbc58720eb5a3f27c%40git.apache.org%3E,2017-04-14 10:57,commits,9.0,340.0,  [12/20] camel git commit: CAMEL-10141: make camel-example-management tests pass on Java 9
44,341.0,davscl...@apache.org,"CAMEL-10141: make camel-example-spring-jms tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3d9a999c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3d9a999c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3d9a999c&#010;&#010;Branch: refs/heads/master&#010;Commit: 3d9a999c035aa10bff547d0d3ee053528b615919&#010;Parents: 9e7b6c6&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-spring-jms/pom.xml | 17 ++++++++++++++++-&#010; 1 file changed, 16 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3d9a999c/examples/camel-example-spring-jms/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-spring-jms/pom.xml b/examples/camel-example-spring-jms/pom.xml&#010;index da360e0..af430aa 100644&#010;--- a/examples/camel-example-spring-jms/pom.xml&#010;+++ b/examples/camel-example-spring-jms/pom.xml&#010;@@ -128,6 +128,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.client.CamelClientEndpoint&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010;   &lt;build&gt;&#010; &#010;@@ -168,5 +184,4 @@&#010;     &lt;/plugins&gt;&#010; &#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cdf7aef9137e64879b2a51fa8161c519e%40git.apache.org%3E,2017-04-14 10:57,commits,9.0,341.0,  [13/20] camel git commit: CAMEL-10141: make camel-example-spring-jms tests pass on Java 9
45,342.0,davscl...@apache.org,"CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/047761a7&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/047761a7&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/047761a7&#010;&#010;Branch: refs/heads/master&#010;Commit: 047761a787d646759069e1ac318ba3523816ec08&#010;Parents: 3d9a999&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:50 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-osgi-rmi/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/047761a7/examples/camel-example-osgi-rmi/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-osgi-rmi/pom.xml b/examples/camel-example-osgi-rmi/pom.xml&#010;index dce39d2..82c588d 100644&#010;--- a/examples/camel-example-osgi-rmi/pom.xml&#010;+++ b/examples/camel-example-osgi-rmi/pom.xml&#010;@@ -87,6 +87,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.osgi.HelloClient&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ca519cd2689fb4af09c8ded1b17b83f65%40git.apache.org%3E,2017-04-14 10:57,commits,9.0,342.0,  [14/20] camel git commit: CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9
46,330.0,davscl...@apache.org,"CAMEL-10968: make camel-example-cxf-tomcat tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/8a23104b&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/8a23104b&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/8a23104b&#010;&#010;Branch: refs/heads/master&#010;Commit: 8a23104b554fcc9113a1913f49a4082c67d28acc&#010;Parents: 44d333f&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:54:47 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cxf-tomcat/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/8a23104b/examples/camel-example-cxf-tomcat/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cxf-tomcat/pom.xml b/examples/camel-example-cxf-tomcat/pom.xml&#010;index 8f1c898..6336aa9 100755&#010;--- a/examples/camel-example-cxf-tomcat/pom.xml&#010;+++ b/examples/camel-example-cxf-tomcat/pom.xml&#010;@@ -137,6 +137,22 @@&#010;         &lt;tomcat.url&gt;http://localhost:8080/manager&lt;/tomcat.url&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.activation,java.xml.bind,java.xml.ws,jdk.xml.bind&#010;--add-opens java.base/java.lang=ALL-UNNAMED --add-exports=java.naming/com.sun.jndi.ldap=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime.reflect=ALL-UNNAMED --add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap.impl=ALL-UNNAMED&#010;--add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap=ALL-UNNAMED --add-opens&#010;java.base/java.net=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ce9859842f13443f6b7ce077840356411%40git.apache.org%3E,2017-04-14 10:57,commits,10.0,330.0,  [02/20] camel git commit: CAMEL-10968: make camel-example-cxf-tomcat tests pass on Java 9
47,331.0,davscl...@apache.org,"CAMEL-10968: make camel-cxf-transport tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/a01f14cd&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/a01f14cd&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/a01f14cd&#010;&#010;Branch: refs/heads/master&#010;Commit: a01f14cdda7b576e42be4357625fec374555f6ae&#010;Parents: 7b2d32e&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:06:00 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; components/camel-cxf-transport/pom.xml | 20 ++++++++++++++++++++&#010; 1 file changed, 20 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/a01f14cd/components/camel-cxf-transport/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/components/camel-cxf-transport/pom.xml b/components/camel-cxf-transport/pom.xml&#010;index 93d650b..bc76a6a 100644&#010;--- a/components/camel-cxf-transport/pom.xml&#010;+++ b/components/camel-cxf-transport/pom.xml&#010;@@ -215,5 +215,25 @@&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;+  &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;reuseForks&gt;true&lt;/reuseForks&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C8944f48bb72241b994053539c7e0edf4%40git.apache.org%3E,2017-04-14 10:57,commits,10.0,331.0,  [03/20] camel git commit: CAMEL-10968: make camel-cxf-transport tests pass on Java 9
48,332.0,davscl...@apache.org,"CAMEL-10141: make camel-example-loan-broker-jms tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/e6964f1e&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/e6964f1e&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/e6964f1e&#010;&#010;Branch: refs/heads/master&#010;Commit: e6964f1e74bc2a2f9d76450447332ce03570cf53&#010;Parents: 3f9ebd5&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:48:15 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-loan-broker-jms/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/e6964f1e/examples/camel-example-loan-broker-jms/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-loan-broker-jms/pom.xml b/examples/camel-example-loan-broker-jms/pom.xml&#010;index 186036b..0668ecf 100644&#010;--- a/examples/camel-example-loan-broker-jms/pom.xml&#010;+++ b/examples/camel-example-loan-broker-jms/pom.xml&#010;@@ -177,6 +177,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.loanbroker.Client&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C9940ce4909db4f58bedb1ca432783218%40git.apache.org%3E,2017-04-14 10:57,commits,10.0,332.0,  [04/20] camel git commit: CAMEL-10141: make camel-example-loan-broker-jms tests pass on Java 9
49,333.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-example tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/1e31f1e4&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/1e31f1e4&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/1e31f1e4&#010;&#010;Branch: refs/heads/master&#010;Commit: 1e31f1e4265f4271d82f54f86cb0ba85f426f54d&#010;Parents: 6a02de1&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Thu Apr 13 18:35:07 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-xml/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/1e31f1e4/examples/camel-example-cdi-xml/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-xml/pom.xml b/examples/camel-example-cdi-xml/pom.xml&#010;index e365cc2..9758b4a 100755&#010;--- a/examples/camel-example-cdi-xml/pom.xml&#010;+++ b/examples/camel-example-cdi-xml/pom.xml&#010;@@ -114,4 +114,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ce4eb9713620046ea85a7803fdcaefd90%40git.apache.org%3E,2017-04-14 10:57,commits,10.0,333.0,  [05/20] camel git commit: CAMEL-10141: make camel-example-cdi-example tests pass on Java 9
50,334.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-test tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/d590e921&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/d590e921&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/d590e921&#010;&#010;Branch: refs/heads/master&#010;Commit: d590e92118a20b07c8a7d136d754a26e5055af86&#010;Parents: 1e31f1e&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:45:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-test/pom.xml | 19 ++++++++++++++++++-&#010; 1 file changed, 18 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/d590e921/examples/camel-example-cdi-test/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-test/pom.xml b/examples/camel-example-cdi-test/pom.xml&#010;index d1b5765..697847c 100644&#010;--- a/examples/camel-example-cdi-test/pom.xml&#010;+++ b/examples/camel-example-cdi-test/pom.xml&#010;@@ -106,7 +106,24 @@&#010;         &lt;/dependencies&gt;&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;-&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C17603fa71f9f4446851fd50f33bc248a%40git.apache.org%3E,2017-04-14 10:57,commits,10.0,334.0,  [06/20] camel git commit: CAMEL-10141: make camel-example-cdi-test tests pass on Java 9
51,335.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-metrics tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/73b61ef3&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/73b61ef3&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/73b61ef3&#010;&#010;Branch: refs/heads/master&#010;Commit: 73b61ef32533aac448fe5c31d2f28f0373ad5d90&#010;Parents: d590e92&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:46:37 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-metrics/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/73b61ef3/examples/camel-example-cdi-metrics/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-metrics/pom.xml b/examples/camel-example-cdi-metrics/pom.xml&#010;index 08401f7..5f09f7c 100755&#010;--- a/examples/camel-example-cdi-metrics/pom.xml&#010;+++ b/examples/camel-example-cdi-metrics/pom.xml&#010;@@ -127,4 +127,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C17d5bb4af9784983a8ac362b3e589ea3%40git.apache.org%3E,2017-04-14 10:57,commits,10.0,335.0,  [07/20] camel git commit: CAMEL-10141: make camel-example-cdi-metrics tests pass on Java 9
52,336.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-properties tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/061eb241&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/061eb241&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/061eb241&#010;&#010;Branch: refs/heads/master&#010;Commit: 061eb2416cd5863cf845b330740cacaed83321cd&#010;Parents: 73b61ef&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:46:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-properties/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/061eb241/examples/camel-example-cdi-properties/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-properties/pom.xml b/examples/camel-example-cdi-properties/pom.xml&#010;index 24adc77..ae2ae06 100755&#010;--- a/examples/camel-example-cdi-properties/pom.xml&#010;+++ b/examples/camel-example-cdi-properties/pom.xml&#010;@@ -124,4 +124,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C4901736312b14536a40a9ab29e998af5%40git.apache.org%3E,2017-04-14 10:57,commits,10.0,336.0,  [08/20] camel git commit: CAMEL-10141: make camel-example-cdi-properties tests pass on Java 9
53,337.0,davscl...@apache.org,"CAMEL-10141: make camel-example-reportincident tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/1b8949f5&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/1b8949f5&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/1b8949f5&#010;&#010;Branch: refs/heads/master&#010;Commit: 1b8949f593eed1fb0b97bcf0d138f2be113d0d2e&#010;Parents: e6964f1&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:59:57 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-reportincident/pom.xml | 2 +-&#010; 1 file changed, 1 insertion(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/1b8949f5/examples/camel-example-reportincident/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-reportincident/pom.xml b/examples/camel-example-reportincident/pom.xml&#010;index 92091d7..b820ac1 100755&#010;--- a/examples/camel-example-reportincident/pom.xml&#010;+++ b/examples/camel-example-reportincident/pom.xml&#010;@@ -208,7 +208,7 @@&#010;           &lt;plugin&gt;&#010;             &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;             &lt;configuration&gt;&#010;-              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.base/java.lang.invoke=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED&lt;/argLine&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.base/java.lang.invoke=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED&#010;--add-opens java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;             &lt;/configuration&gt;&#010;           &lt;/plugin&gt;&#010;         &lt;/plugins&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C4b84d50cca2f408189db81727d97a39f%40git.apache.org%3E,2017-04-14 10:57,commits,10.0,337.0,  [09/20] camel git commit: CAMEL-10141: make camel-example-reportincident tests pass on Java 9
54,338.0,davscl...@apache.org,"CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3f9ebd5a&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3f9ebd5a&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3f9ebd5a&#010;&#010;Branch: refs/heads/master&#010;Commit: 3f9ebd5a0a9e23e5b8c2f10abdf0c1c6ca4eda90&#010;Parents: 061eb24&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:47:16 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-rest-servlet/pom.xml | 43 +++++++++++++++++++-&#010; 1 file changed, 42 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3f9ebd5a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-rest-servlet/pom.xml b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;index 260d778..aac0973 100755&#010;--- a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;+++ b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;@@ -163,6 +163,48 @@&#010;         &lt;/dependency&gt;&#010;       &lt;/dependencies&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build-jetty&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;dependencies&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;arquillian-jetty-embedded-9&lt;/artifactId&gt;&#010;+          &lt;version&gt;1.0.0.CR2&lt;/version&gt;&#010;+          &lt;scope&gt;test&lt;/scope&gt;&#010;+          &lt;exclusions&gt;&#010;+            &lt;exclusion&gt;&#010;+              &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+              &lt;artifactId&gt;arquillian-container-spi&lt;/artifactId&gt;&#010;+            &lt;/exclusion&gt;&#010;+          &lt;/exclusions&gt;&#010;+        &lt;/dependency&gt;&#010;+      &lt;/dependencies&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;@@ -175,5 +217,4 @@&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cd0654af72ef94f628420b970c145ccf5%40git.apache.org%3E,2017-04-14 10:57,commits,10.0,338.0,  [10/20] camel git commit: CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9
55,339.0,davscl...@apache.org,"CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/fdeb3475&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/fdeb3475&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/fdeb3475&#010;&#010;Branch: refs/heads/master&#010;Commit: fdeb34752943b2bf4723407b99da875708fae852&#010;Parents: 1b8949f&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-pojo-messaging/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/fdeb3475/examples/camel-example-pojo-messaging/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-pojo-messaging/pom.xml b/examples/camel-example-pojo-messaging/pom.xml&#010;index f71b3b7..34b1bd6 100644&#010;--- a/examples/camel-example-pojo-messaging/pom.xml&#010;+++ b/examples/camel-example-pojo-messaging/pom.xml&#010;@@ -140,4 +140,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C7bc5feb92c534ce9a2bf51de8ce26017%40git.apache.org%3E,2017-04-14 10:57,commits,10.0,339.0,  [11/20] camel git commit: CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9
56,340.0,davscl...@apache.org,"CAMEL-10141: make camel-example-management tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/9e7b6c6c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/9e7b6c6c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/9e7b6c6c&#010;&#010;Branch: refs/heads/master&#010;Commit: 9e7b6c6c7bb423f36dd3a6db98635e2a95a98acc&#010;Parents: fdeb347&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-management/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/9e7b6c6c/examples/camel-example-management/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-management/pom.xml b/examples/camel-example-management/pom.xml&#010;index 66f0b1f..d8db087 100644&#010;--- a/examples/camel-example-management/pom.xml&#010;+++ b/examples/camel-example-management/pom.xml&#010;@@ -129,4 +129,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C30204927025749bbbc58720eb5a3f27c%40git.apache.org%3E,2017-04-14 10:57,commits,10.0,340.0,  [12/20] camel git commit: CAMEL-10141: make camel-example-management tests pass on Java 9
57,341.0,davscl...@apache.org,"CAMEL-10141: make camel-example-spring-jms tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3d9a999c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3d9a999c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3d9a999c&#010;&#010;Branch: refs/heads/master&#010;Commit: 3d9a999c035aa10bff547d0d3ee053528b615919&#010;Parents: 9e7b6c6&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-spring-jms/pom.xml | 17 ++++++++++++++++-&#010; 1 file changed, 16 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3d9a999c/examples/camel-example-spring-jms/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-spring-jms/pom.xml b/examples/camel-example-spring-jms/pom.xml&#010;index da360e0..af430aa 100644&#010;--- a/examples/camel-example-spring-jms/pom.xml&#010;+++ b/examples/camel-example-spring-jms/pom.xml&#010;@@ -128,6 +128,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.client.CamelClientEndpoint&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010;   &lt;build&gt;&#010; &#010;@@ -168,5 +184,4 @@&#010;     &lt;/plugins&gt;&#010; &#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cdf7aef9137e64879b2a51fa8161c519e%40git.apache.org%3E,2017-04-14 10:57,commits,10.0,341.0,  [13/20] camel git commit: CAMEL-10141: make camel-example-spring-jms tests pass on Java 9
58,342.0,davscl...@apache.org,"CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/047761a7&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/047761a7&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/047761a7&#010;&#010;Branch: refs/heads/master&#010;Commit: 047761a787d646759069e1ac318ba3523816ec08&#010;Parents: 3d9a999&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:50 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-osgi-rmi/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/047761a7/examples/camel-example-osgi-rmi/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-osgi-rmi/pom.xml b/examples/camel-example-osgi-rmi/pom.xml&#010;index dce39d2..82c588d 100644&#010;--- a/examples/camel-example-osgi-rmi/pom.xml&#010;+++ b/examples/camel-example-osgi-rmi/pom.xml&#010;@@ -87,6 +87,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.osgi.HelloClient&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ca519cd2689fb4af09c8ded1b17b83f65%40git.apache.org%3E,2017-04-14 10:57,commits,10.0,342.0,  [14/20] camel git commit: CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9
59,331.0,davscl...@apache.org,"CAMEL-10968: make camel-cxf-transport tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/a01f14cd&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/a01f14cd&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/a01f14cd&#010;&#010;Branch: refs/heads/master&#010;Commit: a01f14cdda7b576e42be4357625fec374555f6ae&#010;Parents: 7b2d32e&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:06:00 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; components/camel-cxf-transport/pom.xml | 20 ++++++++++++++++++++&#010; 1 file changed, 20 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/a01f14cd/components/camel-cxf-transport/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/components/camel-cxf-transport/pom.xml b/components/camel-cxf-transport/pom.xml&#010;index 93d650b..bc76a6a 100644&#010;--- a/components/camel-cxf-transport/pom.xml&#010;+++ b/components/camel-cxf-transport/pom.xml&#010;@@ -215,5 +215,25 @@&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;+  &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;reuseForks&gt;true&lt;/reuseForks&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C8944f48bb72241b994053539c7e0edf4%40git.apache.org%3E,2017-04-14 10:57,commits,11.0,331.0,  [03/20] camel git commit: CAMEL-10968: make camel-cxf-transport tests pass on Java 9
60,332.0,davscl...@apache.org,"CAMEL-10141: make camel-example-loan-broker-jms tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/e6964f1e&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/e6964f1e&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/e6964f1e&#010;&#010;Branch: refs/heads/master&#010;Commit: e6964f1e74bc2a2f9d76450447332ce03570cf53&#010;Parents: 3f9ebd5&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:48:15 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-loan-broker-jms/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/e6964f1e/examples/camel-example-loan-broker-jms/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-loan-broker-jms/pom.xml b/examples/camel-example-loan-broker-jms/pom.xml&#010;index 186036b..0668ecf 100644&#010;--- a/examples/camel-example-loan-broker-jms/pom.xml&#010;+++ b/examples/camel-example-loan-broker-jms/pom.xml&#010;@@ -177,6 +177,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.loanbroker.Client&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C9940ce4909db4f58bedb1ca432783218%40git.apache.org%3E,2017-04-14 10:57,commits,11.0,332.0,  [04/20] camel git commit: CAMEL-10141: make camel-example-loan-broker-jms tests pass on Java 9
61,333.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-example tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/1e31f1e4&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/1e31f1e4&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/1e31f1e4&#010;&#010;Branch: refs/heads/master&#010;Commit: 1e31f1e4265f4271d82f54f86cb0ba85f426f54d&#010;Parents: 6a02de1&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Thu Apr 13 18:35:07 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-xml/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/1e31f1e4/examples/camel-example-cdi-xml/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-xml/pom.xml b/examples/camel-example-cdi-xml/pom.xml&#010;index e365cc2..9758b4a 100755&#010;--- a/examples/camel-example-cdi-xml/pom.xml&#010;+++ b/examples/camel-example-cdi-xml/pom.xml&#010;@@ -114,4 +114,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ce4eb9713620046ea85a7803fdcaefd90%40git.apache.org%3E,2017-04-14 10:57,commits,11.0,333.0,  [05/20] camel git commit: CAMEL-10141: make camel-example-cdi-example tests pass on Java 9
62,334.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-test tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/d590e921&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/d590e921&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/d590e921&#010;&#010;Branch: refs/heads/master&#010;Commit: d590e92118a20b07c8a7d136d754a26e5055af86&#010;Parents: 1e31f1e&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:45:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-test/pom.xml | 19 ++++++++++++++++++-&#010; 1 file changed, 18 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/d590e921/examples/camel-example-cdi-test/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-test/pom.xml b/examples/camel-example-cdi-test/pom.xml&#010;index d1b5765..697847c 100644&#010;--- a/examples/camel-example-cdi-test/pom.xml&#010;+++ b/examples/camel-example-cdi-test/pom.xml&#010;@@ -106,7 +106,24 @@&#010;         &lt;/dependencies&gt;&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;-&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C17603fa71f9f4446851fd50f33bc248a%40git.apache.org%3E,2017-04-14 10:57,commits,11.0,334.0,  [06/20] camel git commit: CAMEL-10141: make camel-example-cdi-test tests pass on Java 9
63,335.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-metrics tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/73b61ef3&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/73b61ef3&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/73b61ef3&#010;&#010;Branch: refs/heads/master&#010;Commit: 73b61ef32533aac448fe5c31d2f28f0373ad5d90&#010;Parents: d590e92&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:46:37 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-metrics/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/73b61ef3/examples/camel-example-cdi-metrics/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-metrics/pom.xml b/examples/camel-example-cdi-metrics/pom.xml&#010;index 08401f7..5f09f7c 100755&#010;--- a/examples/camel-example-cdi-metrics/pom.xml&#010;+++ b/examples/camel-example-cdi-metrics/pom.xml&#010;@@ -127,4 +127,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C17d5bb4af9784983a8ac362b3e589ea3%40git.apache.org%3E,2017-04-14 10:57,commits,11.0,335.0,  [07/20] camel git commit: CAMEL-10141: make camel-example-cdi-metrics tests pass on Java 9
64,336.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-properties tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/061eb241&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/061eb241&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/061eb241&#010;&#010;Branch: refs/heads/master&#010;Commit: 061eb2416cd5863cf845b330740cacaed83321cd&#010;Parents: 73b61ef&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:46:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-properties/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/061eb241/examples/camel-example-cdi-properties/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-properties/pom.xml b/examples/camel-example-cdi-properties/pom.xml&#010;index 24adc77..ae2ae06 100755&#010;--- a/examples/camel-example-cdi-properties/pom.xml&#010;+++ b/examples/camel-example-cdi-properties/pom.xml&#010;@@ -124,4 +124,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C4901736312b14536a40a9ab29e998af5%40git.apache.org%3E,2017-04-14 10:57,commits,11.0,336.0,  [08/20] camel git commit: CAMEL-10141: make camel-example-cdi-properties tests pass on Java 9
65,337.0,davscl...@apache.org,"CAMEL-10141: make camel-example-reportincident tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/1b8949f5&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/1b8949f5&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/1b8949f5&#010;&#010;Branch: refs/heads/master&#010;Commit: 1b8949f593eed1fb0b97bcf0d138f2be113d0d2e&#010;Parents: e6964f1&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:59:57 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-reportincident/pom.xml | 2 +-&#010; 1 file changed, 1 insertion(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/1b8949f5/examples/camel-example-reportincident/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-reportincident/pom.xml b/examples/camel-example-reportincident/pom.xml&#010;index 92091d7..b820ac1 100755&#010;--- a/examples/camel-example-reportincident/pom.xml&#010;+++ b/examples/camel-example-reportincident/pom.xml&#010;@@ -208,7 +208,7 @@&#010;           &lt;plugin&gt;&#010;             &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;             &lt;configuration&gt;&#010;-              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.base/java.lang.invoke=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED&lt;/argLine&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.base/java.lang.invoke=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED&#010;--add-opens java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;             &lt;/configuration&gt;&#010;           &lt;/plugin&gt;&#010;         &lt;/plugins&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C4b84d50cca2f408189db81727d97a39f%40git.apache.org%3E,2017-04-14 10:57,commits,11.0,337.0,  [09/20] camel git commit: CAMEL-10141: make camel-example-reportincident tests pass on Java 9
66,338.0,davscl...@apache.org,"CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3f9ebd5a&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3f9ebd5a&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3f9ebd5a&#010;&#010;Branch: refs/heads/master&#010;Commit: 3f9ebd5a0a9e23e5b8c2f10abdf0c1c6ca4eda90&#010;Parents: 061eb24&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:47:16 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-rest-servlet/pom.xml | 43 +++++++++++++++++++-&#010; 1 file changed, 42 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3f9ebd5a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-rest-servlet/pom.xml b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;index 260d778..aac0973 100755&#010;--- a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;+++ b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;@@ -163,6 +163,48 @@&#010;         &lt;/dependency&gt;&#010;       &lt;/dependencies&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build-jetty&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;dependencies&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;arquillian-jetty-embedded-9&lt;/artifactId&gt;&#010;+          &lt;version&gt;1.0.0.CR2&lt;/version&gt;&#010;+          &lt;scope&gt;test&lt;/scope&gt;&#010;+          &lt;exclusions&gt;&#010;+            &lt;exclusion&gt;&#010;+              &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+              &lt;artifactId&gt;arquillian-container-spi&lt;/artifactId&gt;&#010;+            &lt;/exclusion&gt;&#010;+          &lt;/exclusions&gt;&#010;+        &lt;/dependency&gt;&#010;+      &lt;/dependencies&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;@@ -175,5 +217,4 @@&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cd0654af72ef94f628420b970c145ccf5%40git.apache.org%3E,2017-04-14 10:57,commits,11.0,338.0,  [10/20] camel git commit: CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9
67,339.0,davscl...@apache.org,"CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/fdeb3475&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/fdeb3475&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/fdeb3475&#010;&#010;Branch: refs/heads/master&#010;Commit: fdeb34752943b2bf4723407b99da875708fae852&#010;Parents: 1b8949f&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-pojo-messaging/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/fdeb3475/examples/camel-example-pojo-messaging/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-pojo-messaging/pom.xml b/examples/camel-example-pojo-messaging/pom.xml&#010;index f71b3b7..34b1bd6 100644&#010;--- a/examples/camel-example-pojo-messaging/pom.xml&#010;+++ b/examples/camel-example-pojo-messaging/pom.xml&#010;@@ -140,4 +140,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C7bc5feb92c534ce9a2bf51de8ce26017%40git.apache.org%3E,2017-04-14 10:57,commits,11.0,339.0,  [11/20] camel git commit: CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9
68,340.0,davscl...@apache.org,"CAMEL-10141: make camel-example-management tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/9e7b6c6c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/9e7b6c6c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/9e7b6c6c&#010;&#010;Branch: refs/heads/master&#010;Commit: 9e7b6c6c7bb423f36dd3a6db98635e2a95a98acc&#010;Parents: fdeb347&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-management/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/9e7b6c6c/examples/camel-example-management/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-management/pom.xml b/examples/camel-example-management/pom.xml&#010;index 66f0b1f..d8db087 100644&#010;--- a/examples/camel-example-management/pom.xml&#010;+++ b/examples/camel-example-management/pom.xml&#010;@@ -129,4 +129,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C30204927025749bbbc58720eb5a3f27c%40git.apache.org%3E,2017-04-14 10:57,commits,11.0,340.0,  [12/20] camel git commit: CAMEL-10141: make camel-example-management tests pass on Java 9
69,341.0,davscl...@apache.org,"CAMEL-10141: make camel-example-spring-jms tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3d9a999c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3d9a999c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3d9a999c&#010;&#010;Branch: refs/heads/master&#010;Commit: 3d9a999c035aa10bff547d0d3ee053528b615919&#010;Parents: 9e7b6c6&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-spring-jms/pom.xml | 17 ++++++++++++++++-&#010; 1 file changed, 16 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3d9a999c/examples/camel-example-spring-jms/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-spring-jms/pom.xml b/examples/camel-example-spring-jms/pom.xml&#010;index da360e0..af430aa 100644&#010;--- a/examples/camel-example-spring-jms/pom.xml&#010;+++ b/examples/camel-example-spring-jms/pom.xml&#010;@@ -128,6 +128,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.client.CamelClientEndpoint&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010;   &lt;build&gt;&#010; &#010;@@ -168,5 +184,4 @@&#010;     &lt;/plugins&gt;&#010; &#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cdf7aef9137e64879b2a51fa8161c519e%40git.apache.org%3E,2017-04-14 10:57,commits,11.0,341.0,  [13/20] camel git commit: CAMEL-10141: make camel-example-spring-jms tests pass on Java 9
70,342.0,davscl...@apache.org,"CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/047761a7&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/047761a7&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/047761a7&#010;&#010;Branch: refs/heads/master&#010;Commit: 047761a787d646759069e1ac318ba3523816ec08&#010;Parents: 3d9a999&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:50 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-osgi-rmi/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/047761a7/examples/camel-example-osgi-rmi/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-osgi-rmi/pom.xml b/examples/camel-example-osgi-rmi/pom.xml&#010;index dce39d2..82c588d 100644&#010;--- a/examples/camel-example-osgi-rmi/pom.xml&#010;+++ b/examples/camel-example-osgi-rmi/pom.xml&#010;@@ -87,6 +87,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.osgi.HelloClient&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ca519cd2689fb4af09c8ded1b17b83f65%40git.apache.org%3E,2017-04-14 10:57,commits,11.0,342.0,  [14/20] camel git commit: CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9
71,332.0,davscl...@apache.org,"CAMEL-10141: make camel-example-loan-broker-jms tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/e6964f1e&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/e6964f1e&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/e6964f1e&#010;&#010;Branch: refs/heads/master&#010;Commit: e6964f1e74bc2a2f9d76450447332ce03570cf53&#010;Parents: 3f9ebd5&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:48:15 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-loan-broker-jms/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/e6964f1e/examples/camel-example-loan-broker-jms/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-loan-broker-jms/pom.xml b/examples/camel-example-loan-broker-jms/pom.xml&#010;index 186036b..0668ecf 100644&#010;--- a/examples/camel-example-loan-broker-jms/pom.xml&#010;+++ b/examples/camel-example-loan-broker-jms/pom.xml&#010;@@ -177,6 +177,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.loanbroker.Client&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C9940ce4909db4f58bedb1ca432783218%40git.apache.org%3E,2017-04-14 10:57,commits,12.0,332.0,  [04/20] camel git commit: CAMEL-10141: make camel-example-loan-broker-jms tests pass on Java 9
72,333.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-example tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/1e31f1e4&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/1e31f1e4&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/1e31f1e4&#010;&#010;Branch: refs/heads/master&#010;Commit: 1e31f1e4265f4271d82f54f86cb0ba85f426f54d&#010;Parents: 6a02de1&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Thu Apr 13 18:35:07 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-xml/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/1e31f1e4/examples/camel-example-cdi-xml/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-xml/pom.xml b/examples/camel-example-cdi-xml/pom.xml&#010;index e365cc2..9758b4a 100755&#010;--- a/examples/camel-example-cdi-xml/pom.xml&#010;+++ b/examples/camel-example-cdi-xml/pom.xml&#010;@@ -114,4 +114,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ce4eb9713620046ea85a7803fdcaefd90%40git.apache.org%3E,2017-04-14 10:57,commits,12.0,333.0,  [05/20] camel git commit: CAMEL-10141: make camel-example-cdi-example tests pass on Java 9
73,334.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-test tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/d590e921&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/d590e921&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/d590e921&#010;&#010;Branch: refs/heads/master&#010;Commit: d590e92118a20b07c8a7d136d754a26e5055af86&#010;Parents: 1e31f1e&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:45:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-test/pom.xml | 19 ++++++++++++++++++-&#010; 1 file changed, 18 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/d590e921/examples/camel-example-cdi-test/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-test/pom.xml b/examples/camel-example-cdi-test/pom.xml&#010;index d1b5765..697847c 100644&#010;--- a/examples/camel-example-cdi-test/pom.xml&#010;+++ b/examples/camel-example-cdi-test/pom.xml&#010;@@ -106,7 +106,24 @@&#010;         &lt;/dependencies&gt;&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;-&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C17603fa71f9f4446851fd50f33bc248a%40git.apache.org%3E,2017-04-14 10:57,commits,12.0,334.0,  [06/20] camel git commit: CAMEL-10141: make camel-example-cdi-test tests pass on Java 9
74,335.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-metrics tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/73b61ef3&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/73b61ef3&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/73b61ef3&#010;&#010;Branch: refs/heads/master&#010;Commit: 73b61ef32533aac448fe5c31d2f28f0373ad5d90&#010;Parents: d590e92&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:46:37 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-metrics/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/73b61ef3/examples/camel-example-cdi-metrics/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-metrics/pom.xml b/examples/camel-example-cdi-metrics/pom.xml&#010;index 08401f7..5f09f7c 100755&#010;--- a/examples/camel-example-cdi-metrics/pom.xml&#010;+++ b/examples/camel-example-cdi-metrics/pom.xml&#010;@@ -127,4 +127,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C17d5bb4af9784983a8ac362b3e589ea3%40git.apache.org%3E,2017-04-14 10:57,commits,12.0,335.0,  [07/20] camel git commit: CAMEL-10141: make camel-example-cdi-metrics tests pass on Java 9
75,336.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-properties tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/061eb241&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/061eb241&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/061eb241&#010;&#010;Branch: refs/heads/master&#010;Commit: 061eb2416cd5863cf845b330740cacaed83321cd&#010;Parents: 73b61ef&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:46:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-properties/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/061eb241/examples/camel-example-cdi-properties/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-properties/pom.xml b/examples/camel-example-cdi-properties/pom.xml&#010;index 24adc77..ae2ae06 100755&#010;--- a/examples/camel-example-cdi-properties/pom.xml&#010;+++ b/examples/camel-example-cdi-properties/pom.xml&#010;@@ -124,4 +124,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C4901736312b14536a40a9ab29e998af5%40git.apache.org%3E,2017-04-14 10:57,commits,12.0,336.0,  [08/20] camel git commit: CAMEL-10141: make camel-example-cdi-properties tests pass on Java 9
76,337.0,davscl...@apache.org,"CAMEL-10141: make camel-example-reportincident tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/1b8949f5&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/1b8949f5&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/1b8949f5&#010;&#010;Branch: refs/heads/master&#010;Commit: 1b8949f593eed1fb0b97bcf0d138f2be113d0d2e&#010;Parents: e6964f1&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:59:57 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-reportincident/pom.xml | 2 +-&#010; 1 file changed, 1 insertion(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/1b8949f5/examples/camel-example-reportincident/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-reportincident/pom.xml b/examples/camel-example-reportincident/pom.xml&#010;index 92091d7..b820ac1 100755&#010;--- a/examples/camel-example-reportincident/pom.xml&#010;+++ b/examples/camel-example-reportincident/pom.xml&#010;@@ -208,7 +208,7 @@&#010;           &lt;plugin&gt;&#010;             &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;             &lt;configuration&gt;&#010;-              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.base/java.lang.invoke=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED&lt;/argLine&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.base/java.lang.invoke=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED&#010;--add-opens java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;             &lt;/configuration&gt;&#010;           &lt;/plugin&gt;&#010;         &lt;/plugins&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C4b84d50cca2f408189db81727d97a39f%40git.apache.org%3E,2017-04-14 10:57,commits,12.0,337.0,  [09/20] camel git commit: CAMEL-10141: make camel-example-reportincident tests pass on Java 9
77,338.0,davscl...@apache.org,"CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3f9ebd5a&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3f9ebd5a&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3f9ebd5a&#010;&#010;Branch: refs/heads/master&#010;Commit: 3f9ebd5a0a9e23e5b8c2f10abdf0c1c6ca4eda90&#010;Parents: 061eb24&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:47:16 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-rest-servlet/pom.xml | 43 +++++++++++++++++++-&#010; 1 file changed, 42 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3f9ebd5a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-rest-servlet/pom.xml b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;index 260d778..aac0973 100755&#010;--- a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;+++ b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;@@ -163,6 +163,48 @@&#010;         &lt;/dependency&gt;&#010;       &lt;/dependencies&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build-jetty&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;dependencies&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;arquillian-jetty-embedded-9&lt;/artifactId&gt;&#010;+          &lt;version&gt;1.0.0.CR2&lt;/version&gt;&#010;+          &lt;scope&gt;test&lt;/scope&gt;&#010;+          &lt;exclusions&gt;&#010;+            &lt;exclusion&gt;&#010;+              &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+              &lt;artifactId&gt;arquillian-container-spi&lt;/artifactId&gt;&#010;+            &lt;/exclusion&gt;&#010;+          &lt;/exclusions&gt;&#010;+        &lt;/dependency&gt;&#010;+      &lt;/dependencies&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;@@ -175,5 +217,4 @@&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cd0654af72ef94f628420b970c145ccf5%40git.apache.org%3E,2017-04-14 10:57,commits,12.0,338.0,  [10/20] camel git commit: CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9
78,339.0,davscl...@apache.org,"CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/fdeb3475&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/fdeb3475&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/fdeb3475&#010;&#010;Branch: refs/heads/master&#010;Commit: fdeb34752943b2bf4723407b99da875708fae852&#010;Parents: 1b8949f&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-pojo-messaging/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/fdeb3475/examples/camel-example-pojo-messaging/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-pojo-messaging/pom.xml b/examples/camel-example-pojo-messaging/pom.xml&#010;index f71b3b7..34b1bd6 100644&#010;--- a/examples/camel-example-pojo-messaging/pom.xml&#010;+++ b/examples/camel-example-pojo-messaging/pom.xml&#010;@@ -140,4 +140,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C7bc5feb92c534ce9a2bf51de8ce26017%40git.apache.org%3E,2017-04-14 10:57,commits,12.0,339.0,  [11/20] camel git commit: CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9
79,340.0,davscl...@apache.org,"CAMEL-10141: make camel-example-management tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/9e7b6c6c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/9e7b6c6c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/9e7b6c6c&#010;&#010;Branch: refs/heads/master&#010;Commit: 9e7b6c6c7bb423f36dd3a6db98635e2a95a98acc&#010;Parents: fdeb347&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-management/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/9e7b6c6c/examples/camel-example-management/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-management/pom.xml b/examples/camel-example-management/pom.xml&#010;index 66f0b1f..d8db087 100644&#010;--- a/examples/camel-example-management/pom.xml&#010;+++ b/examples/camel-example-management/pom.xml&#010;@@ -129,4 +129,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C30204927025749bbbc58720eb5a3f27c%40git.apache.org%3E,2017-04-14 10:57,commits,12.0,340.0,  [12/20] camel git commit: CAMEL-10141: make camel-example-management tests pass on Java 9
80,341.0,davscl...@apache.org,"CAMEL-10141: make camel-example-spring-jms tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3d9a999c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3d9a999c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3d9a999c&#010;&#010;Branch: refs/heads/master&#010;Commit: 3d9a999c035aa10bff547d0d3ee053528b615919&#010;Parents: 9e7b6c6&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-spring-jms/pom.xml | 17 ++++++++++++++++-&#010; 1 file changed, 16 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3d9a999c/examples/camel-example-spring-jms/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-spring-jms/pom.xml b/examples/camel-example-spring-jms/pom.xml&#010;index da360e0..af430aa 100644&#010;--- a/examples/camel-example-spring-jms/pom.xml&#010;+++ b/examples/camel-example-spring-jms/pom.xml&#010;@@ -128,6 +128,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.client.CamelClientEndpoint&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010;   &lt;build&gt;&#010; &#010;@@ -168,5 +184,4 @@&#010;     &lt;/plugins&gt;&#010; &#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cdf7aef9137e64879b2a51fa8161c519e%40git.apache.org%3E,2017-04-14 10:57,commits,12.0,341.0,  [13/20] camel git commit: CAMEL-10141: make camel-example-spring-jms tests pass on Java 9
81,342.0,davscl...@apache.org,"CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/047761a7&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/047761a7&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/047761a7&#010;&#010;Branch: refs/heads/master&#010;Commit: 047761a787d646759069e1ac318ba3523816ec08&#010;Parents: 3d9a999&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:50 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-osgi-rmi/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/047761a7/examples/camel-example-osgi-rmi/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-osgi-rmi/pom.xml b/examples/camel-example-osgi-rmi/pom.xml&#010;index dce39d2..82c588d 100644&#010;--- a/examples/camel-example-osgi-rmi/pom.xml&#010;+++ b/examples/camel-example-osgi-rmi/pom.xml&#010;@@ -87,6 +87,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.osgi.HelloClient&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ca519cd2689fb4af09c8ded1b17b83f65%40git.apache.org%3E,2017-04-14 10:57,commits,12.0,342.0,  [14/20] camel git commit: CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9
82,333.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-example tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/1e31f1e4&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/1e31f1e4&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/1e31f1e4&#010;&#010;Branch: refs/heads/master&#010;Commit: 1e31f1e4265f4271d82f54f86cb0ba85f426f54d&#010;Parents: 6a02de1&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Thu Apr 13 18:35:07 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-xml/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/1e31f1e4/examples/camel-example-cdi-xml/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-xml/pom.xml b/examples/camel-example-cdi-xml/pom.xml&#010;index e365cc2..9758b4a 100755&#010;--- a/examples/camel-example-cdi-xml/pom.xml&#010;+++ b/examples/camel-example-cdi-xml/pom.xml&#010;@@ -114,4 +114,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ce4eb9713620046ea85a7803fdcaefd90%40git.apache.org%3E,2017-04-14 10:57,commits,13.0,333.0,  [05/20] camel git commit: CAMEL-10141: make camel-example-cdi-example tests pass on Java 9
83,334.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-test tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/d590e921&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/d590e921&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/d590e921&#010;&#010;Branch: refs/heads/master&#010;Commit: d590e92118a20b07c8a7d136d754a26e5055af86&#010;Parents: 1e31f1e&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:45:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-test/pom.xml | 19 ++++++++++++++++++-&#010; 1 file changed, 18 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/d590e921/examples/camel-example-cdi-test/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-test/pom.xml b/examples/camel-example-cdi-test/pom.xml&#010;index d1b5765..697847c 100644&#010;--- a/examples/camel-example-cdi-test/pom.xml&#010;+++ b/examples/camel-example-cdi-test/pom.xml&#010;@@ -106,7 +106,24 @@&#010;         &lt;/dependencies&gt;&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;-&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C17603fa71f9f4446851fd50f33bc248a%40git.apache.org%3E,2017-04-14 10:57,commits,13.0,334.0,  [06/20] camel git commit: CAMEL-10141: make camel-example-cdi-test tests pass on Java 9
84,335.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-metrics tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/73b61ef3&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/73b61ef3&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/73b61ef3&#010;&#010;Branch: refs/heads/master&#010;Commit: 73b61ef32533aac448fe5c31d2f28f0373ad5d90&#010;Parents: d590e92&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:46:37 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-metrics/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/73b61ef3/examples/camel-example-cdi-metrics/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-metrics/pom.xml b/examples/camel-example-cdi-metrics/pom.xml&#010;index 08401f7..5f09f7c 100755&#010;--- a/examples/camel-example-cdi-metrics/pom.xml&#010;+++ b/examples/camel-example-cdi-metrics/pom.xml&#010;@@ -127,4 +127,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C17d5bb4af9784983a8ac362b3e589ea3%40git.apache.org%3E,2017-04-14 10:57,commits,13.0,335.0,  [07/20] camel git commit: CAMEL-10141: make camel-example-cdi-metrics tests pass on Java 9
85,336.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-properties tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/061eb241&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/061eb241&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/061eb241&#010;&#010;Branch: refs/heads/master&#010;Commit: 061eb2416cd5863cf845b330740cacaed83321cd&#010;Parents: 73b61ef&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:46:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-properties/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/061eb241/examples/camel-example-cdi-properties/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-properties/pom.xml b/examples/camel-example-cdi-properties/pom.xml&#010;index 24adc77..ae2ae06 100755&#010;--- a/examples/camel-example-cdi-properties/pom.xml&#010;+++ b/examples/camel-example-cdi-properties/pom.xml&#010;@@ -124,4 +124,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C4901736312b14536a40a9ab29e998af5%40git.apache.org%3E,2017-04-14 10:57,commits,13.0,336.0,  [08/20] camel git commit: CAMEL-10141: make camel-example-cdi-properties tests pass on Java 9
86,337.0,davscl...@apache.org,"CAMEL-10141: make camel-example-reportincident tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/1b8949f5&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/1b8949f5&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/1b8949f5&#010;&#010;Branch: refs/heads/master&#010;Commit: 1b8949f593eed1fb0b97bcf0d138f2be113d0d2e&#010;Parents: e6964f1&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:59:57 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-reportincident/pom.xml | 2 +-&#010; 1 file changed, 1 insertion(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/1b8949f5/examples/camel-example-reportincident/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-reportincident/pom.xml b/examples/camel-example-reportincident/pom.xml&#010;index 92091d7..b820ac1 100755&#010;--- a/examples/camel-example-reportincident/pom.xml&#010;+++ b/examples/camel-example-reportincident/pom.xml&#010;@@ -208,7 +208,7 @@&#010;           &lt;plugin&gt;&#010;             &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;             &lt;configuration&gt;&#010;-              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.base/java.lang.invoke=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED&lt;/argLine&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.base/java.lang.invoke=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED&#010;--add-opens java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;             &lt;/configuration&gt;&#010;           &lt;/plugin&gt;&#010;         &lt;/plugins&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C4b84d50cca2f408189db81727d97a39f%40git.apache.org%3E,2017-04-14 10:57,commits,13.0,337.0,  [09/20] camel git commit: CAMEL-10141: make camel-example-reportincident tests pass on Java 9
87,338.0,davscl...@apache.org,"CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3f9ebd5a&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3f9ebd5a&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3f9ebd5a&#010;&#010;Branch: refs/heads/master&#010;Commit: 3f9ebd5a0a9e23e5b8c2f10abdf0c1c6ca4eda90&#010;Parents: 061eb24&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:47:16 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-rest-servlet/pom.xml | 43 +++++++++++++++++++-&#010; 1 file changed, 42 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3f9ebd5a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-rest-servlet/pom.xml b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;index 260d778..aac0973 100755&#010;--- a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;+++ b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;@@ -163,6 +163,48 @@&#010;         &lt;/dependency&gt;&#010;       &lt;/dependencies&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build-jetty&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;dependencies&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;arquillian-jetty-embedded-9&lt;/artifactId&gt;&#010;+          &lt;version&gt;1.0.0.CR2&lt;/version&gt;&#010;+          &lt;scope&gt;test&lt;/scope&gt;&#010;+          &lt;exclusions&gt;&#010;+            &lt;exclusion&gt;&#010;+              &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+              &lt;artifactId&gt;arquillian-container-spi&lt;/artifactId&gt;&#010;+            &lt;/exclusion&gt;&#010;+          &lt;/exclusions&gt;&#010;+        &lt;/dependency&gt;&#010;+      &lt;/dependencies&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;@@ -175,5 +217,4 @@&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cd0654af72ef94f628420b970c145ccf5%40git.apache.org%3E,2017-04-14 10:57,commits,13.0,338.0,  [10/20] camel git commit: CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9
88,339.0,davscl...@apache.org,"CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/fdeb3475&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/fdeb3475&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/fdeb3475&#010;&#010;Branch: refs/heads/master&#010;Commit: fdeb34752943b2bf4723407b99da875708fae852&#010;Parents: 1b8949f&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-pojo-messaging/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/fdeb3475/examples/camel-example-pojo-messaging/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-pojo-messaging/pom.xml b/examples/camel-example-pojo-messaging/pom.xml&#010;index f71b3b7..34b1bd6 100644&#010;--- a/examples/camel-example-pojo-messaging/pom.xml&#010;+++ b/examples/camel-example-pojo-messaging/pom.xml&#010;@@ -140,4 +140,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C7bc5feb92c534ce9a2bf51de8ce26017%40git.apache.org%3E,2017-04-14 10:57,commits,13.0,339.0,  [11/20] camel git commit: CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9
89,340.0,davscl...@apache.org,"CAMEL-10141: make camel-example-management tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/9e7b6c6c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/9e7b6c6c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/9e7b6c6c&#010;&#010;Branch: refs/heads/master&#010;Commit: 9e7b6c6c7bb423f36dd3a6db98635e2a95a98acc&#010;Parents: fdeb347&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-management/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/9e7b6c6c/examples/camel-example-management/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-management/pom.xml b/examples/camel-example-management/pom.xml&#010;index 66f0b1f..d8db087 100644&#010;--- a/examples/camel-example-management/pom.xml&#010;+++ b/examples/camel-example-management/pom.xml&#010;@@ -129,4 +129,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C30204927025749bbbc58720eb5a3f27c%40git.apache.org%3E,2017-04-14 10:57,commits,13.0,340.0,  [12/20] camel git commit: CAMEL-10141: make camel-example-management tests pass on Java 9
90,341.0,davscl...@apache.org,"CAMEL-10141: make camel-example-spring-jms tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3d9a999c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3d9a999c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3d9a999c&#010;&#010;Branch: refs/heads/master&#010;Commit: 3d9a999c035aa10bff547d0d3ee053528b615919&#010;Parents: 9e7b6c6&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-spring-jms/pom.xml | 17 ++++++++++++++++-&#010; 1 file changed, 16 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3d9a999c/examples/camel-example-spring-jms/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-spring-jms/pom.xml b/examples/camel-example-spring-jms/pom.xml&#010;index da360e0..af430aa 100644&#010;--- a/examples/camel-example-spring-jms/pom.xml&#010;+++ b/examples/camel-example-spring-jms/pom.xml&#010;@@ -128,6 +128,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.client.CamelClientEndpoint&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010;   &lt;build&gt;&#010; &#010;@@ -168,5 +184,4 @@&#010;     &lt;/plugins&gt;&#010; &#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cdf7aef9137e64879b2a51fa8161c519e%40git.apache.org%3E,2017-04-14 10:57,commits,13.0,341.0,  [13/20] camel git commit: CAMEL-10141: make camel-example-spring-jms tests pass on Java 9
91,342.0,davscl...@apache.org,"CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/047761a7&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/047761a7&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/047761a7&#010;&#010;Branch: refs/heads/master&#010;Commit: 047761a787d646759069e1ac318ba3523816ec08&#010;Parents: 3d9a999&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:50 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-osgi-rmi/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/047761a7/examples/camel-example-osgi-rmi/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-osgi-rmi/pom.xml b/examples/camel-example-osgi-rmi/pom.xml&#010;index dce39d2..82c588d 100644&#010;--- a/examples/camel-example-osgi-rmi/pom.xml&#010;+++ b/examples/camel-example-osgi-rmi/pom.xml&#010;@@ -87,6 +87,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.osgi.HelloClient&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ca519cd2689fb4af09c8ded1b17b83f65%40git.apache.org%3E,2017-04-14 10:57,commits,13.0,342.0,  [14/20] camel git commit: CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9
92,334.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-test tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/d590e921&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/d590e921&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/d590e921&#010;&#010;Branch: refs/heads/master&#010;Commit: d590e92118a20b07c8a7d136d754a26e5055af86&#010;Parents: 1e31f1e&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:45:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-test/pom.xml | 19 ++++++++++++++++++-&#010; 1 file changed, 18 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/d590e921/examples/camel-example-cdi-test/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-test/pom.xml b/examples/camel-example-cdi-test/pom.xml&#010;index d1b5765..697847c 100644&#010;--- a/examples/camel-example-cdi-test/pom.xml&#010;+++ b/examples/camel-example-cdi-test/pom.xml&#010;@@ -106,7 +106,24 @@&#010;         &lt;/dependencies&gt;&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;-&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C17603fa71f9f4446851fd50f33bc248a%40git.apache.org%3E,2017-04-14 10:57,commits,14.0,334.0,  [06/20] camel git commit: CAMEL-10141: make camel-example-cdi-test tests pass on Java 9
93,335.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-metrics tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/73b61ef3&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/73b61ef3&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/73b61ef3&#010;&#010;Branch: refs/heads/master&#010;Commit: 73b61ef32533aac448fe5c31d2f28f0373ad5d90&#010;Parents: d590e92&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:46:37 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-metrics/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/73b61ef3/examples/camel-example-cdi-metrics/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-metrics/pom.xml b/examples/camel-example-cdi-metrics/pom.xml&#010;index 08401f7..5f09f7c 100755&#010;--- a/examples/camel-example-cdi-metrics/pom.xml&#010;+++ b/examples/camel-example-cdi-metrics/pom.xml&#010;@@ -127,4 +127,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C17d5bb4af9784983a8ac362b3e589ea3%40git.apache.org%3E,2017-04-14 10:57,commits,14.0,335.0,  [07/20] camel git commit: CAMEL-10141: make camel-example-cdi-metrics tests pass on Java 9
94,336.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-properties tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/061eb241&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/061eb241&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/061eb241&#010;&#010;Branch: refs/heads/master&#010;Commit: 061eb2416cd5863cf845b330740cacaed83321cd&#010;Parents: 73b61ef&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:46:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-properties/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/061eb241/examples/camel-example-cdi-properties/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-properties/pom.xml b/examples/camel-example-cdi-properties/pom.xml&#010;index 24adc77..ae2ae06 100755&#010;--- a/examples/camel-example-cdi-properties/pom.xml&#010;+++ b/examples/camel-example-cdi-properties/pom.xml&#010;@@ -124,4 +124,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C4901736312b14536a40a9ab29e998af5%40git.apache.org%3E,2017-04-14 10:57,commits,14.0,336.0,  [08/20] camel git commit: CAMEL-10141: make camel-example-cdi-properties tests pass on Java 9
95,337.0,davscl...@apache.org,"CAMEL-10141: make camel-example-reportincident tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/1b8949f5&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/1b8949f5&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/1b8949f5&#010;&#010;Branch: refs/heads/master&#010;Commit: 1b8949f593eed1fb0b97bcf0d138f2be113d0d2e&#010;Parents: e6964f1&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:59:57 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-reportincident/pom.xml | 2 +-&#010; 1 file changed, 1 insertion(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/1b8949f5/examples/camel-example-reportincident/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-reportincident/pom.xml b/examples/camel-example-reportincident/pom.xml&#010;index 92091d7..b820ac1 100755&#010;--- a/examples/camel-example-reportincident/pom.xml&#010;+++ b/examples/camel-example-reportincident/pom.xml&#010;@@ -208,7 +208,7 @@&#010;           &lt;plugin&gt;&#010;             &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;             &lt;configuration&gt;&#010;-              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.base/java.lang.invoke=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED&lt;/argLine&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.base/java.lang.invoke=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED&#010;--add-opens java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;             &lt;/configuration&gt;&#010;           &lt;/plugin&gt;&#010;         &lt;/plugins&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C4b84d50cca2f408189db81727d97a39f%40git.apache.org%3E,2017-04-14 10:57,commits,14.0,337.0,  [09/20] camel git commit: CAMEL-10141: make camel-example-reportincident tests pass on Java 9
96,338.0,davscl...@apache.org,"CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3f9ebd5a&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3f9ebd5a&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3f9ebd5a&#010;&#010;Branch: refs/heads/master&#010;Commit: 3f9ebd5a0a9e23e5b8c2f10abdf0c1c6ca4eda90&#010;Parents: 061eb24&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:47:16 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-rest-servlet/pom.xml | 43 +++++++++++++++++++-&#010; 1 file changed, 42 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3f9ebd5a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-rest-servlet/pom.xml b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;index 260d778..aac0973 100755&#010;--- a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;+++ b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;@@ -163,6 +163,48 @@&#010;         &lt;/dependency&gt;&#010;       &lt;/dependencies&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build-jetty&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;dependencies&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;arquillian-jetty-embedded-9&lt;/artifactId&gt;&#010;+          &lt;version&gt;1.0.0.CR2&lt;/version&gt;&#010;+          &lt;scope&gt;test&lt;/scope&gt;&#010;+          &lt;exclusions&gt;&#010;+            &lt;exclusion&gt;&#010;+              &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+              &lt;artifactId&gt;arquillian-container-spi&lt;/artifactId&gt;&#010;+            &lt;/exclusion&gt;&#010;+          &lt;/exclusions&gt;&#010;+        &lt;/dependency&gt;&#010;+      &lt;/dependencies&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;@@ -175,5 +217,4 @@&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cd0654af72ef94f628420b970c145ccf5%40git.apache.org%3E,2017-04-14 10:57,commits,14.0,338.0,  [10/20] camel git commit: CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9
97,339.0,davscl...@apache.org,"CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/fdeb3475&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/fdeb3475&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/fdeb3475&#010;&#010;Branch: refs/heads/master&#010;Commit: fdeb34752943b2bf4723407b99da875708fae852&#010;Parents: 1b8949f&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-pojo-messaging/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/fdeb3475/examples/camel-example-pojo-messaging/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-pojo-messaging/pom.xml b/examples/camel-example-pojo-messaging/pom.xml&#010;index f71b3b7..34b1bd6 100644&#010;--- a/examples/camel-example-pojo-messaging/pom.xml&#010;+++ b/examples/camel-example-pojo-messaging/pom.xml&#010;@@ -140,4 +140,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C7bc5feb92c534ce9a2bf51de8ce26017%40git.apache.org%3E,2017-04-14 10:57,commits,14.0,339.0,  [11/20] camel git commit: CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9
98,340.0,davscl...@apache.org,"CAMEL-10141: make camel-example-management tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/9e7b6c6c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/9e7b6c6c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/9e7b6c6c&#010;&#010;Branch: refs/heads/master&#010;Commit: 9e7b6c6c7bb423f36dd3a6db98635e2a95a98acc&#010;Parents: fdeb347&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-management/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/9e7b6c6c/examples/camel-example-management/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-management/pom.xml b/examples/camel-example-management/pom.xml&#010;index 66f0b1f..d8db087 100644&#010;--- a/examples/camel-example-management/pom.xml&#010;+++ b/examples/camel-example-management/pom.xml&#010;@@ -129,4 +129,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C30204927025749bbbc58720eb5a3f27c%40git.apache.org%3E,2017-04-14 10:57,commits,14.0,340.0,  [12/20] camel git commit: CAMEL-10141: make camel-example-management tests pass on Java 9
99,341.0,davscl...@apache.org,"CAMEL-10141: make camel-example-spring-jms tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3d9a999c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3d9a999c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3d9a999c&#010;&#010;Branch: refs/heads/master&#010;Commit: 3d9a999c035aa10bff547d0d3ee053528b615919&#010;Parents: 9e7b6c6&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-spring-jms/pom.xml | 17 ++++++++++++++++-&#010; 1 file changed, 16 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3d9a999c/examples/camel-example-spring-jms/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-spring-jms/pom.xml b/examples/camel-example-spring-jms/pom.xml&#010;index da360e0..af430aa 100644&#010;--- a/examples/camel-example-spring-jms/pom.xml&#010;+++ b/examples/camel-example-spring-jms/pom.xml&#010;@@ -128,6 +128,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.client.CamelClientEndpoint&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010;   &lt;build&gt;&#010; &#010;@@ -168,5 +184,4 @@&#010;     &lt;/plugins&gt;&#010; &#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cdf7aef9137e64879b2a51fa8161c519e%40git.apache.org%3E,2017-04-14 10:57,commits,14.0,341.0,  [13/20] camel git commit: CAMEL-10141: make camel-example-spring-jms tests pass on Java 9
100,342.0,davscl...@apache.org,"CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/047761a7&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/047761a7&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/047761a7&#010;&#010;Branch: refs/heads/master&#010;Commit: 047761a787d646759069e1ac318ba3523816ec08&#010;Parents: 3d9a999&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:50 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-osgi-rmi/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/047761a7/examples/camel-example-osgi-rmi/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-osgi-rmi/pom.xml b/examples/camel-example-osgi-rmi/pom.xml&#010;index dce39d2..82c588d 100644&#010;--- a/examples/camel-example-osgi-rmi/pom.xml&#010;+++ b/examples/camel-example-osgi-rmi/pom.xml&#010;@@ -87,6 +87,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.osgi.HelloClient&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ca519cd2689fb4af09c8ded1b17b83f65%40git.apache.org%3E,2017-04-14 10:57,commits,14.0,342.0,  [14/20] camel git commit: CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9
101,335.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-metrics tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/73b61ef3&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/73b61ef3&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/73b61ef3&#010;&#010;Branch: refs/heads/master&#010;Commit: 73b61ef32533aac448fe5c31d2f28f0373ad5d90&#010;Parents: d590e92&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:46:37 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-metrics/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/73b61ef3/examples/camel-example-cdi-metrics/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-metrics/pom.xml b/examples/camel-example-cdi-metrics/pom.xml&#010;index 08401f7..5f09f7c 100755&#010;--- a/examples/camel-example-cdi-metrics/pom.xml&#010;+++ b/examples/camel-example-cdi-metrics/pom.xml&#010;@@ -127,4 +127,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C17d5bb4af9784983a8ac362b3e589ea3%40git.apache.org%3E,2017-04-14 10:57,commits,15.0,335.0,  [07/20] camel git commit: CAMEL-10141: make camel-example-cdi-metrics tests pass on Java 9
102,336.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-properties tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/061eb241&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/061eb241&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/061eb241&#010;&#010;Branch: refs/heads/master&#010;Commit: 061eb2416cd5863cf845b330740cacaed83321cd&#010;Parents: 73b61ef&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:46:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-properties/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/061eb241/examples/camel-example-cdi-properties/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-properties/pom.xml b/examples/camel-example-cdi-properties/pom.xml&#010;index 24adc77..ae2ae06 100755&#010;--- a/examples/camel-example-cdi-properties/pom.xml&#010;+++ b/examples/camel-example-cdi-properties/pom.xml&#010;@@ -124,4 +124,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C4901736312b14536a40a9ab29e998af5%40git.apache.org%3E,2017-04-14 10:57,commits,15.0,336.0,  [08/20] camel git commit: CAMEL-10141: make camel-example-cdi-properties tests pass on Java 9
103,337.0,davscl...@apache.org,"CAMEL-10141: make camel-example-reportincident tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/1b8949f5&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/1b8949f5&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/1b8949f5&#010;&#010;Branch: refs/heads/master&#010;Commit: 1b8949f593eed1fb0b97bcf0d138f2be113d0d2e&#010;Parents: e6964f1&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:59:57 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-reportincident/pom.xml | 2 +-&#010; 1 file changed, 1 insertion(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/1b8949f5/examples/camel-example-reportincident/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-reportincident/pom.xml b/examples/camel-example-reportincident/pom.xml&#010;index 92091d7..b820ac1 100755&#010;--- a/examples/camel-example-reportincident/pom.xml&#010;+++ b/examples/camel-example-reportincident/pom.xml&#010;@@ -208,7 +208,7 @@&#010;           &lt;plugin&gt;&#010;             &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;             &lt;configuration&gt;&#010;-              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.base/java.lang.invoke=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED&lt;/argLine&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.base/java.lang.invoke=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED&#010;--add-opens java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;             &lt;/configuration&gt;&#010;           &lt;/plugin&gt;&#010;         &lt;/plugins&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C4b84d50cca2f408189db81727d97a39f%40git.apache.org%3E,2017-04-14 10:57,commits,15.0,337.0,  [09/20] camel git commit: CAMEL-10141: make camel-example-reportincident tests pass on Java 9
104,338.0,davscl...@apache.org,"CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3f9ebd5a&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3f9ebd5a&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3f9ebd5a&#010;&#010;Branch: refs/heads/master&#010;Commit: 3f9ebd5a0a9e23e5b8c2f10abdf0c1c6ca4eda90&#010;Parents: 061eb24&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:47:16 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-rest-servlet/pom.xml | 43 +++++++++++++++++++-&#010; 1 file changed, 42 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3f9ebd5a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-rest-servlet/pom.xml b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;index 260d778..aac0973 100755&#010;--- a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;+++ b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;@@ -163,6 +163,48 @@&#010;         &lt;/dependency&gt;&#010;       &lt;/dependencies&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build-jetty&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;dependencies&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;arquillian-jetty-embedded-9&lt;/artifactId&gt;&#010;+          &lt;version&gt;1.0.0.CR2&lt;/version&gt;&#010;+          &lt;scope&gt;test&lt;/scope&gt;&#010;+          &lt;exclusions&gt;&#010;+            &lt;exclusion&gt;&#010;+              &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+              &lt;artifactId&gt;arquillian-container-spi&lt;/artifactId&gt;&#010;+            &lt;/exclusion&gt;&#010;+          &lt;/exclusions&gt;&#010;+        &lt;/dependency&gt;&#010;+      &lt;/dependencies&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;@@ -175,5 +217,4 @@&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cd0654af72ef94f628420b970c145ccf5%40git.apache.org%3E,2017-04-14 10:57,commits,15.0,338.0,  [10/20] camel git commit: CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9
105,339.0,davscl...@apache.org,"CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/fdeb3475&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/fdeb3475&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/fdeb3475&#010;&#010;Branch: refs/heads/master&#010;Commit: fdeb34752943b2bf4723407b99da875708fae852&#010;Parents: 1b8949f&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-pojo-messaging/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/fdeb3475/examples/camel-example-pojo-messaging/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-pojo-messaging/pom.xml b/examples/camel-example-pojo-messaging/pom.xml&#010;index f71b3b7..34b1bd6 100644&#010;--- a/examples/camel-example-pojo-messaging/pom.xml&#010;+++ b/examples/camel-example-pojo-messaging/pom.xml&#010;@@ -140,4 +140,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C7bc5feb92c534ce9a2bf51de8ce26017%40git.apache.org%3E,2017-04-14 10:57,commits,15.0,339.0,  [11/20] camel git commit: CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9
106,340.0,davscl...@apache.org,"CAMEL-10141: make camel-example-management tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/9e7b6c6c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/9e7b6c6c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/9e7b6c6c&#010;&#010;Branch: refs/heads/master&#010;Commit: 9e7b6c6c7bb423f36dd3a6db98635e2a95a98acc&#010;Parents: fdeb347&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-management/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/9e7b6c6c/examples/camel-example-management/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-management/pom.xml b/examples/camel-example-management/pom.xml&#010;index 66f0b1f..d8db087 100644&#010;--- a/examples/camel-example-management/pom.xml&#010;+++ b/examples/camel-example-management/pom.xml&#010;@@ -129,4 +129,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C30204927025749bbbc58720eb5a3f27c%40git.apache.org%3E,2017-04-14 10:57,commits,15.0,340.0,  [12/20] camel git commit: CAMEL-10141: make camel-example-management tests pass on Java 9
107,341.0,davscl...@apache.org,"CAMEL-10141: make camel-example-spring-jms tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3d9a999c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3d9a999c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3d9a999c&#010;&#010;Branch: refs/heads/master&#010;Commit: 3d9a999c035aa10bff547d0d3ee053528b615919&#010;Parents: 9e7b6c6&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-spring-jms/pom.xml | 17 ++++++++++++++++-&#010; 1 file changed, 16 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3d9a999c/examples/camel-example-spring-jms/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-spring-jms/pom.xml b/examples/camel-example-spring-jms/pom.xml&#010;index da360e0..af430aa 100644&#010;--- a/examples/camel-example-spring-jms/pom.xml&#010;+++ b/examples/camel-example-spring-jms/pom.xml&#010;@@ -128,6 +128,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.client.CamelClientEndpoint&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010;   &lt;build&gt;&#010; &#010;@@ -168,5 +184,4 @@&#010;     &lt;/plugins&gt;&#010; &#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cdf7aef9137e64879b2a51fa8161c519e%40git.apache.org%3E,2017-04-14 10:57,commits,15.0,341.0,  [13/20] camel git commit: CAMEL-10141: make camel-example-spring-jms tests pass on Java 9
108,342.0,davscl...@apache.org,"CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/047761a7&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/047761a7&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/047761a7&#010;&#010;Branch: refs/heads/master&#010;Commit: 047761a787d646759069e1ac318ba3523816ec08&#010;Parents: 3d9a999&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:50 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-osgi-rmi/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/047761a7/examples/camel-example-osgi-rmi/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-osgi-rmi/pom.xml b/examples/camel-example-osgi-rmi/pom.xml&#010;index dce39d2..82c588d 100644&#010;--- a/examples/camel-example-osgi-rmi/pom.xml&#010;+++ b/examples/camel-example-osgi-rmi/pom.xml&#010;@@ -87,6 +87,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.osgi.HelloClient&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ca519cd2689fb4af09c8ded1b17b83f65%40git.apache.org%3E,2017-04-14 10:57,commits,15.0,342.0,  [14/20] camel git commit: CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9
109,336.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cdi-properties tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/061eb241&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/061eb241&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/061eb241&#010;&#010;Branch: refs/heads/master&#010;Commit: 061eb2416cd5863cf845b330740cacaed83321cd&#010;Parents: 73b61ef&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:46:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-properties/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/061eb241/examples/camel-example-cdi-properties/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-properties/pom.xml b/examples/camel-example-cdi-properties/pom.xml&#010;index 24adc77..ae2ae06 100755&#010;--- a/examples/camel-example-cdi-properties/pom.xml&#010;+++ b/examples/camel-example-cdi-properties/pom.xml&#010;@@ -124,4 +124,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C4901736312b14536a40a9ab29e998af5%40git.apache.org%3E,2017-04-14 10:57,commits,16.0,336.0,  [08/20] camel git commit: CAMEL-10141: make camel-example-cdi-properties tests pass on Java 9
110,337.0,davscl...@apache.org,"CAMEL-10141: make camel-example-reportincident tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/1b8949f5&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/1b8949f5&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/1b8949f5&#010;&#010;Branch: refs/heads/master&#010;Commit: 1b8949f593eed1fb0b97bcf0d138f2be113d0d2e&#010;Parents: e6964f1&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:59:57 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-reportincident/pom.xml | 2 +-&#010; 1 file changed, 1 insertion(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/1b8949f5/examples/camel-example-reportincident/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-reportincident/pom.xml b/examples/camel-example-reportincident/pom.xml&#010;index 92091d7..b820ac1 100755&#010;--- a/examples/camel-example-reportincident/pom.xml&#010;+++ b/examples/camel-example-reportincident/pom.xml&#010;@@ -208,7 +208,7 @@&#010;           &lt;plugin&gt;&#010;             &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;             &lt;configuration&gt;&#010;-              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.base/java.lang.invoke=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED&lt;/argLine&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.base/java.lang.invoke=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED&#010;--add-opens java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;             &lt;/configuration&gt;&#010;           &lt;/plugin&gt;&#010;         &lt;/plugins&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C4b84d50cca2f408189db81727d97a39f%40git.apache.org%3E,2017-04-14 10:57,commits,16.0,337.0,  [09/20] camel git commit: CAMEL-10141: make camel-example-reportincident tests pass on Java 9
111,338.0,davscl...@apache.org,"CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3f9ebd5a&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3f9ebd5a&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3f9ebd5a&#010;&#010;Branch: refs/heads/master&#010;Commit: 3f9ebd5a0a9e23e5b8c2f10abdf0c1c6ca4eda90&#010;Parents: 061eb24&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:47:16 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-rest-servlet/pom.xml | 43 +++++++++++++++++++-&#010; 1 file changed, 42 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3f9ebd5a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-rest-servlet/pom.xml b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;index 260d778..aac0973 100755&#010;--- a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;+++ b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;@@ -163,6 +163,48 @@&#010;         &lt;/dependency&gt;&#010;       &lt;/dependencies&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build-jetty&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;dependencies&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;arquillian-jetty-embedded-9&lt;/artifactId&gt;&#010;+          &lt;version&gt;1.0.0.CR2&lt;/version&gt;&#010;+          &lt;scope&gt;test&lt;/scope&gt;&#010;+          &lt;exclusions&gt;&#010;+            &lt;exclusion&gt;&#010;+              &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+              &lt;artifactId&gt;arquillian-container-spi&lt;/artifactId&gt;&#010;+            &lt;/exclusion&gt;&#010;+          &lt;/exclusions&gt;&#010;+        &lt;/dependency&gt;&#010;+      &lt;/dependencies&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;@@ -175,5 +217,4 @@&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cd0654af72ef94f628420b970c145ccf5%40git.apache.org%3E,2017-04-14 10:57,commits,16.0,338.0,  [10/20] camel git commit: CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9
112,339.0,davscl...@apache.org,"CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/fdeb3475&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/fdeb3475&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/fdeb3475&#010;&#010;Branch: refs/heads/master&#010;Commit: fdeb34752943b2bf4723407b99da875708fae852&#010;Parents: 1b8949f&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-pojo-messaging/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/fdeb3475/examples/camel-example-pojo-messaging/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-pojo-messaging/pom.xml b/examples/camel-example-pojo-messaging/pom.xml&#010;index f71b3b7..34b1bd6 100644&#010;--- a/examples/camel-example-pojo-messaging/pom.xml&#010;+++ b/examples/camel-example-pojo-messaging/pom.xml&#010;@@ -140,4 +140,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C7bc5feb92c534ce9a2bf51de8ce26017%40git.apache.org%3E,2017-04-14 10:57,commits,16.0,339.0,  [11/20] camel git commit: CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9
113,340.0,davscl...@apache.org,"CAMEL-10141: make camel-example-management tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/9e7b6c6c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/9e7b6c6c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/9e7b6c6c&#010;&#010;Branch: refs/heads/master&#010;Commit: 9e7b6c6c7bb423f36dd3a6db98635e2a95a98acc&#010;Parents: fdeb347&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-management/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/9e7b6c6c/examples/camel-example-management/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-management/pom.xml b/examples/camel-example-management/pom.xml&#010;index 66f0b1f..d8db087 100644&#010;--- a/examples/camel-example-management/pom.xml&#010;+++ b/examples/camel-example-management/pom.xml&#010;@@ -129,4 +129,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C30204927025749bbbc58720eb5a3f27c%40git.apache.org%3E,2017-04-14 10:57,commits,16.0,340.0,  [12/20] camel git commit: CAMEL-10141: make camel-example-management tests pass on Java 9
114,341.0,davscl...@apache.org,"CAMEL-10141: make camel-example-spring-jms tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3d9a999c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3d9a999c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3d9a999c&#010;&#010;Branch: refs/heads/master&#010;Commit: 3d9a999c035aa10bff547d0d3ee053528b615919&#010;Parents: 9e7b6c6&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-spring-jms/pom.xml | 17 ++++++++++++++++-&#010; 1 file changed, 16 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3d9a999c/examples/camel-example-spring-jms/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-spring-jms/pom.xml b/examples/camel-example-spring-jms/pom.xml&#010;index da360e0..af430aa 100644&#010;--- a/examples/camel-example-spring-jms/pom.xml&#010;+++ b/examples/camel-example-spring-jms/pom.xml&#010;@@ -128,6 +128,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.client.CamelClientEndpoint&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010;   &lt;build&gt;&#010; &#010;@@ -168,5 +184,4 @@&#010;     &lt;/plugins&gt;&#010; &#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cdf7aef9137e64879b2a51fa8161c519e%40git.apache.org%3E,2017-04-14 10:57,commits,16.0,341.0,  [13/20] camel git commit: CAMEL-10141: make camel-example-spring-jms tests pass on Java 9
115,342.0,davscl...@apache.org,"CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/047761a7&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/047761a7&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/047761a7&#010;&#010;Branch: refs/heads/master&#010;Commit: 047761a787d646759069e1ac318ba3523816ec08&#010;Parents: 3d9a999&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:50 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-osgi-rmi/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/047761a7/examples/camel-example-osgi-rmi/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-osgi-rmi/pom.xml b/examples/camel-example-osgi-rmi/pom.xml&#010;index dce39d2..82c588d 100644&#010;--- a/examples/camel-example-osgi-rmi/pom.xml&#010;+++ b/examples/camel-example-osgi-rmi/pom.xml&#010;@@ -87,6 +87,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.osgi.HelloClient&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ca519cd2689fb4af09c8ded1b17b83f65%40git.apache.org%3E,2017-04-14 10:57,commits,16.0,342.0,  [14/20] camel git commit: CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9
116,337.0,davscl...@apache.org,"CAMEL-10141: make camel-example-reportincident tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/1b8949f5&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/1b8949f5&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/1b8949f5&#010;&#010;Branch: refs/heads/master&#010;Commit: 1b8949f593eed1fb0b97bcf0d138f2be113d0d2e&#010;Parents: e6964f1&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:59:57 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-reportincident/pom.xml | 2 +-&#010; 1 file changed, 1 insertion(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/1b8949f5/examples/camel-example-reportincident/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-reportincident/pom.xml b/examples/camel-example-reportincident/pom.xml&#010;index 92091d7..b820ac1 100755&#010;--- a/examples/camel-example-reportincident/pom.xml&#010;+++ b/examples/camel-example-reportincident/pom.xml&#010;@@ -208,7 +208,7 @@&#010;           &lt;plugin&gt;&#010;             &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;             &lt;configuration&gt;&#010;-              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.base/java.lang.invoke=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED&lt;/argLine&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.base/java.lang.invoke=ALL-UNNAMED --add-opens java.base/java.util=ALL-UNNAMED&#010;--add-opens java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;             &lt;/configuration&gt;&#010;           &lt;/plugin&gt;&#010;         &lt;/plugins&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C4b84d50cca2f408189db81727d97a39f%40git.apache.org%3E,2017-04-14 10:57,commits,17.0,337.0,  [09/20] camel git commit: CAMEL-10141: make camel-example-reportincident tests pass on Java 9
117,338.0,davscl...@apache.org,"CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3f9ebd5a&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3f9ebd5a&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3f9ebd5a&#010;&#010;Branch: refs/heads/master&#010;Commit: 3f9ebd5a0a9e23e5b8c2f10abdf0c1c6ca4eda90&#010;Parents: 061eb24&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:47:16 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-rest-servlet/pom.xml | 43 +++++++++++++++++++-&#010; 1 file changed, 42 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3f9ebd5a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-rest-servlet/pom.xml b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;index 260d778..aac0973 100755&#010;--- a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;+++ b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;@@ -163,6 +163,48 @@&#010;         &lt;/dependency&gt;&#010;       &lt;/dependencies&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build-jetty&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;dependencies&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;arquillian-jetty-embedded-9&lt;/artifactId&gt;&#010;+          &lt;version&gt;1.0.0.CR2&lt;/version&gt;&#010;+          &lt;scope&gt;test&lt;/scope&gt;&#010;+          &lt;exclusions&gt;&#010;+            &lt;exclusion&gt;&#010;+              &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+              &lt;artifactId&gt;arquillian-container-spi&lt;/artifactId&gt;&#010;+            &lt;/exclusion&gt;&#010;+          &lt;/exclusions&gt;&#010;+        &lt;/dependency&gt;&#010;+      &lt;/dependencies&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;@@ -175,5 +217,4 @@&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cd0654af72ef94f628420b970c145ccf5%40git.apache.org%3E,2017-04-14 10:57,commits,17.0,338.0,  [10/20] camel git commit: CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9
118,339.0,davscl...@apache.org,"CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/fdeb3475&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/fdeb3475&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/fdeb3475&#010;&#010;Branch: refs/heads/master&#010;Commit: fdeb34752943b2bf4723407b99da875708fae852&#010;Parents: 1b8949f&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-pojo-messaging/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/fdeb3475/examples/camel-example-pojo-messaging/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-pojo-messaging/pom.xml b/examples/camel-example-pojo-messaging/pom.xml&#010;index f71b3b7..34b1bd6 100644&#010;--- a/examples/camel-example-pojo-messaging/pom.xml&#010;+++ b/examples/camel-example-pojo-messaging/pom.xml&#010;@@ -140,4 +140,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C7bc5feb92c534ce9a2bf51de8ce26017%40git.apache.org%3E,2017-04-14 10:57,commits,17.0,339.0,  [11/20] camel git commit: CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9
119,340.0,davscl...@apache.org,"CAMEL-10141: make camel-example-management tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/9e7b6c6c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/9e7b6c6c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/9e7b6c6c&#010;&#010;Branch: refs/heads/master&#010;Commit: 9e7b6c6c7bb423f36dd3a6db98635e2a95a98acc&#010;Parents: fdeb347&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-management/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/9e7b6c6c/examples/camel-example-management/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-management/pom.xml b/examples/camel-example-management/pom.xml&#010;index 66f0b1f..d8db087 100644&#010;--- a/examples/camel-example-management/pom.xml&#010;+++ b/examples/camel-example-management/pom.xml&#010;@@ -129,4 +129,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C30204927025749bbbc58720eb5a3f27c%40git.apache.org%3E,2017-04-14 10:57,commits,17.0,340.0,  [12/20] camel git commit: CAMEL-10141: make camel-example-management tests pass on Java 9
120,341.0,davscl...@apache.org,"CAMEL-10141: make camel-example-spring-jms tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3d9a999c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3d9a999c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3d9a999c&#010;&#010;Branch: refs/heads/master&#010;Commit: 3d9a999c035aa10bff547d0d3ee053528b615919&#010;Parents: 9e7b6c6&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-spring-jms/pom.xml | 17 ++++++++++++++++-&#010; 1 file changed, 16 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3d9a999c/examples/camel-example-spring-jms/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-spring-jms/pom.xml b/examples/camel-example-spring-jms/pom.xml&#010;index da360e0..af430aa 100644&#010;--- a/examples/camel-example-spring-jms/pom.xml&#010;+++ b/examples/camel-example-spring-jms/pom.xml&#010;@@ -128,6 +128,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.client.CamelClientEndpoint&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010;   &lt;build&gt;&#010; &#010;@@ -168,5 +184,4 @@&#010;     &lt;/plugins&gt;&#010; &#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cdf7aef9137e64879b2a51fa8161c519e%40git.apache.org%3E,2017-04-14 10:57,commits,17.0,341.0,  [13/20] camel git commit: CAMEL-10141: make camel-example-spring-jms tests pass on Java 9
121,342.0,davscl...@apache.org,"CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/047761a7&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/047761a7&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/047761a7&#010;&#010;Branch: refs/heads/master&#010;Commit: 047761a787d646759069e1ac318ba3523816ec08&#010;Parents: 3d9a999&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:50 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-osgi-rmi/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/047761a7/examples/camel-example-osgi-rmi/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-osgi-rmi/pom.xml b/examples/camel-example-osgi-rmi/pom.xml&#010;index dce39d2..82c588d 100644&#010;--- a/examples/camel-example-osgi-rmi/pom.xml&#010;+++ b/examples/camel-example-osgi-rmi/pom.xml&#010;@@ -87,6 +87,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.osgi.HelloClient&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ca519cd2689fb4af09c8ded1b17b83f65%40git.apache.org%3E,2017-04-14 10:57,commits,17.0,342.0,  [14/20] camel git commit: CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9
122,338.0,davscl...@apache.org,"CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3f9ebd5a&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3f9ebd5a&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3f9ebd5a&#010;&#010;Branch: refs/heads/master&#010;Commit: 3f9ebd5a0a9e23e5b8c2f10abdf0c1c6ca4eda90&#010;Parents: 061eb24&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 10:47:16 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cdi-rest-servlet/pom.xml | 43 +++++++++++++++++++-&#010; 1 file changed, 42 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3f9ebd5a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cdi-rest-servlet/pom.xml b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;index 260d778..aac0973 100755&#010;--- a/examples/camel-example-cdi-rest-servlet/pom.xml&#010;+++ b/examples/camel-example-cdi-rest-servlet/pom.xml&#010;@@ -163,6 +163,48 @@&#010;         &lt;/dependency&gt;&#010;       &lt;/dependencies&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build-jetty&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;dependencies&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt;&#010;+          &lt;version&gt;${jetty9-version}&lt;/version&gt;&#010;+          &lt;scope&gt;runtime&lt;/scope&gt;&#010;+        &lt;/dependency&gt;&#010;+        &lt;dependency&gt;&#010;+          &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+          &lt;artifactId&gt;arquillian-jetty-embedded-9&lt;/artifactId&gt;&#010;+          &lt;version&gt;1.0.0.CR2&lt;/version&gt;&#010;+          &lt;scope&gt;test&lt;/scope&gt;&#010;+          &lt;exclusions&gt;&#010;+            &lt;exclusion&gt;&#010;+              &lt;groupId&gt;org.jboss.arquillian.container&lt;/groupId&gt;&#010;+              &lt;artifactId&gt;arquillian-container-spi&lt;/artifactId&gt;&#010;+            &lt;/exclusion&gt;&#010;+          &lt;/exclusions&gt;&#010;+        &lt;/dependency&gt;&#010;+      &lt;/dependencies&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;@@ -175,5 +217,4 @@&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cd0654af72ef94f628420b970c145ccf5%40git.apache.org%3E,2017-04-14 10:57,commits,18.0,338.0,  [10/20] camel git commit: CAMEL-10141: make camel-example-rest-servlet tests pass on Java 9
123,339.0,davscl...@apache.org,"CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/fdeb3475&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/fdeb3475&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/fdeb3475&#010;&#010;Branch: refs/heads/master&#010;Commit: fdeb34752943b2bf4723407b99da875708fae852&#010;Parents: 1b8949f&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-pojo-messaging/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/fdeb3475/examples/camel-example-pojo-messaging/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-pojo-messaging/pom.xml b/examples/camel-example-pojo-messaging/pom.xml&#010;index f71b3b7..34b1bd6 100644&#010;--- a/examples/camel-example-pojo-messaging/pom.xml&#010;+++ b/examples/camel-example-pojo-messaging/pom.xml&#010;@@ -140,4 +140,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C7bc5feb92c534ce9a2bf51de8ce26017%40git.apache.org%3E,2017-04-14 10:57,commits,18.0,339.0,  [11/20] camel git commit: CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9
124,340.0,davscl...@apache.org,"CAMEL-10141: make camel-example-management tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/9e7b6c6c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/9e7b6c6c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/9e7b6c6c&#010;&#010;Branch: refs/heads/master&#010;Commit: 9e7b6c6c7bb423f36dd3a6db98635e2a95a98acc&#010;Parents: fdeb347&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-management/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/9e7b6c6c/examples/camel-example-management/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-management/pom.xml b/examples/camel-example-management/pom.xml&#010;index 66f0b1f..d8db087 100644&#010;--- a/examples/camel-example-management/pom.xml&#010;+++ b/examples/camel-example-management/pom.xml&#010;@@ -129,4 +129,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C30204927025749bbbc58720eb5a3f27c%40git.apache.org%3E,2017-04-14 10:57,commits,18.0,340.0,  [12/20] camel git commit: CAMEL-10141: make camel-example-management tests pass on Java 9
125,341.0,davscl...@apache.org,"CAMEL-10141: make camel-example-spring-jms tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3d9a999c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3d9a999c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3d9a999c&#010;&#010;Branch: refs/heads/master&#010;Commit: 3d9a999c035aa10bff547d0d3ee053528b615919&#010;Parents: 9e7b6c6&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-spring-jms/pom.xml | 17 ++++++++++++++++-&#010; 1 file changed, 16 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3d9a999c/examples/camel-example-spring-jms/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-spring-jms/pom.xml b/examples/camel-example-spring-jms/pom.xml&#010;index da360e0..af430aa 100644&#010;--- a/examples/camel-example-spring-jms/pom.xml&#010;+++ b/examples/camel-example-spring-jms/pom.xml&#010;@@ -128,6 +128,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.client.CamelClientEndpoint&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010;   &lt;build&gt;&#010; &#010;@@ -168,5 +184,4 @@&#010;     &lt;/plugins&gt;&#010; &#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cdf7aef9137e64879b2a51fa8161c519e%40git.apache.org%3E,2017-04-14 10:57,commits,18.0,341.0,  [13/20] camel git commit: CAMEL-10141: make camel-example-spring-jms tests pass on Java 9
126,342.0,davscl...@apache.org,"CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/047761a7&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/047761a7&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/047761a7&#010;&#010;Branch: refs/heads/master&#010;Commit: 047761a787d646759069e1ac318ba3523816ec08&#010;Parents: 3d9a999&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:50 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-osgi-rmi/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/047761a7/examples/camel-example-osgi-rmi/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-osgi-rmi/pom.xml b/examples/camel-example-osgi-rmi/pom.xml&#010;index dce39d2..82c588d 100644&#010;--- a/examples/camel-example-osgi-rmi/pom.xml&#010;+++ b/examples/camel-example-osgi-rmi/pom.xml&#010;@@ -87,6 +87,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.osgi.HelloClient&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ca519cd2689fb4af09c8ded1b17b83f65%40git.apache.org%3E,2017-04-14 10:57,commits,18.0,342.0,  [14/20] camel git commit: CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9
127,339.0,davscl...@apache.org,"CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/fdeb3475&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/fdeb3475&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/fdeb3475&#010;&#010;Branch: refs/heads/master&#010;Commit: fdeb34752943b2bf4723407b99da875708fae852&#010;Parents: 1b8949f&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-pojo-messaging/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/fdeb3475/examples/camel-example-pojo-messaging/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-pojo-messaging/pom.xml b/examples/camel-example-pojo-messaging/pom.xml&#010;index f71b3b7..34b1bd6 100644&#010;--- a/examples/camel-example-pojo-messaging/pom.xml&#010;+++ b/examples/camel-example-pojo-messaging/pom.xml&#010;@@ -140,4 +140,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C7bc5feb92c534ce9a2bf51de8ce26017%40git.apache.org%3E,2017-04-14 10:57,commits,19.0,339.0,  [11/20] camel git commit: CAMEL-10141: make camel-example-pojo-messaging tests pass on Java 9
128,340.0,davscl...@apache.org,"CAMEL-10141: make camel-example-management tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/9e7b6c6c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/9e7b6c6c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/9e7b6c6c&#010;&#010;Branch: refs/heads/master&#010;Commit: 9e7b6c6c7bb423f36dd3a6db98635e2a95a98acc&#010;Parents: fdeb347&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-management/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/9e7b6c6c/examples/camel-example-management/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-management/pom.xml b/examples/camel-example-management/pom.xml&#010;index 66f0b1f..d8db087 100644&#010;--- a/examples/camel-example-management/pom.xml&#010;+++ b/examples/camel-example-management/pom.xml&#010;@@ -129,4 +129,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C30204927025749bbbc58720eb5a3f27c%40git.apache.org%3E,2017-04-14 10:57,commits,19.0,340.0,  [12/20] camel git commit: CAMEL-10141: make camel-example-management tests pass on Java 9
129,341.0,davscl...@apache.org,"CAMEL-10141: make camel-example-spring-jms tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3d9a999c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3d9a999c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3d9a999c&#010;&#010;Branch: refs/heads/master&#010;Commit: 3d9a999c035aa10bff547d0d3ee053528b615919&#010;Parents: 9e7b6c6&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-spring-jms/pom.xml | 17 ++++++++++++++++-&#010; 1 file changed, 16 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3d9a999c/examples/camel-example-spring-jms/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-spring-jms/pom.xml b/examples/camel-example-spring-jms/pom.xml&#010;index da360e0..af430aa 100644&#010;--- a/examples/camel-example-spring-jms/pom.xml&#010;+++ b/examples/camel-example-spring-jms/pom.xml&#010;@@ -128,6 +128,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.client.CamelClientEndpoint&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010;   &lt;build&gt;&#010; &#010;@@ -168,5 +184,4 @@&#010;     &lt;/plugins&gt;&#010; &#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cdf7aef9137e64879b2a51fa8161c519e%40git.apache.org%3E,2017-04-14 10:57,commits,19.0,341.0,  [13/20] camel git commit: CAMEL-10141: make camel-example-spring-jms tests pass on Java 9
130,342.0,davscl...@apache.org,"CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/047761a7&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/047761a7&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/047761a7&#010;&#010;Branch: refs/heads/master&#010;Commit: 047761a787d646759069e1ac318ba3523816ec08&#010;Parents: 3d9a999&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:50 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-osgi-rmi/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/047761a7/examples/camel-example-osgi-rmi/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-osgi-rmi/pom.xml b/examples/camel-example-osgi-rmi/pom.xml&#010;index dce39d2..82c588d 100644&#010;--- a/examples/camel-example-osgi-rmi/pom.xml&#010;+++ b/examples/camel-example-osgi-rmi/pom.xml&#010;@@ -87,6 +87,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.osgi.HelloClient&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ca519cd2689fb4af09c8ded1b17b83f65%40git.apache.org%3E,2017-04-14 10:57,commits,19.0,342.0,  [14/20] camel git commit: CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9
131,340.0,davscl...@apache.org,"CAMEL-10141: make camel-example-management tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/9e7b6c6c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/9e7b6c6c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/9e7b6c6c&#010;&#010;Branch: refs/heads/master&#010;Commit: 9e7b6c6c7bb423f36dd3a6db98635e2a95a98acc&#010;Parents: fdeb347&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:00:56 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-management/pom.xml | 18 ++++++++++++++++++&#010; 1 file changed, 18 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/9e7b6c6c/examples/camel-example-management/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-management/pom.xml b/examples/camel-example-management/pom.xml&#010;index 66f0b1f..d8db087 100644&#010;--- a/examples/camel-example-management/pom.xml&#010;+++ b/examples/camel-example-management/pom.xml&#010;@@ -129,4 +129,22 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C30204927025749bbbc58720eb5a3f27c%40git.apache.org%3E,2017-04-14 10:57,commits,20.0,340.0,  [12/20] camel git commit: CAMEL-10141: make camel-example-management tests pass on Java 9
132,341.0,davscl...@apache.org,"CAMEL-10141: make camel-example-spring-jms tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3d9a999c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3d9a999c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3d9a999c&#010;&#010;Branch: refs/heads/master&#010;Commit: 3d9a999c035aa10bff547d0d3ee053528b615919&#010;Parents: 9e7b6c6&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-spring-jms/pom.xml | 17 ++++++++++++++++-&#010; 1 file changed, 16 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3d9a999c/examples/camel-example-spring-jms/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-spring-jms/pom.xml b/examples/camel-example-spring-jms/pom.xml&#010;index da360e0..af430aa 100644&#010;--- a/examples/camel-example-spring-jms/pom.xml&#010;+++ b/examples/camel-example-spring-jms/pom.xml&#010;@@ -128,6 +128,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.client.CamelClientEndpoint&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010;   &lt;build&gt;&#010; &#010;@@ -168,5 +184,4 @@&#010;     &lt;/plugins&gt;&#010; &#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cdf7aef9137e64879b2a51fa8161c519e%40git.apache.org%3E,2017-04-14 10:57,commits,20.0,341.0,  [13/20] camel git commit: CAMEL-10141: make camel-example-spring-jms tests pass on Java 9
133,342.0,davscl...@apache.org,"CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/047761a7&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/047761a7&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/047761a7&#010;&#010;Branch: refs/heads/master&#010;Commit: 047761a787d646759069e1ac318ba3523816ec08&#010;Parents: 3d9a999&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:50 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-osgi-rmi/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/047761a7/examples/camel-example-osgi-rmi/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-osgi-rmi/pom.xml b/examples/camel-example-osgi-rmi/pom.xml&#010;index dce39d2..82c588d 100644&#010;--- a/examples/camel-example-osgi-rmi/pom.xml&#010;+++ b/examples/camel-example-osgi-rmi/pom.xml&#010;@@ -87,6 +87,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.osgi.HelloClient&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ca519cd2689fb4af09c8ded1b17b83f65%40git.apache.org%3E,2017-04-14 10:57,commits,20.0,342.0,  [14/20] camel git commit: CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9
134,341.0,davscl...@apache.org,"CAMEL-10141: make camel-example-spring-jms tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/3d9a999c&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/3d9a999c&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/3d9a999c&#010;&#010;Branch: refs/heads/master&#010;Commit: 3d9a999c035aa10bff547d0d3ee053528b615919&#010;Parents: 9e7b6c6&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-spring-jms/pom.xml | 17 ++++++++++++++++-&#010; 1 file changed, 16 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/3d9a999c/examples/camel-example-spring-jms/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-spring-jms/pom.xml b/examples/camel-example-spring-jms/pom.xml&#010;index da360e0..af430aa 100644&#010;--- a/examples/camel-example-spring-jms/pom.xml&#010;+++ b/examples/camel-example-spring-jms/pom.xml&#010;@@ -128,6 +128,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.client.CamelClientEndpoint&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010;   &lt;build&gt;&#010; &#010;@@ -168,5 +184,4 @@&#010;     &lt;/plugins&gt;&#010; &#010;   &lt;/build&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cdf7aef9137e64879b2a51fa8161c519e%40git.apache.org%3E,2017-04-14 10:57,commits,21.0,341.0,  [13/20] camel git commit: CAMEL-10141: make camel-example-spring-jms tests pass on Java 9
135,342.0,davscl...@apache.org,"CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/047761a7&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/047761a7&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/047761a7&#010;&#010;Branch: refs/heads/master&#010;Commit: 047761a787d646759069e1ac318ba3523816ec08&#010;Parents: 3d9a999&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:50 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-osgi-rmi/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/047761a7/examples/camel-example-osgi-rmi/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-osgi-rmi/pom.xml b/examples/camel-example-osgi-rmi/pom.xml&#010;index dce39d2..82c588d 100644&#010;--- a/examples/camel-example-osgi-rmi/pom.xml&#010;+++ b/examples/camel-example-osgi-rmi/pom.xml&#010;@@ -87,6 +87,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.osgi.HelloClient&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ca519cd2689fb4af09c8ded1b17b83f65%40git.apache.org%3E,2017-04-14 10:57,commits,21.0,342.0,  [14/20] camel git commit: CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9
136,342.0,davscl...@apache.org,"CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/047761a7&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/047761a7&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/047761a7&#010;&#010;Branch: refs/heads/master&#010;Commit: 047761a787d646759069e1ac318ba3523816ec08&#010;Parents: 3d9a999&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:01:50 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-osgi-rmi/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/047761a7/examples/camel-example-osgi-rmi/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-osgi-rmi/pom.xml b/examples/camel-example-osgi-rmi/pom.xml&#010;index dce39d2..82c588d 100644&#010;--- a/examples/camel-example-osgi-rmi/pom.xml&#010;+++ b/examples/camel-example-osgi-rmi/pom.xml&#010;@@ -87,6 +87,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.osgi.HelloClient&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind --add-opens java.base/java.lang=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Ca519cd2689fb4af09c8ded1b17b83f65%40git.apache.org%3E,2017-04-14 10:57,commits,22.0,342.0,  [14/20] camel git commit: CAMEL-10141: make camel-example-osgi-rmi tests pass on Java 9
137,343.0,davscl...@apache.org,"CAMEL-10141: make camel-example-cafe tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/f0cc62ec&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/f0cc62ec&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/f0cc62ec&#010;&#010;Branch: refs/heads/master&#010;Commit: f0cc62ec403817c3f0050c870a5ad06732fb4bba&#010;Parents: 047761a&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:02:13 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cafe/pom.xml | 20 +++++++++++++++++++-&#010; 1 file changed, 19 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/f0cc62ec/examples/camel-example-cafe/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cafe/pom.xml b/examples/camel-example-cafe/pom.xml&#010;index 3255469..5e88b79 100755&#010;--- a/examples/camel-example-cafe/pom.xml&#010;+++ b/examples/camel-example-cafe/pom.xml&#010;@@ -118,5 +118,23 @@&#010; &#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;-&#010;+  &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cad79d72ff20f4e9e9063531f4c8a0503%40git.apache.org%3E,2017-04-14 10:58,commits,23.0,343.0,  [15/20] camel git commit: CAMEL-10141: make camel-example-cafe tests pass on Java 9
138,344.0,davscl...@apache.org,"CAMEL-10968: skip CXF tests on Java 9 until CXF-7270 is resolved&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/925bfe65&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/925bfe65&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/925bfe65&#010;&#010;Branch: refs/heads/master&#010;Commit: 925bfe6592ca4831497bfe1c79e8e98f78c0f908&#010;Parents: a01f14c&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:07:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cxf/pom.xml              | 20 ++++++++++++++++&#010; .../pom.xml                                     | 22 ++++++++++++++++++&#010; tests/camel-blueprint-cxf-test/pom.xml          | 24 +++++++++++++++++++-&#010; 3 files changed, 65 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/925bfe65/examples/camel-example-cxf/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cxf/pom.xml b/examples/camel-example-cxf/pom.xml&#010;index cc3f12f..d87f88f 100644&#010;--- a/examples/camel-example-cxf/pom.xml&#010;+++ b/examples/camel-example-cxf/pom.xml&#010;@@ -245,6 +245,26 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.cxf.jaxrs.Client&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;java9&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;excludes&gt;&#010;+                &lt;!--ignore tests until CXF-7270 is resolved and released--&gt;&#010;+                &lt;exclude&gt;**/**&lt;/exclude&gt;&#010;+              &lt;/excludes&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/925bfe65/examples/camel-example-reportincident-wssecurity/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-reportincident-wssecurity/pom.xml b/examples/camel-example-reportincident-wssecurity/pom.xml&#010;index 143583f..8ff14c2 100644&#010;--- a/examples/camel-example-reportincident-wssecurity/pom.xml&#010;+++ b/examples/camel-example-reportincident-wssecurity/pom.xml&#010;@@ -226,4 +226,26 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;java9&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;excludes&gt;&#010;+                &lt;!--ignore tests until CXF-7270 is resolved and released--&gt;&#010;+                &lt;exclude&gt;**/**&lt;/exclude&gt;&#010;+              &lt;/excludes&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/925bfe65/tests/camel-blueprint-cxf-test/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/tests/camel-blueprint-cxf-test/pom.xml b/tests/camel-blueprint-cxf-test/pom.xml&#010;index 6948da8..3e790b1 100644&#010;--- a/tests/camel-blueprint-cxf-test/pom.xml&#010;+++ b/tests/camel-blueprint-cxf-test/pom.xml&#010;@@ -195,5 +195,27 @@&#010;     &lt;/dependency&gt;&#010; &#010;   &lt;/dependencies&gt;&#010;-&#010;+  &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;java9&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;excludes&gt;&#010;+                &lt;!--ignore tests until CXF-7270 is resolved and released--&gt;&#010;+                &lt;exclude&gt;**/**&lt;/exclude&gt;&#010;+              &lt;/excludes&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cf223533da6264a95bdf7c35eb48a0936%40git.apache.org%3E,2017-04-14 10:58,commits,23.0,344.0,  [16/20] camel git commit: CAMEL-10968: skip CXF tests on Java 9 until CXF-7270 is resolved
139,345.0,davscl...@apache.org,"CAMEL-10968: skip CXF tests on Java 9 until CXF-7270 is resolved&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/7b2d32e1&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/7b2d32e1&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/7b2d32e1&#010;&#010;Branch: refs/heads/master&#010;Commit: 7b2d32e1292f7d5f2515b018527aba8d6e95846b&#010;Parents: f0cc62e&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:04:57 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; components/camel-cxf/pom.xml | 21 ++++++++++++++++++++-&#010; 1 file changed, 20 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/7b2d32e1/components/camel-cxf/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/components/camel-cxf/pom.xml b/components/camel-cxf/pom.xml&#010;index 70f782e..2503adf 100644&#010;--- a/components/camel-cxf/pom.xml&#010;+++ b/components/camel-cxf/pom.xml&#010;@@ -492,6 +492,25 @@&#010;         &lt;/dependency&gt;&#010;       &lt;/dependencies&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;java9&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;excludes&gt;&#010;+                &lt;!--ignore tests until CXF-7270 is resolved and released--&gt;&#010;+                &lt;exclude&gt;**/**&lt;/exclude&gt;&#010;+              &lt;/excludes&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C6ae8575032e649018fd66bcbb39bfa36%40git.apache.org%3E,2017-04-14 10:58,commits,23.0,345.0,  [17/20] camel git commit: CAMEL-10968: skip CXF tests on Java 9 until CXF-7270 is resolved
140,346.0,davscl...@apache.org,"CAMEL-10968: make camel-example-cxf-osgi tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/bb7bd6ab&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/bb7bd6ab&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/bb7bd6ab&#010;&#010;Branch: refs/heads/master&#010;Commit: bb7bd6ab35a2984bb041e7021039136678315d47&#010;Parents: 925bfe6&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:50:01 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cxf-osgi/pom.xml | 19 +++++++++++++++++++&#010; 1 file changed, 19 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/bb7bd6ab/examples/camel-example-cxf-osgi/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cxf-osgi/pom.xml b/examples/camel-example-cxf-osgi/pom.xml&#010;index 04e8e79..8c2c773 100644&#010;--- a/examples/camel-example-cxf-osgi/pom.xml&#010;+++ b/examples/camel-example-cxf-osgi/pom.xml&#010;@@ -159,4 +159,23 @@&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;+  &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.activation,java.xml.bind,java.xml.ws,jdk.xml.bind&#010;--add-opens java.base/java.lang=ALL-UNNAMED --add-exports=java.naming/com.sun.jndi.ldap=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime.reflect=ALL-UNNAMED --add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap.impl=ALL-UNNAMED&#010;--add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap=ALL-UNNAMED --add-opens&#010;java.base/java.net=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cb7b76d890975415b8e3d8088aa623a6f%40git.apache.org%3E,2017-04-14 10:58,commits,23.0,346.0,  [18/20] camel git commit: CAMEL-10968: make camel-example-cxf-osgi tests pass on Java 9
141,347.0,davscl...@apache.org,"CAMEL-10968: make camel-example-loan-broker-cxf tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/1ca0ec4d&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/1ca0ec4d&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/1ca0ec4d&#010;&#010;Branch: refs/heads/master&#010;Commit: 1ca0ec4dac23930357bb62ac587b8047d332cf0f&#010;Parents: 8a23104&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:56:22 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-loan-broker-cxf/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/1ca0ec4d/examples/camel-example-loan-broker-cxf/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-loan-broker-cxf/pom.xml b/examples/camel-example-loan-broker-cxf/pom.xml&#010;index b5180c5..e6c5db0 100644&#010;--- a/examples/camel-example-loan-broker-cxf/pom.xml&#010;+++ b/examples/camel-example-loan-broker-cxf/pom.xml&#010;@@ -170,6 +170,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.loanbroker.Client&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cabfdccad36ad4d6ba0d229dc4c4050cd%40git.apache.org%3E,2017-04-14 10:58,commits,23.0,347.0,  [19/20] camel git commit: CAMEL-10968: make camel-example-loan-broker-cxf tests pass on Java 9
142,348.0,davscl...@apache.org,"CAMEL-10968: make camel-example-cxf-proxy tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/44d333fe&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/44d333fe&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/44d333fe&#010;&#010;Branch: refs/heads/master&#010;Commit: 44d333fe7cc2d5bdc1f452a16e5c3923edd9ea10&#010;Parents: bb7bd6a&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:52:00 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cxf-proxy/pom.xml | 20 +++++++++++++++++++-&#010; 1 file changed, 19 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/44d333fe/examples/camel-example-cxf-proxy/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cxf-proxy/pom.xml b/examples/camel-example-cxf-proxy/pom.xml&#010;index be68c33..6c08ee7 100755&#010;--- a/examples/camel-example-cxf-proxy/pom.xml&#010;+++ b/examples/camel-example-cxf-proxy/pom.xml&#010;@@ -152,5 +152,23 @@&#010; &#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;-&#010;+  &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.activation,java.xml.bind,java.xml.ws,jdk.xml.bind&#010;--add-opens java.base/java.lang=ALL-UNNAMED --add-exports=java.naming/com.sun.jndi.ldap=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime.reflect=ALL-UNNAMED --add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap.impl=ALL-UNNAMED&#010;--add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap=ALL-UNNAMED --add-opens&#010;java.base/java.net=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C846df69249224f8fad5cf4414e42b733%40git.apache.org%3E,2017-04-14 10:58,commits,23.0,348.0,  [20/20] camel git commit: CAMEL-10968: make camel-example-cxf-proxy tests pass on Java 9
143,344.0,davscl...@apache.org,"CAMEL-10968: skip CXF tests on Java 9 until CXF-7270 is resolved&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/925bfe65&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/925bfe65&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/925bfe65&#010;&#010;Branch: refs/heads/master&#010;Commit: 925bfe6592ca4831497bfe1c79e8e98f78c0f908&#010;Parents: a01f14c&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:07:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cxf/pom.xml              | 20 ++++++++++++++++&#010; .../pom.xml                                     | 22 ++++++++++++++++++&#010; tests/camel-blueprint-cxf-test/pom.xml          | 24 +++++++++++++++++++-&#010; 3 files changed, 65 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/925bfe65/examples/camel-example-cxf/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cxf/pom.xml b/examples/camel-example-cxf/pom.xml&#010;index cc3f12f..d87f88f 100644&#010;--- a/examples/camel-example-cxf/pom.xml&#010;+++ b/examples/camel-example-cxf/pom.xml&#010;@@ -245,6 +245,26 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.cxf.jaxrs.Client&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;java9&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;excludes&gt;&#010;+                &lt;!--ignore tests until CXF-7270 is resolved and released--&gt;&#010;+                &lt;exclude&gt;**/**&lt;/exclude&gt;&#010;+              &lt;/excludes&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/925bfe65/examples/camel-example-reportincident-wssecurity/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-reportincident-wssecurity/pom.xml b/examples/camel-example-reportincident-wssecurity/pom.xml&#010;index 143583f..8ff14c2 100644&#010;--- a/examples/camel-example-reportincident-wssecurity/pom.xml&#010;+++ b/examples/camel-example-reportincident-wssecurity/pom.xml&#010;@@ -226,4 +226,26 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;java9&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;excludes&gt;&#010;+                &lt;!--ignore tests until CXF-7270 is resolved and released--&gt;&#010;+                &lt;exclude&gt;**/**&lt;/exclude&gt;&#010;+              &lt;/excludes&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/925bfe65/tests/camel-blueprint-cxf-test/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/tests/camel-blueprint-cxf-test/pom.xml b/tests/camel-blueprint-cxf-test/pom.xml&#010;index 6948da8..3e790b1 100644&#010;--- a/tests/camel-blueprint-cxf-test/pom.xml&#010;+++ b/tests/camel-blueprint-cxf-test/pom.xml&#010;@@ -195,5 +195,27 @@&#010;     &lt;/dependency&gt;&#010; &#010;   &lt;/dependencies&gt;&#010;-&#010;+  &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;java9&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;excludes&gt;&#010;+                &lt;!--ignore tests until CXF-7270 is resolved and released--&gt;&#010;+                &lt;exclude&gt;**/**&lt;/exclude&gt;&#010;+              &lt;/excludes&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cf223533da6264a95bdf7c35eb48a0936%40git.apache.org%3E,2017-04-14 10:58,commits,24.0,344.0,  [16/20] camel git commit: CAMEL-10968: skip CXF tests on Java 9 until CXF-7270 is resolved
144,345.0,davscl...@apache.org,"CAMEL-10968: skip CXF tests on Java 9 until CXF-7270 is resolved&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/7b2d32e1&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/7b2d32e1&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/7b2d32e1&#010;&#010;Branch: refs/heads/master&#010;Commit: 7b2d32e1292f7d5f2515b018527aba8d6e95846b&#010;Parents: f0cc62e&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:04:57 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; components/camel-cxf/pom.xml | 21 ++++++++++++++++++++-&#010; 1 file changed, 20 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/7b2d32e1/components/camel-cxf/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/components/camel-cxf/pom.xml b/components/camel-cxf/pom.xml&#010;index 70f782e..2503adf 100644&#010;--- a/components/camel-cxf/pom.xml&#010;+++ b/components/camel-cxf/pom.xml&#010;@@ -492,6 +492,25 @@&#010;         &lt;/dependency&gt;&#010;       &lt;/dependencies&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;java9&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;excludes&gt;&#010;+                &lt;!--ignore tests until CXF-7270 is resolved and released--&gt;&#010;+                &lt;exclude&gt;**/**&lt;/exclude&gt;&#010;+              &lt;/excludes&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C6ae8575032e649018fd66bcbb39bfa36%40git.apache.org%3E,2017-04-14 10:58,commits,24.0,345.0,  [17/20] camel git commit: CAMEL-10968: skip CXF tests on Java 9 until CXF-7270 is resolved
145,346.0,davscl...@apache.org,"CAMEL-10968: make camel-example-cxf-osgi tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/bb7bd6ab&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/bb7bd6ab&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/bb7bd6ab&#010;&#010;Branch: refs/heads/master&#010;Commit: bb7bd6ab35a2984bb041e7021039136678315d47&#010;Parents: 925bfe6&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:50:01 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cxf-osgi/pom.xml | 19 +++++++++++++++++++&#010; 1 file changed, 19 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/bb7bd6ab/examples/camel-example-cxf-osgi/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cxf-osgi/pom.xml b/examples/camel-example-cxf-osgi/pom.xml&#010;index 04e8e79..8c2c773 100644&#010;--- a/examples/camel-example-cxf-osgi/pom.xml&#010;+++ b/examples/camel-example-cxf-osgi/pom.xml&#010;@@ -159,4 +159,23 @@&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;+  &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.activation,java.xml.bind,java.xml.ws,jdk.xml.bind&#010;--add-opens java.base/java.lang=ALL-UNNAMED --add-exports=java.naming/com.sun.jndi.ldap=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime.reflect=ALL-UNNAMED --add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap.impl=ALL-UNNAMED&#010;--add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap=ALL-UNNAMED --add-opens&#010;java.base/java.net=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cb7b76d890975415b8e3d8088aa623a6f%40git.apache.org%3E,2017-04-14 10:58,commits,24.0,346.0,  [18/20] camel git commit: CAMEL-10968: make camel-example-cxf-osgi tests pass on Java 9
146,347.0,davscl...@apache.org,"CAMEL-10968: make camel-example-loan-broker-cxf tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/1ca0ec4d&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/1ca0ec4d&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/1ca0ec4d&#010;&#010;Branch: refs/heads/master&#010;Commit: 1ca0ec4dac23930357bb62ac587b8047d332cf0f&#010;Parents: 8a23104&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:56:22 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-loan-broker-cxf/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/1ca0ec4d/examples/camel-example-loan-broker-cxf/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-loan-broker-cxf/pom.xml b/examples/camel-example-loan-broker-cxf/pom.xml&#010;index b5180c5..e6c5db0 100644&#010;--- a/examples/camel-example-loan-broker-cxf/pom.xml&#010;+++ b/examples/camel-example-loan-broker-cxf/pom.xml&#010;@@ -170,6 +170,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.loanbroker.Client&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cabfdccad36ad4d6ba0d229dc4c4050cd%40git.apache.org%3E,2017-04-14 10:58,commits,24.0,347.0,  [19/20] camel git commit: CAMEL-10968: make camel-example-loan-broker-cxf tests pass on Java 9
147,348.0,davscl...@apache.org,"CAMEL-10968: make camel-example-cxf-proxy tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/44d333fe&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/44d333fe&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/44d333fe&#010;&#010;Branch: refs/heads/master&#010;Commit: 44d333fe7cc2d5bdc1f452a16e5c3923edd9ea10&#010;Parents: bb7bd6a&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:52:00 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cxf-proxy/pom.xml | 20 +++++++++++++++++++-&#010; 1 file changed, 19 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/44d333fe/examples/camel-example-cxf-proxy/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cxf-proxy/pom.xml b/examples/camel-example-cxf-proxy/pom.xml&#010;index be68c33..6c08ee7 100755&#010;--- a/examples/camel-example-cxf-proxy/pom.xml&#010;+++ b/examples/camel-example-cxf-proxy/pom.xml&#010;@@ -152,5 +152,23 @@&#010; &#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;-&#010;+  &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.activation,java.xml.bind,java.xml.ws,jdk.xml.bind&#010;--add-opens java.base/java.lang=ALL-UNNAMED --add-exports=java.naming/com.sun.jndi.ldap=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime.reflect=ALL-UNNAMED --add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap.impl=ALL-UNNAMED&#010;--add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap=ALL-UNNAMED --add-opens&#010;java.base/java.net=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C846df69249224f8fad5cf4414e42b733%40git.apache.org%3E,2017-04-14 10:58,commits,24.0,348.0,  [20/20] camel git commit: CAMEL-10968: make camel-example-cxf-proxy tests pass on Java 9
148,344.0,davscl...@apache.org,"CAMEL-10968: skip CXF tests on Java 9 until CXF-7270 is resolved&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/925bfe65&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/925bfe65&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/925bfe65&#010;&#010;Branch: refs/heads/master&#010;Commit: 925bfe6592ca4831497bfe1c79e8e98f78c0f908&#010;Parents: a01f14c&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:07:21 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cxf/pom.xml              | 20 ++++++++++++++++&#010; .../pom.xml                                     | 22 ++++++++++++++++++&#010; tests/camel-blueprint-cxf-test/pom.xml          | 24 +++++++++++++++++++-&#010; 3 files changed, 65 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/925bfe65/examples/camel-example-cxf/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cxf/pom.xml b/examples/camel-example-cxf/pom.xml&#010;index cc3f12f..d87f88f 100644&#010;--- a/examples/camel-example-cxf/pom.xml&#010;+++ b/examples/camel-example-cxf/pom.xml&#010;@@ -245,6 +245,26 @@&#010;         &lt;target.main.class&gt;org.apache.camel.example.cxf.jaxrs.Client&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;java9&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;excludes&gt;&#010;+                &lt;!--ignore tests until CXF-7270 is resolved and released--&gt;&#010;+                &lt;exclude&gt;**/**&lt;/exclude&gt;&#010;+              &lt;/excludes&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010;   &lt;build&gt;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/925bfe65/examples/camel-example-reportincident-wssecurity/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-reportincident-wssecurity/pom.xml b/examples/camel-example-reportincident-wssecurity/pom.xml&#010;index 143583f..8ff14c2 100644&#010;--- a/examples/camel-example-reportincident-wssecurity/pom.xml&#010;+++ b/examples/camel-example-reportincident-wssecurity/pom.xml&#010;@@ -226,4 +226,26 @@&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010; &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;java9&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;excludes&gt;&#010;+                &lt;!--ignore tests until CXF-7270 is resolved and released--&gt;&#010;+                &lt;exclude&gt;**/**&lt;/exclude&gt;&#010;+              &lt;/excludes&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/925bfe65/tests/camel-blueprint-cxf-test/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/tests/camel-blueprint-cxf-test/pom.xml b/tests/camel-blueprint-cxf-test/pom.xml&#010;index 6948da8..3e790b1 100644&#010;--- a/tests/camel-blueprint-cxf-test/pom.xml&#010;+++ b/tests/camel-blueprint-cxf-test/pom.xml&#010;@@ -195,5 +195,27 @@&#010;     &lt;/dependency&gt;&#010; &#010;   &lt;/dependencies&gt;&#010;-&#010;+  &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;java9&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;excludes&gt;&#010;+                &lt;!--ignore tests until CXF-7270 is resolved and released--&gt;&#010;+                &lt;exclude&gt;**/**&lt;/exclude&gt;&#010;+              &lt;/excludes&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cf223533da6264a95bdf7c35eb48a0936%40git.apache.org%3E,2017-04-14 10:58,commits,25.0,344.0,  [16/20] camel git commit: CAMEL-10968: skip CXF tests on Java 9 until CXF-7270 is resolved
149,345.0,davscl...@apache.org,"CAMEL-10968: skip CXF tests on Java 9 until CXF-7270 is resolved&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/7b2d32e1&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/7b2d32e1&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/7b2d32e1&#010;&#010;Branch: refs/heads/master&#010;Commit: 7b2d32e1292f7d5f2515b018527aba8d6e95846b&#010;Parents: f0cc62e&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:04:57 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; components/camel-cxf/pom.xml | 21 ++++++++++++++++++++-&#010; 1 file changed, 20 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/7b2d32e1/components/camel-cxf/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/components/camel-cxf/pom.xml b/components/camel-cxf/pom.xml&#010;index 70f782e..2503adf 100644&#010;--- a/components/camel-cxf/pom.xml&#010;+++ b/components/camel-cxf/pom.xml&#010;@@ -492,6 +492,25 @@&#010;         &lt;/dependency&gt;&#010;       &lt;/dependencies&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;java9&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;excludes&gt;&#010;+                &lt;!--ignore tests until CXF-7270 is resolved and released--&gt;&#010;+                &lt;exclude&gt;**/**&lt;/exclude&gt;&#010;+              &lt;/excludes&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010;-&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C6ae8575032e649018fd66bcbb39bfa36%40git.apache.org%3E,2017-04-14 10:58,commits,25.0,345.0,  [17/20] camel git commit: CAMEL-10968: skip CXF tests on Java 9 until CXF-7270 is resolved
150,346.0,davscl...@apache.org,"CAMEL-10968: make camel-example-cxf-osgi tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/bb7bd6ab&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/bb7bd6ab&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/bb7bd6ab&#010;&#010;Branch: refs/heads/master&#010;Commit: bb7bd6ab35a2984bb041e7021039136678315d47&#010;Parents: 925bfe6&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:50:01 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cxf-osgi/pom.xml | 19 +++++++++++++++++++&#010; 1 file changed, 19 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/bb7bd6ab/examples/camel-example-cxf-osgi/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cxf-osgi/pom.xml b/examples/camel-example-cxf-osgi/pom.xml&#010;index 04e8e79..8c2c773 100644&#010;--- a/examples/camel-example-cxf-osgi/pom.xml&#010;+++ b/examples/camel-example-cxf-osgi/pom.xml&#010;@@ -159,4 +159,23 @@&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;+  &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.activation,java.xml.bind,java.xml.ws,jdk.xml.bind&#010;--add-opens java.base/java.lang=ALL-UNNAMED --add-exports=java.naming/com.sun.jndi.ldap=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime.reflect=ALL-UNNAMED --add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap.impl=ALL-UNNAMED&#010;--add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap=ALL-UNNAMED --add-opens&#010;java.base/java.net=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cb7b76d890975415b8e3d8088aa623a6f%40git.apache.org%3E,2017-04-14 10:58,commits,25.0,346.0,  [18/20] camel git commit: CAMEL-10968: make camel-example-cxf-osgi tests pass on Java 9
151,347.0,davscl...@apache.org,"CAMEL-10968: make camel-example-loan-broker-cxf tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/1ca0ec4d&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/1ca0ec4d&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/1ca0ec4d&#010;&#010;Branch: refs/heads/master&#010;Commit: 1ca0ec4dac23930357bb62ac587b8047d332cf0f&#010;Parents: 8a23104&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:56:22 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-loan-broker-cxf/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/1ca0ec4d/examples/camel-example-loan-broker-cxf/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-loan-broker-cxf/pom.xml b/examples/camel-example-loan-broker-cxf/pom.xml&#010;index b5180c5..e6c5db0 100644&#010;--- a/examples/camel-example-loan-broker-cxf/pom.xml&#010;+++ b/examples/camel-example-loan-broker-cxf/pom.xml&#010;@@ -170,6 +170,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.loanbroker.Client&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cabfdccad36ad4d6ba0d229dc4c4050cd%40git.apache.org%3E,2017-04-14 10:58,commits,25.0,347.0,  [19/20] camel git commit: CAMEL-10968: make camel-example-loan-broker-cxf tests pass on Java 9
152,348.0,davscl...@apache.org,"CAMEL-10968: make camel-example-cxf-proxy tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/44d333fe&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/44d333fe&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/44d333fe&#010;&#010;Branch: refs/heads/master&#010;Commit: 44d333fe7cc2d5bdc1f452a16e5c3923edd9ea10&#010;Parents: bb7bd6a&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:52:00 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cxf-proxy/pom.xml | 20 +++++++++++++++++++-&#010; 1 file changed, 19 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/44d333fe/examples/camel-example-cxf-proxy/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cxf-proxy/pom.xml b/examples/camel-example-cxf-proxy/pom.xml&#010;index be68c33..6c08ee7 100755&#010;--- a/examples/camel-example-cxf-proxy/pom.xml&#010;+++ b/examples/camel-example-cxf-proxy/pom.xml&#010;@@ -152,5 +152,23 @@&#010; &#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;-&#010;+  &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.activation,java.xml.bind,java.xml.ws,jdk.xml.bind&#010;--add-opens java.base/java.lang=ALL-UNNAMED --add-exports=java.naming/com.sun.jndi.ldap=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime.reflect=ALL-UNNAMED --add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap.impl=ALL-UNNAMED&#010;--add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap=ALL-UNNAMED --add-opens&#010;java.base/java.net=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C846df69249224f8fad5cf4414e42b733%40git.apache.org%3E,2017-04-14 10:58,commits,25.0,348.0,  [20/20] camel git commit: CAMEL-10968: make camel-example-cxf-proxy tests pass on Java 9
153,346.0,davscl...@apache.org,"CAMEL-10968: make camel-example-cxf-osgi tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/bb7bd6ab&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/bb7bd6ab&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/bb7bd6ab&#010;&#010;Branch: refs/heads/master&#010;Commit: bb7bd6ab35a2984bb041e7021039136678315d47&#010;Parents: 925bfe6&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:50:01 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cxf-osgi/pom.xml | 19 +++++++++++++++++++&#010; 1 file changed, 19 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/bb7bd6ab/examples/camel-example-cxf-osgi/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cxf-osgi/pom.xml b/examples/camel-example-cxf-osgi/pom.xml&#010;index 04e8e79..8c2c773 100644&#010;--- a/examples/camel-example-cxf-osgi/pom.xml&#010;+++ b/examples/camel-example-cxf-osgi/pom.xml&#010;@@ -159,4 +159,23 @@&#010;       &lt;/plugin&gt;&#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;+  &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.activation,java.xml.bind,java.xml.ws,jdk.xml.bind&#010;--add-opens java.base/java.lang=ALL-UNNAMED --add-exports=java.naming/com.sun.jndi.ldap=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime.reflect=ALL-UNNAMED --add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap.impl=ALL-UNNAMED&#010;--add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap=ALL-UNNAMED --add-opens&#010;java.base/java.net=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cb7b76d890975415b8e3d8088aa623a6f%40git.apache.org%3E,2017-04-14 10:58,commits,26.0,346.0,  [18/20] camel git commit: CAMEL-10968: make camel-example-cxf-osgi tests pass on Java 9
154,347.0,davscl...@apache.org,"CAMEL-10968: make camel-example-loan-broker-cxf tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/1ca0ec4d&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/1ca0ec4d&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/1ca0ec4d&#010;&#010;Branch: refs/heads/master&#010;Commit: 1ca0ec4dac23930357bb62ac587b8047d332cf0f&#010;Parents: 8a23104&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:56:22 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-loan-broker-cxf/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/1ca0ec4d/examples/camel-example-loan-broker-cxf/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-loan-broker-cxf/pom.xml b/examples/camel-example-loan-broker-cxf/pom.xml&#010;index b5180c5..e6c5db0 100644&#010;--- a/examples/camel-example-loan-broker-cxf/pom.xml&#010;+++ b/examples/camel-example-loan-broker-cxf/pom.xml&#010;@@ -170,6 +170,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.loanbroker.Client&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cabfdccad36ad4d6ba0d229dc4c4050cd%40git.apache.org%3E,2017-04-14 10:58,commits,26.0,347.0,  [19/20] camel git commit: CAMEL-10968: make camel-example-loan-broker-cxf tests pass on Java 9
155,348.0,davscl...@apache.org,"CAMEL-10968: make camel-example-cxf-proxy tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/44d333fe&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/44d333fe&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/44d333fe&#010;&#010;Branch: refs/heads/master&#010;Commit: 44d333fe7cc2d5bdc1f452a16e5c3923edd9ea10&#010;Parents: bb7bd6a&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:52:00 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cxf-proxy/pom.xml | 20 +++++++++++++++++++-&#010; 1 file changed, 19 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/44d333fe/examples/camel-example-cxf-proxy/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cxf-proxy/pom.xml b/examples/camel-example-cxf-proxy/pom.xml&#010;index be68c33..6c08ee7 100755&#010;--- a/examples/camel-example-cxf-proxy/pom.xml&#010;+++ b/examples/camel-example-cxf-proxy/pom.xml&#010;@@ -152,5 +152,23 @@&#010; &#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;-&#010;+  &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.activation,java.xml.bind,java.xml.ws,jdk.xml.bind&#010;--add-opens java.base/java.lang=ALL-UNNAMED --add-exports=java.naming/com.sun.jndi.ldap=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime.reflect=ALL-UNNAMED --add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap.impl=ALL-UNNAMED&#010;--add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap=ALL-UNNAMED --add-opens&#010;java.base/java.net=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C846df69249224f8fad5cf4414e42b733%40git.apache.org%3E,2017-04-14 10:58,commits,26.0,348.0,  [20/20] camel git commit: CAMEL-10968: make camel-example-cxf-proxy tests pass on Java 9
156,347.0,davscl...@apache.org,"CAMEL-10968: make camel-example-loan-broker-cxf tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/1ca0ec4d&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/1ca0ec4d&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/1ca0ec4d&#010;&#010;Branch: refs/heads/master&#010;Commit: 1ca0ec4dac23930357bb62ac587b8047d332cf0f&#010;Parents: 8a23104&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:56:22 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-loan-broker-cxf/pom.xml | 16 ++++++++++++++++&#010; 1 file changed, 16 insertions(+)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/1ca0ec4d/examples/camel-example-loan-broker-cxf/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-loan-broker-cxf/pom.xml b/examples/camel-example-loan-broker-cxf/pom.xml&#010;index b5180c5..e6c5db0 100644&#010;--- a/examples/camel-example-loan-broker-cxf/pom.xml&#010;+++ b/examples/camel-example-loan-broker-cxf/pom.xml&#010;@@ -170,6 +170,22 @@&#010;         &lt;target.main.class&gt;org.apache.camel.loanbroker.Client&lt;/target.main.class&gt;&#010;       &lt;/properties&gt;&#010;     &lt;/profile&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.xml.bind,java.xml.ws --add-opens java.base/java.lang=ALL-UNNAMED&#010;--add-opens java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;   &lt;/profiles&gt;&#010; &#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3Cabfdccad36ad4d6ba0d229dc4c4050cd%40git.apache.org%3E,2017-04-14 10:58,commits,27.0,347.0,  [19/20] camel git commit: CAMEL-10968: make camel-example-loan-broker-cxf tests pass on Java 9
157,348.0,davscl...@apache.org,"CAMEL-10968: make camel-example-cxf-proxy tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/44d333fe&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/44d333fe&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/44d333fe&#010;&#010;Branch: refs/heads/master&#010;Commit: 44d333fe7cc2d5bdc1f452a16e5c3923edd9ea10&#010;Parents: bb7bd6a&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:52:00 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cxf-proxy/pom.xml | 20 +++++++++++++++++++-&#010; 1 file changed, 19 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/44d333fe/examples/camel-example-cxf-proxy/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cxf-proxy/pom.xml b/examples/camel-example-cxf-proxy/pom.xml&#010;index be68c33..6c08ee7 100755&#010;--- a/examples/camel-example-cxf-proxy/pom.xml&#010;+++ b/examples/camel-example-cxf-proxy/pom.xml&#010;@@ -152,5 +152,23 @@&#010; &#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;-&#010;+  &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.activation,java.xml.bind,java.xml.ws,jdk.xml.bind&#010;--add-opens java.base/java.lang=ALL-UNNAMED --add-exports=java.naming/com.sun.jndi.ldap=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime.reflect=ALL-UNNAMED --add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap.impl=ALL-UNNAMED&#010;--add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap=ALL-UNNAMED --add-opens&#010;java.base/java.net=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C846df69249224f8fad5cf4414e42b733%40git.apache.org%3E,2017-04-14 10:58,commits,27.0,348.0,  [20/20] camel git commit: CAMEL-10968: make camel-example-cxf-proxy tests pass on Java 9
158,348.0,davscl...@apache.org,"CAMEL-10968: make camel-example-cxf-proxy tests pass on Java 9&#010;&#010;&#010;Project: http://git-wip-us.apache.org/repos/asf/camel/repo&#010;Commit: http://git-wip-us.apache.org/repos/asf/camel/commit/44d333fe&#010;Tree: http://git-wip-us.apache.org/repos/asf/camel/tree/44d333fe&#010;Diff: http://git-wip-us.apache.org/repos/asf/camel/diff/44d333fe&#010;&#010;Branch: refs/heads/master&#010;Commit: 44d333fe7cc2d5bdc1f452a16e5c3923edd9ea10&#010;Parents: bb7bd6a&#010;Author: jpoth &lt;poth.john@gmail.com&gt;&#010;Authored: Fri Apr 14 11:52:00 2017 +0200&#010;Committer: Claus Ibsen &lt;davsclaus@apache.org&gt;&#010;Committed: Fri Apr 14 12:57:21 2017 +0200&#010;&#010;----------------------------------------------------------------------&#010; examples/camel-example-cxf-proxy/pom.xml | 20 +++++++++++++++++++-&#010; 1 file changed, 19 insertions(+), 1 deletion(-)&#010;----------------------------------------------------------------------&#010;&#010;&#010;http://git-wip-us.apache.org/repos/asf/camel/blob/44d333fe/examples/camel-example-cxf-proxy/pom.xml&#010;----------------------------------------------------------------------&#010;diff --git a/examples/camel-example-cxf-proxy/pom.xml b/examples/camel-example-cxf-proxy/pom.xml&#010;index be68c33..6c08ee7 100755&#010;--- a/examples/camel-example-cxf-proxy/pom.xml&#010;+++ b/examples/camel-example-cxf-proxy/pom.xml&#010;@@ -152,5 +152,23 @@&#010; &#010;     &lt;/plugins&gt;&#010;   &lt;/build&gt;&#010;-&#010;+  &#010;+  &lt;profiles&gt;&#010;+    &lt;profile&gt;&#010;+      &lt;id&gt;jdk9-build&lt;/id&gt;&#010;+      &lt;activation&gt;&#010;+        &lt;jdk&gt;9&lt;/jdk&gt;&#010;+      &lt;/activation&gt;&#010;+      &lt;build&gt;&#010;+        &lt;plugins&gt;&#010;+          &lt;plugin&gt;&#010;+            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;&#010;+            &lt;configuration&gt;&#010;+              &lt;argLine&gt;--add-modules java.activation,java.xml.bind,java.xml.ws,jdk.xml.bind&#010;--add-opens java.base/java.lang=ALL-UNNAMED --add-exports=java.naming/com.sun.jndi.ldap=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2=ALL-UNNAMED&#010;--add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime.reflect=ALL-UNNAMED --add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap.impl=ALL-UNNAMED&#010;--add-exports=java.xml.ws/com.sun.xml.internal.messaging.saaj.soap=ALL-UNNAMED --add-opens&#010;java.base/java.net=ALL-UNNAMED --add-exports=java.xml.bind/com.sun.xml.internal.bind.v2.runtime=ALL-UNNAMED&lt;/argLine&gt;&#010;+            &lt;/configuration&gt;&#010;+          &lt;/plugin&gt;&#010;+        &lt;/plugins&gt;&#010;+      &lt;/build&gt;&#010;+    &lt;/profile&gt;&#010;+  &lt;/profiles&gt;&#010; &lt;/project&gt;&#010;&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-commits/201704.mbox/ajax/%3C846df69249224f8fad5cf4414e42b733%40git.apache.org%3E,2017-04-14 10:58,commits,28.0,348.0,  [20/20] camel git commit: CAMEL-10968: make camel-example-cxf-proxy tests pass on Java 9
159,195.0,johnpoth,"Github user johnpoth closed the pull request at:&#010;&#010;    https://github.com/apache/camel/pull/1633&#010;&#010;&#010;---&#010;If your project is set up for it, you can reply to this email and have your&#010;reply appear on GitHub as well. If your project does not have this feature&#010;enabled and wishes so, or if the feature is enabled but not working, please&#010;contact infrastructure at infrastructure@apache.org or file a JIRA ticket&#010;with INFRA.&#010;---&#010;&#010;",http://mail-archives.apache.org/mod_mbox/camel-dev/201704.mbox/ajax/%3C20170414114012.0CE98DFDAC%40git1-us-west.apache.org%3E,2017-04-14 11:40,mails,32.0,195.0,  [GitHub] camel pull request #1633: Camel-10141 Lets pass remaining tests on Java 9 an...
